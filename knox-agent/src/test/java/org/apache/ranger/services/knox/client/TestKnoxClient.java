/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.services.knox.client;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.WebResource.Builder;
import com.sun.jersey.api.client.filter.HTTPBasicAuthFilter;
import org.apache.ranger.plugin.client.HadoopException;
import org.apache.ranger.plugin.util.PasswordUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description <Unit Test for KnoxClient class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestKnoxClient {
    @Test
    public void test01_connectionTest_success() {
        Map<String, String> configs = new HashMap<>();
        configs.put("knox.url", "https://example:8443/gateway/admin/api/v1/topologies");
        configs.put("username", "admin");
        configs.put("password", "pwd");

        try (MockedStatic<KnoxClient> knoxStatic = Mockito.mockStatic(KnoxClient.class)) {
            KnoxClient dummy = new KnoxClient("u", "u", "p");
            knoxStatic.when(() -> KnoxClient.connectionTest("svc", configs)).thenCallRealMethod();
            knoxStatic.when(() -> KnoxClient.getKnoxClient("svc", configs)).thenReturn(dummy);
            knoxStatic.when(() -> KnoxClient.getKnoxResources(Mockito.eq(dummy), anyString(), Mockito.isNull(),
                    Mockito.isNull(), Mockito.isNull())).thenReturn(Collections.singletonList("top1"));

            Map<String, Object> resp = KnoxClient.connectionTest("svc", configs);

            Assertions.assertNotNull(resp);
            Assertions.assertEquals(Boolean.TRUE, resp.get("connectivityStatus"));
            Assertions.assertEquals("ConnectionTest Successful", resp.get("message"));
            Assertions.assertEquals("ConnectionTest Successful", resp.get("description"));
            Assertions.assertNull(resp.get("objectId"));
            Assertions.assertNull(resp.get("fieldName"));
        }
    }

    @Test
    public void test02_connectionTest_failure() {
        Map<String, String> configs = new HashMap<>();
        configs.put("knox.url", "https://example:8443/gateway/admin/api/v1/topologies");
        configs.put("username", "admin");
        configs.put("password", "pwd");

        try (MockedStatic<KnoxClient> knoxStatic = Mockito.mockStatic(KnoxClient.class)) {
            KnoxClient dummy = new KnoxClient("u", "u", "p");
            knoxStatic.when(() -> KnoxClient.connectionTest("svc", configs)).thenCallRealMethod();
            knoxStatic.when(() -> KnoxClient.getKnoxClient("svc", configs)).thenReturn(dummy);
            knoxStatic.when(() -> KnoxClient.getKnoxResources(Mockito.eq(dummy), anyString(), Mockito.isNull(),
                    Mockito.isNull(), Mockito.isNull())).thenReturn(Collections.emptyList());

            Map<String, Object> resp = KnoxClient.connectionTest("svc", configs);

            Assertions.assertNotNull(resp);
            Assertions.assertEquals(Boolean.FALSE, resp.get("connectivityStatus"));
            Assertions.assertEquals("Unable to retrieve any topologies/services using given parameters.",
                    resp.get("message"));
            Assertions.assertTrue(String.valueOf(resp.get("description")).contains("You can still save"));
        }
    }

    @Test
    public void test03_getKnoxClient_validConfigs() {
        Map<String, String> configs = new HashMap<>();
        configs.put("knox.url", "https://example");
        configs.put("username", "admin");
        configs.put("password", "pwd");

        KnoxClient client = KnoxClient.getKnoxClient("svc", configs);
        Assertions.assertNotNull(client);
    }

    @Test
    public void test04_getKnoxClient_emptyConfigs_throws() {
        Map<String, String> configs = new HashMap<>();
        HadoopException ex = Assertions.assertThrows(HadoopException.class,
                () -> KnoxClient.getKnoxClient("svc", configs));
        Assertions.assertTrue(ex.getResponseData().containsKey("connectivityStatus"));
        Assertions.assertEquals(Boolean.FALSE, ex.getResponseData().get("connectivityStatus"));
        Assertions.assertTrue(String.valueOf(ex.getResponseData().get("description")).contains("You can still save"));
    }

    @Test
    public void test05_getKnoxResources_nullClient_throws() {
        HadoopException ex = Assertions.assertThrows(HadoopException.class,
                () -> KnoxClient.getKnoxResources(null, "t", null, null, null));
        Assertions.assertEquals(Boolean.FALSE, ex.getResponseData().get("connectivityStatus"));
    }

    @Test
    public void test06_getKnoxResources_callsTopologyList() throws Exception {
        KnoxClient knoxClient = mock(KnoxClient.class);
        List<String> expected = Arrays.asList("topA", "topB");
        when(knoxClient.getTopologyList(Mockito.eq("adm"), Mockito.isNull())).thenReturn(expected);

        List<String> result = KnoxClient.getKnoxResources(knoxClient, "adm", null, null, null);
        Assertions.assertEquals(expected, result);
    }

    @Test
    public void test07_getKnoxResources_callsServiceList() throws Exception {
        KnoxClient knoxClient = mock(KnoxClient.class);
        List<String> expected = Arrays.asList("HIVE", "NAMENODE");
        when(knoxClient.getServiceList(Mockito.anyList(), Mockito.eq("HI"), Mockito.isNull())).thenReturn(expected);

        List<String> topoList = new ArrayList<>();
        List<String> result = KnoxClient.getKnoxResources(knoxClient, null, "HI", topoList, null);
        Assertions.assertEquals(expected, result);
    }

    @Test
    public void test08_getKnoxResources_wrapsException() throws Exception {
        KnoxClient knoxClient = mock(KnoxClient.class);
        when(knoxClient.getTopologyList(Mockito.eq(""), Mockito.isNull())).thenThrow(new RuntimeException("boom"));

        HadoopException ex = Assertions.assertThrows(HadoopException.class,
                () -> KnoxClient.getKnoxResources(knoxClient, null, null, null, null));
        Assertions.assertTrue(String.valueOf(ex.getResponseData().get("description")).contains("You can still save"));
    }

    @Test
    public void test09_timedTask_success() throws Exception {
        String value = KnoxClient.timedTask(new Callable<String>() {
            @Override
            public String call() {
                return "ok";
            }
        }, 1L, TimeUnit.SECONDS);
        Assertions.assertEquals("ok", value);
    }

    @Test
    public void test10_timedTask_throws() {
        Assertions.assertThrows(Exception.class, () -> KnoxClient.timedTask(new Callable<String>() {
            @Override
            public String call() throws Exception {
                throw new Exception("x");
            }
        }, 1L, TimeUnit.SECONDS));
    }

    @Test
    public void test11_getTopologyList_status200_and_filters() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<PasswordUtils> pwStatic = Mockito.mockStatic(PasswordUtils.class);
                MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            pwStatic.when(() -> PasswordUtils.decryptPassword("pwd")).thenReturn("dec");

            Client jersey = mock(Client.class);
            WebResource wr = mock(WebResource.class);
            Builder builder = mock(Builder.class);
            ClientResponse response = mock(ClientResponse.class);

            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies")).thenReturn(wr);
            when(wr.accept("application/json")).thenReturn(builder);
            when(builder.get(ClientResponse.class)).thenReturn(response);

            when(response.getStatus()).thenReturn(200);
            String json = "{\"topology\":[{\"name\":\"admin\"},{\"name\":\"gateway\"}]}";
            when(response.getEntity(String.class)).thenReturn(json);

            List<String> listAll = client.getTopologyList("*", null);
            Assertions.assertEquals(2, listAll.size());

            List<String> listFiltered = client.getTopologyList("adm", null);
            Assertions.assertEquals(1, listFiltered.size());

            List<String> skipDueToContains = client.getTopologyList("adm", Collections.singletonList("adm"));
            Assertions.assertTrue(skipDueToContains.isEmpty());

            verify(response, times(3)).close();
            verify(jersey, times(3)).destroy();
        }
    }

    @Test
    public void test12_getTopologyList_statusNot200_returnsEmpty() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            Client jersey = mock(Client.class);
            WebResource wr = mock(WebResource.class);
            Builder builder = mock(Builder.class);
            ClientResponse response = mock(ClientResponse.class);

            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies")).thenReturn(wr);
            when(wr.accept("application/json")).thenReturn(builder);
            when(builder.get(ClientResponse.class)).thenReturn(response);

            when(response.getStatus()).thenReturn(500);

            List<String> list = client.getTopologyList("*", null);
            Assertions.assertTrue(list.isEmpty());
        }
    }

    @Test
    public void test13_getTopologyList_responseNull_throws() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            Client jersey = mock(Client.class);
            WebResource wr = mock(WebResource.class);
            Builder builder = mock(Builder.class);

            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies")).thenReturn(wr);
            when(wr.accept("application/json")).thenReturn(builder);
            when(builder.get(ClientResponse.class)).thenReturn(null);

            Assertions.assertThrows(HadoopException.class, () -> client.getTopologyList("*", null));
        }
    }

    @Test
    public void test14_getTopologyList_throwsWrapped() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            Client jersey = mock(Client.class);
            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies")).thenThrow(new RuntimeException("boom"));

            Assertions.assertThrows(HadoopException.class, () -> client.getTopologyList("*", null));
        }
    }

    @Test
    public void test15_getServiceList_happyPath_andFilters() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<PasswordUtils> pwStatic = Mockito.mockStatic(PasswordUtils.class);
                MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            pwStatic.when(() -> PasswordUtils.decryptPassword("pwd")).thenReturn("dec");

            Client jersey = mock(Client.class);
            WebResource wr = mock(WebResource.class);
            Builder builder = mock(Builder.class);
            ClientResponse response = mock(ClientResponse.class);

            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies/top1")).thenReturn(wr);
            when(wr.accept("application/json")).thenReturn(builder);
            when(builder.get(ClientResponse.class)).thenReturn(response);

            when(response.getStatus()).thenReturn(200);
            String json = "{\"topology\":{\"service\":[{\"role\":\"HIVE\"},{\"role\":\"NAMENODE\"}]}}";
            when(response.getEntity(String.class)).thenReturn(json);

            List<String> tops = Collections.singletonList("top1");
            List<String> all = client.getServiceList(tops, "*", null);
            Assertions.assertEquals(2, all.size());

            List<String> filtered = client.getServiceList(tops, "HI", null);
            Assertions.assertEquals(1, filtered.size());

            List<String> skip = client.getServiceList(tops, "HI", Collections.singletonList("HIVE"));
            Assertions.assertTrue(skip.isEmpty());
        }
    }

    @Test
    public void test16_getServiceList_statusNot200_logsAndContinues() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            Client jersey = mock(Client.class);
            WebResource wr = mock(WebResource.class);
            Builder builder = mock(Builder.class);
            ClientResponse response = mock(ClientResponse.class);

            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies/top1")).thenReturn(wr);
            when(wr.accept("application/json")).thenReturn(builder);
            when(builder.get(ClientResponse.class)).thenReturn(response);

            when(response.getStatus()).thenReturn(500);

            List<String> list = client.getServiceList(Collections.singletonList("top1"), "*", null);
            Assertions.assertTrue(list.isEmpty());
        }
    }

    @Test
    public void test17_getServiceList_responseNull_throws() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            Client jersey = mock(Client.class);
            WebResource wr = mock(WebResource.class);
            Builder builder = mock(Builder.class);

            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies/top1")).thenReturn(wr);
            when(wr.accept("application/json")).thenReturn(builder);
            when(builder.get(ClientResponse.class)).thenReturn(null);

            Assertions.assertThrows(HadoopException.class,
                    () -> client.getServiceList(Collections.singletonList("top1"), "*", null));
        }
    }

    @Test
    public void test18_getServiceList_throwsWrapped() {
        KnoxClient client = new KnoxClient("https://knox/topologies", "admin", "pwd");

        try (MockedStatic<Client> clientStatic = Mockito.mockStatic(Client.class)) {
            Client jersey = mock(Client.class);
            clientStatic.when(Client::create).thenReturn(jersey);
            Mockito.doNothing().when(jersey).addFilter(Mockito.any(HTTPBasicAuthFilter.class));
            when(jersey.resource("https://knox/topologies/top1")).thenThrow(new RuntimeException("boom"));

            Assertions.assertThrows(HadoopException.class,
                    () -> client.getServiceList(Collections.singletonList("top1"), "*", null));
        }
    }

    @Test
    public void test19_main_invalidArgs_exitsWithStatus1() {
        SecurityManager originalSm = System.getSecurityManager();
        class NoExitSecurityManager extends SecurityManager {
            private Integer status;

            @Override
            public void checkPermission(Permission perm) {
                // allow
            }

            @Override
            public void checkPermission(Permission perm, Object context) {
                // allow
            }

            @Override
            public void checkExit(int status) {
                this.status = status;
                throw new SecurityException("exit");
            }
        }

        NoExitSecurityManager sm = new NoExitSecurityManager();
        PrintStream origErr = System.err;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        System.setErr(new PrintStream(baos));
        System.setSecurityManager(sm);
        try {
            Assertions.assertThrows(SecurityException.class, () -> KnoxClient.main(new String[] {"only", "two"}));
            Assertions.assertEquals(Integer.valueOf(1), sm.status);
            String err = baos.toString();
            Assertions.assertTrue(err.contains("USAGE: java "));
            Assertions.assertTrue(err.contains("KnoxClient"));
        } finally {
            System.setErr(origErr);
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void test20_main_validArgs_happyPath_printsServices() {
        String[] args = new String[] {"https://knox", "admin", "pwd"};
        PrintStream origOut = System.out;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        System.setOut(new PrintStream(baos));

        try (MockedConstruction<KnoxClient> construction = Mockito.mockConstruction(KnoxClient.class,
                (mock, context) -> {
                    when(mock.getTopologyList("", null)).thenReturn(Collections.singletonList("top1"));
                    when(mock.getServiceList(Collections.singletonList("top1"), "*", null))
                            .thenReturn(Collections.singletonList("HIVE"));
                })) {
            KnoxClient.main(args);
            String out = baos.toString();
            Assertions.assertTrue(out.contains("Found service for topology:"));
        } finally {
            System.setOut(origOut);
        }
    }
}
