/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.plugin.model.validation;

import org.apache.hadoop.thirdparty.com.google.common.collect.Lists;
import org.apache.ranger.authorization.utils.JsonUtils;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerDataMaskDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerResourceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerRowFilterDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefHelper.Delegate;
import org.apache.ranger.plugin.resourcematcher.RangerAbstractResourceMatcher;
import org.apache.ranger.plugin.resourcematcher.RangerPathResourceMatcher;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static java.util.Objects.requireNonNull;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertIterableEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
* @generated by Cursor
* @description <Unit Test for RangerServiceDefHelper class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerServiceDefHelper {
    @BeforeEach
    public void before() {
        // wipe the cache clean
        RangerServiceDefHelper.cache.clear();
    }

    @Test
    public void test_getResourceHierarchies() {
        /*
         * Create a service-def with following resource graph
         *
         *   Database -> UDF
         *       |
         *       v
         *      Table -> Column
         *         |
         *         v
         *        Table-Attribute
         *
         *  It contains following hierarchies
         *  - [ Database UDF]
         *  - [ Database Table Column ]
         *  - [ Database Table Table-Attribute ]
         */
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, null);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, null);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, true);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);

        // order of resources in list sould not matter
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);

        // stuff this into a service-def
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        // now assert the behavior
        RangerServiceDefHelper         helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);

        Set<List<String>> expectedHierarchies = new HashSet<>();
        expectedHierarchies.add(Lists.newArrayList("Database", "UDF"));
        expectedHierarchies.add(Lists.newArrayList("Database", "Table", "Column"));
        expectedHierarchies.add(Lists.newArrayList("Database", "Table", "Table-Attribute"));

        for (List<RangerResourceDef> aHierarchy : hierarchies) {
            List<String> resourceNames = helper.getAllResourceNamesOrdered(aHierarchy);
            if (expectedHierarchies.contains(resourceNames)) {
                expectedHierarchies.remove(resourceNames);
            }
        }

        assertTrue(expectedHierarchies.isEmpty());
    }

    @Test
    public final void test_isResourceGraphValid_detectCycle() {
        /*
         * Create a service-def with cycles in resource graph
         *  A --> B --> C
         *  ^           |
         *  |           |
         *  |---- D <---
         */
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef a = createMockResourceDef("A", "D"); // A's parent is D, etc.
        RangerResourceDef b = createMockResourceDef("B", "C");
        RangerResourceDef c = createMockResourceDef("C", "D");
        RangerResourceDef d = createMockResourceDef("D", "A");

        // order of resources in list sould not matter
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(a, b, c, d);

        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertFalse(helper.isResourceGraphValid());
    }

    @Test
    public final void test_isResourceGraphValid_forest() {
        /*
         * Create a service-def which is a forest
         *   Database -> Table-space
         *       |
         *       v
         *      Table -> Column
         *
         *   Namespace -> package
         *       |
         *       v
         *     function
         *
         * Check that helper corrects reports back all of the hierarchies: levels in it and their order.
         */
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef       database     = createMockResourceDef("database", "");
        RangerResourceDef       tableSpace   = createMockResourceDef("table-space", "database", true);
        RangerResourceDef       table        = createMockResourceDef("table", "database");
        RangerResourceDef       column       = createMockResourceDef("column", "table", true);
        RangerResourceDef       namespace    = createMockResourceDef("namespace", "");
        RangerResourceDef       function     = createMockResourceDef("function", "namespace", true);
        RangerResourceDef       packagE      = createMockResourceDef("package", "namespace", true);
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(database, tableSpace, table, column, namespace, function, packagE);

        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies         = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);
        Set<List<String>>            expectedHierarchies = new HashSet<>();

        expectedHierarchies.add(Lists.newArrayList("database", "table-space"));
        expectedHierarchies.add(Lists.newArrayList("database", "table", "column"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "package"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "function"));

        for (List<RangerResourceDef> aHierarchy : hierarchies) {
            List<String> resourceNames = helper.getAllResourceNamesOrdered(aHierarchy);

            assertTrue(expectedHierarchies.contains(resourceNames));

            expectedHierarchies.remove(resourceNames);
        }

        assertTrue(expectedHierarchies.isEmpty());  // make sure we got back all hierarchies
    }

    @Test
    public final void test_isResourceGraphValid_forest_singleNodeTrees() {
        /*
         * Create a service-def which is a forest with a few single node trees
         *
         *   Database
         *
         *   Server
         *
         *   Namespace -> package
         *       |
         *       v
         *     function
         *
         * Check that helper corrects reports back all of the hierarchies: levels in it and their order.
         */
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef       database  = createRealResourceDef("database", null, 1, null);
        RangerResourceDef       server    = createRealResourceDef("server", null, 1, null);
        RangerResourceDef       namespace = createRealResourceDef("namespace", null, 1, null);
        RangerResourceDef       function  = createRealResourceDef("function", "namespace", 2, true);
        RangerResourceDef       packagE   = createRealResourceDef("package", "namespace", 2, true);
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(database, server, namespace, function, packagE);

        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies         = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);
        Set<List<String>>            expectedHierarchies = new HashSet<>();

        expectedHierarchies.add(Lists.newArrayList("database"));
        expectedHierarchies.add(Lists.newArrayList("server"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "package"));
        expectedHierarchies.add(Lists.newArrayList("namespace", "function"));

        for (List<RangerResourceDef> aHierarchy : hierarchies) {
            List<String> resourceNames = helper.getAllResourceNamesOrdered(aHierarchy);

            assertTrue(expectedHierarchies.contains(resourceNames));

            expectedHierarchies.remove(resourceNames);
        }

        assertTrue(expectedHierarchies.isEmpty()); // make sure we got back all hierarchies
    }

    @Test
    public final void test_cacheBehavior() {
        // let's add one entry to the cache
        Delegate delegate    = mock(Delegate.class);
        Date     aDate       = getNow();
        String   serviceName = "a-service-def";

        when(delegate.getServiceFreshnessDate()).thenReturn(aDate);

        RangerServiceDefHelper.cache.put(serviceName, delegate);

        // create a service def with matching date value
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);

        when(serviceDef.getName()).thenReturn(serviceName);
        when(serviceDef.getUpdateTime()).thenReturn(aDate);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        // since cache has it, we should get back the one that we have added
        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertSame(delegate, helper.delegate);

        // if we change the date then that should force helper to create a new delegate instance
        /*
         * NOTE:: current logic would replace the cache instance even if the one in the cache is newer.  This is not likely to happen but it is important to call this out
         * as in rare cases one may end up creating re creating delegate if threads have stale copies of service def.
         */
        when(serviceDef.getUpdateTime()).thenReturn(getLastMonth());

        helper = new RangerServiceDefHelper(serviceDef);

        assertNotSame(delegate, helper.delegate);

        // now that a new instance was added to the cache let's ensure that it got added to the cache
        Delegate newDelegate = helper.delegate;

        helper = new RangerServiceDefHelper(serviceDef);

        assertSame(newDelegate, helper.delegate);
    }

    @Test
    public void test_getResourceHierarchies_with_leaf_specification() {
        /*
         * Leaf Spec for resources:
         *      Database: non-leaf
         *      UDF: Not-specified
         *      Table: Leaf
         *      Column: Leaf
         *      Table-Attribute: Leaf
         *
         * Create a service-def with following resource graph
         *
         *   Database -> UDF
         *       |
         *       v
         *      Table -> Column
         *         |
         *         v
         *        Table-Attribute
         *
         *  It contains following hierarchies
         *  - [ Database UDF]
         *  - [ Database Table Column ]
         *  - [ Database Table ]
         *  - [ Database Table Table-Attribute ]
         */
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, false);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, true);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, true);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);

        // order of resources in list should not matter
        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);

        // stuff this into a service-def
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        // now assert the behavior
        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertTrue(helper.isResourceGraphValid());

        Set<List<RangerResourceDef>> hierarchies = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS);

        Set<List<String>> expectedHierarchies = new HashSet<>();
        expectedHierarchies.add(Lists.newArrayList("Database", "UDF"));
        expectedHierarchies.add(Lists.newArrayList("Database", "Table", "Column"));
        expectedHierarchies.add(Lists.newArrayList("Database", "Table", "Table-Attribute"));
        expectedHierarchies.add(Lists.newArrayList("Database", "Table"));

        Set<List<String>> actualHierarchies = new HashSet<>();
        for (List<RangerResourceDef> aHierarchy : hierarchies) {
            actualHierarchies.add(helper.getAllResourceNamesOrdered(aHierarchy));
        }

        for (List<String> expected : expectedHierarchies) {
            assertTrue(actualHierarchies.contains(expected));
        }

        assertFalse(actualHierarchies.contains(Lists.newArrayList("Database")));
    }

    @Test
    public void test_invalid_resourceHierarchies_with_leaf_specification() {
        /*
         * Leaf Spec for resources:
         *      Database: non-leaf
         *      UDF: Not-specified
         *      Table: Leaf
         *      Column: non-Leaf
         *      Table-Attribute: Leaf
         *
         * Create a service-def with following resource graph
         *
         *   Database -> UDF
         *       |
         *       v
         *      Table -> Column
         *         |
         *         v
         *        Table-Attribute
         *
         *  It should fail as the hierarchy is invalid ("Error in path: sink node:[Column] is not leaf node")
         *
         */
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, false);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, true);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, false);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);
        List<RangerResourceDef> resourceDefs   = Lists.newArrayList(column, database, table, tableAttribute, udf); // order of resources in list should not matter

        // stuff this into a service-def
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        // now assert the behavior
        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        assertFalse(helper.isResourceGraphValid());
    }

    @Test
    public void testRrnTemplateHive() {
        InputStreamReader      reader       = new InputStreamReader(requireNonNull(this.getClass().getResourceAsStream("/admin/service-defs/test-hive-servicedef.json")));
        RangerServiceDef       svcDef       = JsonUtils.jsonToObject(reader, RangerServiceDef.class);
        RangerServiceDefHelper svcDefHelper = new RangerServiceDefHelper(svcDef);

        assertEquals("database", svcDefHelper.getRrnTemplate("database"));
        assertEquals("database/table", svcDefHelper.getRrnTemplate("table"));
        assertEquals("database/table/column", svcDefHelper.getRrnTemplate("column"));
        assertEquals("database/udf", svcDefHelper.getRrnTemplate("udf"));
        assertEquals("url", svcDefHelper.getRrnTemplate("url"));
        assertNull(svcDefHelper.getRrnTemplate("unknown-resource"));
    }

    @Test
    public void testRrnTemplateS3() {
        InputStreamReader      reader       = new InputStreamReader(requireNonNull(this.getClass().getResourceAsStream("/admin/service-defs/test-s3-servicedef.json")));
        RangerServiceDef       svcDef       = JsonUtils.jsonToObject(reader, RangerServiceDef.class);
        RangerServiceDefHelper svcDefHelper = new RangerServiceDefHelper(svcDef);

        assertEquals("bucket", svcDefHelper.getRrnTemplate("bucket"));
        assertEquals("bucket/path", svcDefHelper.getRrnTemplate("path"));
    }

    @Test
    public void test_getResourceHierarchies_filteredByKeys() {
        RangerServiceDef serviceDef = mock(RangerServiceDef.class);
        when(serviceDef.getName()).thenReturn("a-service-def");
        when(serviceDef.getUpdateTime()).thenReturn(getNow());

        RangerResourceDef database       = createRealResourceDef("Database", null, 1, null);
        RangerResourceDef udf            = createRealResourceDef("UDF", "Database", 2, null);
        RangerResourceDef table          = createRealResourceDef("Table", "Database", 2, null);
        RangerResourceDef column         = createRealResourceDef("Column", "Table", 3, true);
        RangerResourceDef tableAttribute = createRealResourceDef("Table-Attribute", "Table", 3, true);

        List<RangerResourceDef> resourceDefs = Lists.newArrayList(column, database, table, tableAttribute, udf);
        when(serviceDef.getResources()).thenReturn(resourceDefs);
        when(serviceDef.getAccessTypes()).thenReturn(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertTrue(helper.isResourceGraphValid());

        Set<String> keys = new HashSet<>();
        keys.add("Database");
        keys.add("Table");

        Set<List<RangerResourceDef>> filtered = helper.getResourceHierarchies(RangerPolicy.POLICY_TYPE_ACCESS, keys);
        List<RangerResourceDef> expected1 = Lists.newArrayList(database, table, column);
        List<RangerResourceDef> expected2 = Lists.newArrayList(database, table, tableAttribute);

        assertTrue(filtered.contains(expected1));
        assertTrue(filtered.contains(expected2));
    }

    @Test
    public void test_static_getServiceDefForPolicyFiltering_pathMatcherModification() {
        RangerServiceDef base = new RangerServiceDef();
        base.setName("svc");
        base.setUpdateTime(getNow());
        base.setAccessTypes(new ArrayList<>());

        RangerResourceDef pathRes = new RangerResourceDef();
        pathRes.setName("path");
        pathRes.setMatcher(RangerPathResourceMatcher.class.getName());
        Map<String, String> opts = new HashMap<>();
        opts.put(RangerPathResourceMatcher.OPTION_PATH_SEPARATOR, "/");
        pathRes.setMatcherOptions(opts);
        pathRes.setRecursiveSupported(true);
        pathRes.setLevel(1);

        RangerResourceDef otherRes = new RangerResourceDef();
        otherRes.setName("other");
        otherRes.setMatcher("com.example.OtherMatcher");
        otherRes.setLevel(1);

        base.setResources(Arrays.asList(pathRes, otherRes));

        RangerServiceDef modified = RangerServiceDefHelper.getServiceDefForPolicyFiltering(base);

        RangerResourceDef modifiedPath = null;
        RangerResourceDef modifiedOther = null;
        for (RangerResourceDef r : modified.getResources()) {
            if ("path".equals(r.getName())) {
                modifiedPath = r;
            } else if ("other".equals(r.getName())) {
                modifiedOther = r;
            }
        }
        assertNotNull(modifiedPath);
        assertNotNull(modifiedOther);
        assertEquals("false", modifiedPath.getMatcherOptions().get(RangerAbstractResourceMatcher.OPTION_WILD_CARD));
        assertFalse(Boolean.TRUE.equals(modifiedPath.getRecursiveSupported()));
        assertNull(modifiedOther.getMatcherOptions() == null ? null : modifiedOther.getMatcherOptions().get(RangerAbstractResourceMatcher.OPTION_WILD_CARD));
    }

    @Test
    public void test_static_getFilterResourcesForAncestorPolicyFiltering_withDefaultDelimiterAndSuffix() {
        RangerServiceDef base = new RangerServiceDef();
        base.setName("svc");
        base.setUpdateTime(getNow());
        base.setAccessTypes(new ArrayList<>());

        RangerResourceDef pathRes = new RangerResourceDef();
        pathRes.setName("path");
        pathRes.setMatcher(RangerPathResourceMatcher.class.getName());
        pathRes.setLevel(1);
        // no PATH_SEPARATOR option to force default
        pathRes.setMatcherOptions(new HashMap<>());

        RangerResourceDef otherRes = new RangerResourceDef();
        otherRes.setName("other");
        otherRes.setMatcher("com.example.OtherMatcher");
        otherRes.setLevel(1);

        base.setResources(Arrays.asList(pathRes, otherRes));

        Map<String, String> filter = new HashMap<>();
        filter.put("path", "a/b");

        Map<String, String> out = RangerServiceDefHelper.getFilterResourcesForAncestorPolicyFiltering(base, filter);
        assertNotNull(out);
        assertEquals("a/b/" + RangerAbstractResourceMatcher.WILDCARD_ASTERISK, out.get("path"));
    }

    @Test
    public void test_static_getFilterResourcesForAncestorPolicyFiltering_noMatchingReturnsNull() {
        RangerServiceDef base = new RangerServiceDef();
        base.setName("svc");
        base.setUpdateTime(getNow());
        base.setAccessTypes(new ArrayList<>());

        RangerResourceDef otherRes = new RangerResourceDef();
        otherRes.setName("other");
        otherRes.setMatcher("com.example.OtherMatcher");
        otherRes.setLevel(1);

        base.setResources(Collections.singletonList(otherRes));

        Map<String, String> filter = new HashMap<>();
        filter.put("path", "a/b");

        Map<String, String> out = RangerServiceDefHelper.getFilterResourcesForAncestorPolicyFiltering(base, filter);
        assertNull(out);
    }

    @Test
    public void test_resourceHierarchyKeys_nullAuditUnknown() {
        RangerServiceDef serviceDef = createServiceDefWithSingleNodes("svc", Arrays.asList("A", "B"));
        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);

        Set<Set<String>> accessKeys = helper.getResourceHierarchyKeys(RangerPolicy.POLICY_TYPE_ACCESS);
        assertFalse(accessKeys.isEmpty());

        Set<Set<String>> auditKeys = helper.getResourceHierarchyKeys(RangerPolicy.POLICY_TYPE_AUDIT);
        assertIterableEquals(accessKeys, auditKeys);

        Set<Set<String>> nullKeys = helper.getResourceHierarchyKeys(null);
        assertIterableEquals(accessKeys, nullKeys);

        Set<Set<String>> unknown = helper.getResourceHierarchyKeys(9999);
        assertTrue(unknown.isEmpty());
    }

    @Test
    public void test_isDataMaskSupported_variants() {
        RangerServiceDef serviceDef = new RangerServiceDef();
        serviceDef.setName("svc");
        serviceDef.setUpdateTime(getNow());
        serviceDef.setAccessTypes(new ArrayList<>());

        RangerResourceDef dmRes = new RangerResourceDef();
        dmRes.setName("DM");
        dmRes.setLevel(1);

        RangerDataMaskDef dmd = new RangerDataMaskDef();
        dmd.setResources(Collections.singletonList(dmRes));
        serviceDef.setDataMaskDef(dmd);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertTrue(helper.isDataMaskSupported());
        Set<String> match = new HashSet<>();
        match.add("DM");
        assertTrue(helper.isDataMaskSupported(match));

        Set<String> noMatch = new HashSet<>();
        noMatch.add("X");
        assertFalse(helper.isDataMaskSupported(noMatch));
    }

    @Test
    public void test_isRowFilterSupported_variants() {
        RangerServiceDef serviceDef = new RangerServiceDef();
        serviceDef.setName("svc");
        serviceDef.setUpdateTime(getNow());
        serviceDef.setAccessTypes(new ArrayList<>());

        RangerResourceDef rfRes = new RangerResourceDef();
        rfRes.setName("RF");
        rfRes.setLevel(1);

        RangerRowFilterDef rfd = new RangerRowFilterDef();
        rfd.setResources(Collections.singletonList(rfRes));
        serviceDef.setRowFilterDef(rfd);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(serviceDef);
        assertTrue(helper.isRowFilterSupported());

        Set<String> match = new HashSet<>();
        match.add("RF");
        assertTrue(helper.isRowFilterSupported(match));

        Set<String> noMatch = new HashSet<>();
        noMatch.add("Y");
        assertFalse(helper.isRowFilterSupported(noMatch));
    }

    @Test
    public void test_filterHierarchies_containsOnlyMandatoryResources() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef r1 = new RangerResourceDef();
        r1.setName("A");
        r1.setLevel(1);
        r1.setMandatory(true);

        RangerResourceDef r2 = new RangerResourceDef();
        r2.setName("B");
        r2.setParent("A");
        r2.setLevel(2);
        r2.setMandatory(true);
        r2.setIsValidLeaf(true);

        RangerResourceDef r3 = new RangerResourceDef();
        r3.setName("C");
        r3.setParent("B");
        r3.setLevel(3);
        r3.setMandatory(false);

        svc.setResources(Arrays.asList(r1, r2, r3));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        Set<List<RangerResourceDef>> onlyMandatory = helper.filterHierarchies_containsOnlyMandatoryResources(RangerPolicy.POLICY_TYPE_ACCESS);
        assertTrue(onlyMandatory.contains(Lists.newArrayList(r1, r2)));
        assertFalse(onlyMandatory.contains(Lists.newArrayList(r1, r2, r3)));
    }

    @Test
    public void test_isValidHierarchy_exact_vs_contains() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);

        RangerResourceDef resC = new RangerResourceDef();
        resC.setName("C");
        resC.setParent("B");
        resC.setLevel(3);

        svc.setResources(Arrays.asList(resA, resB, resC));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);

        Set<String> subset = new HashSet<>();
        subset.add("A");
        subset.add("B");

        Set<String> exact = new HashSet<>();
        exact.add("A");
        exact.add("B");
        exact.add("C");

        assertTrue(helper.isValidHierarchy(RangerPolicy.POLICY_TYPE_ACCESS, subset, false));
        assertFalse(helper.isValidHierarchy(RangerPolicy.POLICY_TYPE_ACCESS, subset, true));
        assertTrue(helper.isValidHierarchy(RangerPolicy.POLICY_TYPE_ACCESS, exact, true));
    }

    @Test
    public void test_hierarchyHasAllResources_true_false() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);

        List<RangerResourceDef> hierarchy = Arrays.asList(resA, resB);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);

        Set<String> yes = new HashSet<>();
        yes.add("A");
        yes.add("B");
        assertTrue(helper.hierarchyHasAllResources(hierarchy, yes));

        Set<String> no = new HashSet<>();
        no.add("A");
        no.add("C");
        assertFalse(helper.hierarchyHasAllResources(hierarchy, no));
    }

    @Test
    public void test_getMandatoryResourceNames_and_getAllResourceNamesOrdered() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        resA.setMandatory(true);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);
        resB.setMandatory(false);

        List<RangerResourceDef> hierarchy = Arrays.asList(resA, resB);

        RangerServiceDefHelper helper = new RangerServiceDefHelper(createServiceDef("svc", hierarchy));

        Set<String> mandatory = helper.getMandatoryResourceNames(hierarchy);
        assertTrue(mandatory.contains("A"));
        assertFalse(mandatory.contains("B"));

        List<String> ordered = helper.getAllResourceNamesOrdered(hierarchy);
        assertIterableEquals(Arrays.asList("A", "B"), ordered);
    }

    @Test
    public void test_getOrderedResourceNames_orderingAndNull() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(2);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setLevel(1);

        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setResources(Arrays.asList(resA, resB));
        svc.setAccessTypes(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc, false);

        List<String> input = Arrays.asList("A", "B");
        List<String> ordered = helper.getOrderedResourceNames(input);
        assertIterableEquals(Arrays.asList("B", "A"), ordered);

        List<String> nullOrdered = helper.getOrderedResourceNames(null);
        assertTrue(nullOrdered.isEmpty());
    }

    @Test
    public void test_getResourceDef_nullPolicyTypeAndSpecific() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setLevel(1);

        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setResources(Arrays.asList(resA, resB));
        svc.setAccessTypes(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        assertEquals("A", helper.getResourceDef("A", null).getName());
        assertNull(helper.getResourceDef("Z", RangerPolicy.POLICY_TYPE_ACCESS));
    }

    @Test
    public void test_getWildcardEnabledResourceDef_cachingAndNullCase() {
        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        resA.setMatcher("com.example.X");
        resA.setMatcherOptions(new HashMap<>());

        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setResources(Collections.singletonList(resA));
        svc.setAccessTypes(new ArrayList<>());

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        RangerResourceDef wr1 = helper.getWildcardEnabledResourceDef("A", RangerPolicy.POLICY_TYPE_ACCESS);
        assertNotNull(wr1);
        assertEquals("true", wr1.getMatcherOptions().get(RangerAbstractResourceMatcher.OPTION_WILD_CARD));

        RangerResourceDef wr2 = helper.getWildcardEnabledResourceDef("A", RangerPolicy.POLICY_TYPE_ACCESS);
        assertSame(wr1, wr2);

        RangerResourceDef missing = helper.getWildcardEnabledResourceDef("Z", RangerPolicy.POLICY_TYPE_ACCESS);
        assertNull(missing);
        RangerResourceDef missingAgain = helper.getWildcardEnabledResourceDef("Z", RangerPolicy.POLICY_TYPE_ACCESS);
        assertNull(missingAgain);
    }

    @Test
    public void test_expandImpliedAccessGrants_cases() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());

        RangerAccessTypeDef read = new RangerAccessTypeDef();
        read.setName("read");
        read.setImpliedGrants(Arrays.asList("view"));

        RangerAccessTypeDef write = new RangerAccessTypeDef();
        write.setName("write");
        write.setImpliedGrants(null);

        RangerAccessTypeDef viewMarker = new RangerAccessTypeDef();
        viewMarker.setName("view");
        viewMarker.setImpliedGrants(Arrays.asList("inspect"));

        svc.setAccessTypes(Arrays.asList(read, write));
        svc.setMarkerAccessTypes(Collections.singletonList(viewMarker));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);

        assertTrue(helper.getImpliedAccessGrants().containsKey("read"));
        assertTrue(helper.getImpliedAccessGrants().containsKey("view"));
        assertFalse(helper.getImpliedAccessGrants().containsKey("write"));

        Set<String> empty = helper.expandImpliedAccessGrants(null);
        assertTrue(empty.isEmpty());

        Set<String> none = new HashSet<>();
        none.add("write");
        Set<String> noneOut = helper.expandImpliedAccessGrants(none);
        assertSame(none, noneOut);

        Set<String> some = new HashSet<>();
        some.add("read");
        Set<String> expanded = helper.expandImpliedAccessGrants(some);
        assertTrue(expanded.contains("read"));
        assertTrue(expanded.contains("view"));
        // expansion is not recursive; should not include implied of implied
        assertFalse(expanded.contains("inspect"));
    }

    @Test
    public void test_patchServiceDefWithDefaultValues_setsLeafOnHierarchyEnds() {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName("svc");
        svc.setUpdateTime(getNow());
        svc.setAccessTypes(new ArrayList<>());

        RangerResourceDef resA = new RangerResourceDef();
        resA.setName("A");
        resA.setLevel(1);
        resA.setIsValidLeaf(null);

        RangerResourceDef resB = new RangerResourceDef();
        resB.setName("B");
        resB.setParent("A");
        resB.setLevel(2);
        resB.setIsValidLeaf(null);

        RangerResourceDef resC = new RangerResourceDef();
        resC.setName("C");
        resC.setParent("B");
        resC.setLevel(3);
        resC.setIsValidLeaf(null);

        svc.setResources(Arrays.asList(resA, resB, resC));

        RangerServiceDefHelper helper = new RangerServiceDefHelper(svc);
        helper.patchServiceDefWithDefaultValues();

        assertFalse(Boolean.TRUE.equals(resA.getIsValidLeaf()));
        assertFalse(Boolean.TRUE.equals(resB.getIsValidLeaf()));
        assertTrue(Boolean.TRUE.equals(resC.getIsValidLeaf()));
    }

    private RangerServiceDef createServiceDef(String name, List<RangerResourceDef> resources) {
        RangerServiceDef svc = new RangerServiceDef();
        svc.setName(name);
        svc.setUpdateTime(getNow());
        svc.setResources(resources);
        svc.setAccessTypes(new ArrayList<>());
        return svc;
    }

    private RangerServiceDef createServiceDefWithSingleNodes(String name, List<String> resourceNames) {
        List<RangerResourceDef> defs = new ArrayList<>();
        int level = 1;
        for (String rn : resourceNames) {
            RangerResourceDef d = new RangerResourceDef();
            d.setName(rn);
            d.setLevel(level++);
            defs.add(d);
        }
        return createServiceDef(name, defs);
    }

    private RangerResourceDef createMockResourceDef(String name, String parent) {
        RangerResourceDef resourceDef = mock(RangerResourceDef.class);
        when(resourceDef.getName()).thenReturn(name);
        when(resourceDef.getParent()).thenReturn(parent);
        return resourceDef;
    }

    private RangerResourceDef createMockResourceDef(String name, String parent, Boolean isValidLeaf) {
        RangerResourceDef resourceDef = mock(RangerResourceDef.class);
        when(resourceDef.getName()).thenReturn(name);
        when(resourceDef.getParent()).thenReturn(parent);
        if (isValidLeaf != null) {
            when(resourceDef.getIsValidLeaf()).thenReturn(isValidLeaf);
        }
        return resourceDef;
    }

    private RangerResourceDef createRealResourceDef(String name, String parent, int level, Boolean isValidLeaf) {
        RangerResourceDef r = new RangerResourceDef();
        r.setName(name);
        r.setParent(parent);
        r.setLevel(level);
        r.setIsValidLeaf(isValidLeaf);
        return r;
    }

    Date getLastMonth() {
        Calendar cal = GregorianCalendar.getInstance();

        cal.add(Calendar.MONTH, 1);

        return cal.getTime();
    }

    Date getNow() {
        return GregorianCalendar.getInstance().getTime();
    }
}
