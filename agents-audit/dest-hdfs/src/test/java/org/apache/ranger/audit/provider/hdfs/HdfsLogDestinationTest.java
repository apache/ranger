/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.provider.hdfs;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.provider.DebugTracer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for HdfsLogDestination
 * */
class HdfsLogDestinationTest {
    private HdfsLogDestination<AuditEventBase> destination;
    private TestableHdfsLogDestination testableDestination;

    @Mock
    private FSDataOutputStream mockStream;

    @Mock
    private OutputStreamWriter mockWriter;

    @Mock
    private AuditEventBase mockEvent;

    static class DummyTracer implements DebugTracer {
        @Override public void debug(String msg) {}

        @Override public void debug(String msg, Throwable excp) {}

        @Override public void info(String msg) {}

        @Override public void info(String msg, Throwable excp) {}

        @Override public void warn(String msg) {}

        @Override public void warn(String msg, Throwable excp) {}

        @Override public void error(String msg) {}

        @Override public void error(String msg, Throwable excp) {}
    }

    // Testable subclass that exposes internals for testing
    static class TestableHdfsLogDestination extends HdfsLogDestination<AuditEventBase> {
        public TestableHdfsLogDestination(DebugTracer tracer) {
            super(tracer);
        }

        // Use reflection to access private fields
        public void setWriter(OutputStreamWriter writer) {
            try {
                Field field = HdfsLogDestination.class.getDeclaredField("mWriter");
                field.setAccessible(true);
                field.set(this, writer);
            } catch (Exception e) {
                throw new RuntimeException("Failed to set writer", e);
            }
        }

        public void setFsDataOutStream(FSDataOutputStream stream) {
            try {
                Field field = HdfsLogDestination.class.getDeclaredField("mFsDataOutStream");
                field.setAccessible(true);
                field.set(this, stream);
            } catch (Exception e) {
                throw new RuntimeException("Failed to set fsDataOutStream", e);
            }
        }

        @Override
        Configuration createConfiguration() {
            // Return mocked configuration to prevent actual HDFS connection
            return mock(Configuration.class);
        }
    }

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
        destination = new HdfsLogDestination<>(new DummyTracer());
        testableDestination = new TestableHdfsLogDestination(new DummyTracer());

        // Setup default behavior for mock event
        when(mockEvent.toString()).thenReturn("{\"eventId\":\"test-id\"}");
    }

    @Test
    void testSettersAndGetters() {
        destination.setDirectory("/tmp/hdfs");
        destination.setFile("audit.log");
        destination.setFlushIntervalSeconds(10);
        destination.setEncoding("UTF-8");
        destination.setRolloverIntervalSeconds(20);
        destination.setOpenRetryIntervalSeconds(30);
        destination.setName("testName");

        assertEquals("/tmp/hdfs", destination.getDirectory());
        assertEquals("audit.log", destination.getFile());
        assertEquals(10, destination.getFlushIntervalSeconds());
        assertEquals("UTF-8", destination.getEncoding());
        assertEquals(20, destination.getRolloverIntervalSeconds());
        assertEquals(30, destination.getOpenRetryIntervalSeconds());
        assertEquals("testName", destination.getName());
    }

    @Test
    void testToString() {
        destination.setDirectory("/tmp/hdfs");
        destination.setFile("audit.log");
        destination.setRolloverIntervalSeconds(42);
        String str = destination.toString();
        assertTrue(str.contains("Directory=/tmp/hdfs"));
        assertTrue(str.contains("File=audit.log"));
        assertTrue(str.contains("RolloverIntervalSeconds=42"));
    }

    @Test
    void testSetConfigProps() {
        Map<String, String> props = new HashMap<>();
        props.put("fs.defaultFS", "hdfs://localhost:9000");
        destination.setConfigProps(props);
        // No exception expected
    }

    @Test
    void testIsAvailableInitiallyFalse() {
        assertFalse(destination.isAvailable());
    }

    @Test
    void testStartAndStop() {
        // No exceptions should be thrown
        testableDestination.start();
        testableDestination.stop();
    }

    @Test
    void testIsAvailableWithWriter() {
        testableDestination.setWriter(mockWriter);
        assertTrue(testableDestination.isAvailable());
    }

    @Test
    void testSendStringifiedWithClosedWriter() throws Exception {
        // Setup
        testableDestination.setWriter(mockWriter);
        doThrow(new IOException("Writer closed")).when(mockWriter).write(anyString());

        // Test
        boolean result = testableDestination.sendStringified("test message");

        // Verify
        assertFalse(result);
    }

    @Test
    void testFlushWithWriter() throws Exception {
        // Setup
        testableDestination.setWriter(mockWriter);
        testableDestination.setFsDataOutStream(mockStream);

        // Test
        boolean result = testableDestination.flush();

        // Verify
        assertTrue(result);
        verify(mockWriter).flush();
        verify(mockStream).hflush();
    }

    @Test
    void testFlushWithoutWriter() {
        // Test
        boolean result = testableDestination.flush();

        // Verify
        assertFalse(result);
    }

    @Test
    void testFlushWithWriterException() throws Exception {
        // Setup
        testableDestination.setWriter(mockWriter);
        doThrow(new IOException("Writer error")).when(mockWriter).flush();

        // Test
        boolean result = testableDestination.flush();

        // Verify
        assertFalse(result);
    }
}
