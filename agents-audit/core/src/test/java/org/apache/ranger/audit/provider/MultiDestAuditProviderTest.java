/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.audit.provider;

import org.apache.ranger.audit.model.AuditEventBase;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.File;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for MultiDestAuditProvider
 * */
class MultiDestAuditProviderTest {
    private MultiDestAuditProvider multiDestProvider;

    @Mock
    private AuditHandler mockProvider1;

    @Mock
    private AuditHandler mockProvider2;

    @Mock
    private BaseAuditHandler mockBaseProvider;

    @Mock
    private AuditEventBase mockEvent;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
        multiDestProvider = new MultiDestAuditProvider();

        // Set names for mocks to make testing easier
        when(mockProvider1.getName()).thenReturn("provider1");
        when(mockProvider2.getName()).thenReturn("provider2");
        when(mockBaseProvider.getName()).thenReturn("baseProvider");
    }

    @Test
    void testDefaultConstructor() {
        assertEquals(MultiDestAuditProvider.DEFAULT_NAME, multiDestProvider.getName(),
                "Default name should be set in constructor");
        assertTrue(multiDestProvider.mProviders.isEmpty(),
                "Provider list should be empty initially");
    }

    @Test
    void testConstructorWithProvider() {
        MultiDestAuditProvider provider = new MultiDestAuditProvider(mockProvider1);

        assertEquals(MultiDestAuditProvider.DEFAULT_NAME, provider.getName(),
                "Default name should be set in constructor");
        assertEquals(1, provider.mProviders.size(),
                "Provider list should have one item");
        assertSame(mockProvider1, provider.mProviders.get(0),
                "The provided handler should be in the list");
    }

    @Test
    void testAddAuditProvider() {
        multiDestProvider.addAuditProvider(mockProvider1);

        assertEquals(1, multiDestProvider.mProviders.size(),
                "Provider list should have one item");
        assertSame(mockProvider1, multiDestProvider.mProviders.get(0),
                "The provided handler should be in the list");
    }

    @Test
    void testAddAuditProviderNull() {
        multiDestProvider.addAuditProvider(null);

        assertTrue(multiDestProvider.mProviders.isEmpty(),
                "Provider list should remain empty when adding null");
    }

    @Test
    void testAddBaseAuditProviderSetsParentPath() {
        multiDestProvider.setName("testMultiDest");
        multiDestProvider.addAuditProvider(mockBaseProvider);

        verify(mockBaseProvider).setParentPath("testMultiDest");
    }

    @Test
    void testAddAuditProviders() {
        List<AuditHandler> providers = Arrays.asList(mockProvider1, mockProvider2);

        multiDestProvider.addAuditProviders(providers);

        assertEquals(2, multiDestProvider.mProviders.size(),
                "Provider list should have two items");
        assertSame(mockProvider1, multiDestProvider.mProviders.get(0));
        assertSame(mockProvider2, multiDestProvider.mProviders.get(1));
    }

    @Test
    void testAddAuditProvidersNull() {
        multiDestProvider.addAuditProviders(null);

        assertTrue(multiDestProvider.mProviders.isEmpty(),
                "Provider list should remain empty when adding null list");
    }

    @Test
    void testLogSingleEvent() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        boolean result = multiDestProvider.log(mockEvent);

        assertTrue(result, "Log method should return true");
        verify(mockProvider1).log(mockEvent);
        verify(mockProvider2).log(mockEvent);
    }

    @Test
    void testLogSingleEventWithException() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        doThrow(new RuntimeException("Test exception")).when(mockProvider1).log(mockEvent);

        boolean result = multiDestProvider.log(mockEvent);

        assertTrue(result, "Log method should return true even when a provider throws exception");
        verify(mockProvider1).log(mockEvent);
        verify(mockProvider2).log(mockEvent);
    }

    @Test
    void testLogMultipleEvents() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        Collection<AuditEventBase> events = Arrays.asList(mockEvent, mock(AuditEventBase.class));

        boolean result = multiDestProvider.log(events);

        assertTrue(result, "Log method should return true");
        verify(mockProvider1).log(events);
        verify(mockProvider2).log(events);
    }

    @Test
    void testLogJSON() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        String jsonEvent = "{\"event\":\"test\"}";

        boolean result = multiDestProvider.logJSON(jsonEvent);

        assertTrue(result, "LogJSON method should return true");
        verify(mockProvider1).logJSON(jsonEvent);
        verify(mockProvider2).logJSON(jsonEvent);
    }

    @Test
    void testLogJSONCollection() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        Collection<String> jsonEvents = Arrays.asList("{\"event\":\"test1\"}", "{\"event\":\"test2\"}");

        boolean result = multiDestProvider.logJSON(jsonEvents);

        assertTrue(result, "LogJSON collection method should return true");
        verify(mockProvider1).logJSON(jsonEvents);
        verify(mockProvider2).logJSON(jsonEvents);
    }

    @Test
    void testLogFile() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        File mockFile = mock(File.class);
        when(mockFile.getAbsolutePath()).thenReturn("/test/path");

        boolean result = multiDestProvider.logFile(mockFile);

        assertTrue(result, "LogFile method should return true");
        verify(mockProvider1).logFile(mockFile);
        verify(mockProvider2).logFile(mockFile);
    }

    @Test
    void testInit() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        Properties props = new Properties();
        props.setProperty("test.key", "test.value");

        multiDestProvider.init(props);

        verify(mockProvider1).init(props);
        verify(mockProvider2).init(props);
    }

    @Test
    void testSetName() {
        multiDestProvider.addAuditProvider(mockBaseProvider);

        multiDestProvider.setName("newName");

        assertEquals("newName", multiDestProvider.getName());
        verify(mockBaseProvider).setParentPath("newName");
    }

    @Test
    void testSetParentPath() {
        multiDestProvider.addAuditProvider(mockBaseProvider);

        multiDestProvider.setParentPath("parentPath");

        verify(mockBaseProvider).setParentPath(multiDestProvider.getName());
    }

    @Test
    void testStart() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        multiDestProvider.start();

        verify(mockProvider1).start();
        verify(mockProvider2).start();
    }

    @Test
    void testStartWithException() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        doThrow(new RuntimeException("Test exception")).when(mockProvider1).start();

        // Should not throw exception
        multiDestProvider.start();

        verify(mockProvider1).start();
        verify(mockProvider2).start();
    }

    @Test
    void testStop() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        multiDestProvider.stop();

        verify(mockProvider1).stop();
        verify(mockProvider2).stop();
    }

    @Test
    void testWaitToComplete() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        multiDestProvider.waitToComplete();

        verify(mockProvider1).waitToComplete();
        verify(mockProvider2).waitToComplete();
    }

    @Test
    void testWaitToCompleteWithTimeout() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        long timeout = 5000L;
        multiDestProvider.waitToComplete(timeout);

        verify(mockProvider1).waitToComplete(timeout);
        verify(mockProvider2).waitToComplete(timeout);
    }

    @Test
    void testFlush() {
        multiDestProvider.addAuditProvider(mockProvider1);
        multiDestProvider.addAuditProvider(mockProvider2);

        multiDestProvider.flush();

        verify(mockProvider1).flush();
        verify(mockProvider2).flush();
    }
}
