/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.provider;

import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.model.AuthzAuditEvent;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.File;
import java.lang.reflect.Field;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;

/**
 * @generated by copilot
 * @description Unit Test cases for BaseAuditHandler
 * */
class BaseAuditHandlerTest {
    private TestBaseAuditHandler auditHandler;

    @Mock
    private AuditEventBase mockAuditEvent;

    @TempDir
    Path tempDir;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
        auditHandler = new TestBaseAuditHandler();
    }

    @Test
    void testInit() {
        Properties props = new Properties();
        props.setProperty("test.audit.name", "testHandler");
        props.setProperty("test.audit.config.param1", "value1");
        props.setProperty("test.audit.config.param2", "value2");

        auditHandler.init(props, "test.audit");

        assertEquals("testHandler", auditHandler.getName());
        assertEquals("value1", auditHandler.configProps.get("param1"));
        assertEquals("value2", auditHandler.configProps.get("param2"));
    }

    @Test
    void testInitWithoutName() {
        Properties props = new Properties();

        auditHandler.init(props, "test.audit");

        assertEquals("audit", auditHandler.getName());
    }

    @Test
    void testLogSingleEvent() {
        // Given
        auditHandler.setReturnValueForLog(true);

        // When
        boolean result = auditHandler.log(mockAuditEvent);

        // Then
        assertTrue(result);
        assertEquals(1, auditHandler.getEventsReceived().size());
        assertSame(mockAuditEvent, auditHandler.getEventsReceived().get(0));
    }

    @Test
    void testLogMultipleEvents() {
        // Given
        auditHandler.setReturnValueForLog(true);
        Collection<AuditEventBase> events = Arrays.asList(
                mockAuditEvent,
                mock(AuditEventBase.class));

        // When
        boolean result = auditHandler.log(events);

        // Then
        assertTrue(result);
        assertEquals(2, auditHandler.getEventsReceived().size());
    }

    @Test
    void testLogJSON() {
        // Given
        auditHandler.setReturnValueForLog(true);
        String jsonEvent = "{\"eventTime\":\"2023-05-20\",\"accessType\":\"read\"}";

        // When
        boolean result = auditHandler.logJSON(jsonEvent);

        // Then
        assertTrue(result);
        assertEquals(1, auditHandler.getEventsReceived().size());
        assertTrue(auditHandler.getEventsReceived().get(0) instanceof AuthzAuditEvent);
    }

    @Test
    void testLogJSONCollection() {
        // Given
        auditHandler.setReturnValueForLog(true);
        Collection<String> jsonEvents = Arrays.asList(
                "{\"eventTime\":\"2023-05-20\",\"accessType\":\"read\"}",
                "{\"eventTime\":\"2023-05-21\",\"accessType\":\"write\"}");

        // When
        boolean result = auditHandler.logJSON(jsonEvents);

        // Then
        assertTrue(result);
        assertEquals(2, auditHandler.getEventsReceived().size());
    }

    @Test
    void testLogFile() {
        // Default implementation should return false
        File file = new File(tempDir.toFile(), "audit.log");

        boolean result = auditHandler.logFile(file);

        assertFalse(result);
    }

    @Test
    void testSetName() {
        auditHandler.setName("customName");

        assertEquals("customName", auditHandler.getName());
    }

    @Test
    void testSetParentPath() {
        auditHandler.setParentPath("parent");
        auditHandler.setName("child");

        assertEquals("parent.child", auditHandler.getName());
        assertEquals("parent", auditHandler.getParentPath());
    }

    @Test
    void testGetFinalPath() {
        auditHandler.setName("testHandler");

        assertEquals("testHandler", auditHandler.getFinalPath());
    }

    @Test
    void testCounters() {
        assertEquals(0, auditHandler.getTotalCount());

        auditHandler.addTotalCount(5);
        assertEquals(5, auditHandler.getTotalCount());

        auditHandler.addSuccessCount(3);
        assertEquals(3, auditHandler.getTotalSuccessCount());

        auditHandler.addFailedCount(2);
        assertEquals(2, auditHandler.getTotalFailedCount());

        auditHandler.addStashedCount(1);
        assertEquals(1, auditHandler.getTotalStashedCount());

        auditHandler.addDeferredCount(4);
        assertEquals(4, auditHandler.getTotalDeferredCount());
    }

    @Test
    void testFormatIntervalForLog() {
        assertEquals("500 milli-seconds", auditHandler.formatIntervalForLog(500));
        assertEquals("05.250 seconds", auditHandler.formatIntervalForLog(5250));
        assertEquals("01:30.000 minutes", auditHandler.formatIntervalForLog(90000));
        assertEquals("02:15:30.500 hours", auditHandler.formatIntervalForLog(8130500));
    }

    @Test
    void testLogFailedEvent() throws Exception {
        // Set up a field to access the private counter
        Field countLifeTimeField = BaseAuditHandler.class.getDeclaredField("mFailedLogCountLifeTime");
        countLifeTimeField.setAccessible(true);

        // Before logging failure
        long initialCount = ((java.util.concurrent.atomic.AtomicLong) countLifeTimeField.get(auditHandler)).get();

        // Log a failed event
        auditHandler.logFailedEvent(mockAuditEvent);

        // After logging failure
        long afterCount = ((java.util.concurrent.atomic.AtomicLong) countLifeTimeField.get(auditHandler)).get();

        assertEquals(initialCount + 1, afterCount, "Failed event count should be incremented");
    }

    @Test
    void testLogFailedEvents() throws Exception {
        // Set up a field to access the private counter
        Field countLifeTimeField = BaseAuditHandler.class.getDeclaredField("mFailedLogCountLifeTime");
        countLifeTimeField.setAccessible(true);

        Collection<AuditEventBase> events = Arrays.asList(
                mockAuditEvent,
                mock(AuditEventBase.class));

        // Before logging failures
        long initialCount = ((java.util.concurrent.atomic.AtomicLong) countLifeTimeField.get(auditHandler)).get();

        // Log failed events
        auditHandler.logFailedEvent(events);

        // After logging failures
        long afterCount = ((java.util.concurrent.atomic.AtomicLong) countLifeTimeField.get(auditHandler)).get();

        assertEquals(initialCount + 2, afterCount, "Failed event count should be incremented by 2");
    }

    @Test
    void testLogStatus() {
        // Set up some counts
        auditHandler.addTotalCount(100);
        auditHandler.addSuccessCount(90);
        auditHandler.addFailedCount(10);

        // This should execute without exceptions
        auditHandler.logStatus();

        // Verify the counters were stored
        assertEquals(100, auditHandler.lastIntervalCount);
        assertEquals(90, auditHandler.lastIntervalSuccessCount);
        assertEquals(10, auditHandler.lastIntervalFailedCount);
    }

    @Test
    void testLogErrorString() {
        // Should log error without throwing
        auditHandler.logError("Test error message");
    }

    @Test
    void testLogErrorStringThrowable() {
        // Should log error with exception without throwing
        Exception ex = new Exception("Test exception");
        auditHandler.logError("Test error with exception", ex);
    }

    @Test
    void testGetTimeDiffStr() {
        long t1 = 1000L;
        long t2 = 2500L;
        String diff = auditHandler.getTimeDiffStr(t1, t2);
        assertNotNull(diff);
        assertTrue(diff.contains("milli-seconds") || diff.contains("seconds") || diff.contains("minutes") || diff.contains("hours"));
    }

    @Test
    void testFormatIntervalForLogEdgeCases() {
        // 0 ms
        assertEquals("000 milli-seconds", auditHandler.formatIntervalForLog(0));
        // 1 hour, 2 minutes, 3 seconds, 4 ms = 3723004 ms
        assertEquals("01:02:03.004 hours", auditHandler.formatIntervalForLog(3723004));
    }

    // Test implementation of BaseAuditHandler for testing
    static class TestBaseAuditHandler extends BaseAuditHandler {
        private boolean returnValueForLog;
        private ArrayList<AuditEventBase> eventsReceived = new ArrayList<>();

        public void setReturnValueForLog(boolean value) {
            returnValueForLog = value;
        }

        public ArrayList<AuditEventBase> getEventsReceived() {
            return eventsReceived;
        }

        @Override
        public boolean log(Collection<AuditEventBase> events) {
            eventsReceived.addAll(events);
            return returnValueForLog;
        }

        @Override
        public void start() {
            // No-op for testing
        }

        @Override
        public void stop() {
            // No-op for testing
        }

        @Override
        public void flush() {
            // No-op for testing
        }

        @Override
        public void waitToComplete() {
            // No-op for testing
        }

        @Override
        public void waitToComplete(long timeout) {
            // No-op for testing
        }
    }
}
