/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.queue;

import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.provider.AuditHandler;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AuditFileCacheProviderSpool
 * */
class AuditFileCacheProviderSpoolTest {
    private AuditHandler mockHandler;
    private AuditFileCacheProviderSpool spool;
    private File tempDir;
    private Properties props;

    @BeforeEach
    void setUp() throws Exception {
        mockHandler = mock(AuditHandler.class);
        tempDir = Files.createTempDirectory("auditspooltest").toFile();
        tempDir.deleteOnExit();

        props = new Properties();
        props.setProperty("xasecure.audit.filespool.filespool.dir", tempDir.getAbsolutePath());
        props.setProperty("xasecure.audit.filespool.filespool.archive.dir", new File(tempDir, "archive").getAbsolutePath());
        props.setProperty("xasecure.audit.filespool.filespool.index.filename", "index_test.json");
        props.setProperty("xasecure.audit.provider.filecache.is.enabled", "true");

        spool = new AuditFileCacheProviderSpool(mockHandler);
    }

    @AfterEach
    void tearDown() {
        if (spool != null) {
            spool.stop();
        }
        if (tempDir != null && tempDir.exists()) {
            File[] files = tempDir.listFiles();
            if (files != null) {
                for (File f : files) {
                    f.delete();
                }
            }
            tempDir.delete();
        }
    }

    @Test
    void testInitCreatesFilesAndFolders() {
        boolean result = spool.init(props, "xasecure.audit.filespool");
        assertTrue(result);
        assertTrue(spool.logFolder.exists());
        assertTrue(spool.archiveFolder.exists());
        assertTrue(spool.indexFile.exists());
        assertTrue(spool.indexDoneFile.exists());
    }

    @Test
    void testStartAndStopThread() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        spool.start();
        assertNotNull(spool.destinationThread);
        assertTrue(spool.destinationThread.isAlive());
        spool.stop();
        assertNull(spool.destinationThread);
    }

    @Test
    void testStashSingleEvent() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        AuditEventBase event = mock(AuditEventBase.class);
        spool.stashLogs(event);
        assertTrue(spool.isPending());
        assertTrue(spool.isSpoolingSuccessful());
    }

    @Test
    void testStashMultipleEvents() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        List<AuditEventBase> events = Arrays.asList(event1, event2);
        spool.stashLogs(events);
        assertTrue(spool.isPending());
    }

    @Test
    void testFlushDoesNotThrow() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertDoesNotThrow(() -> spool.flush());
    }

    @Test
    void testIsPendingBeforeAndAfterInit() {
        assertFalse(spool.isPending());
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertFalse(spool.isPending());
    }

    @Test
    void testDoubleInitReturnsTrue() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertTrue(spool.init(props, "xasecure.audit.filespool")); // Should log error and return true
    }

    @Test
    void testStashLogsStringCollection() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        List<String> events = Arrays.asList("event1", "event2", "event3");
        assertDoesNotThrow(() -> spool.stashLogsString(events));
    }

    @Test
    void testStashLogsStringAfterStop() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        spool.stop();
        spool.stashLogsString("event after stop");
        assertTrue(true); // Should not throw
    }

    @Test
    void testStashLogsAfterStop() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        spool.stop();
        AuditEventBase event = mock(AuditEventBase.class);
        spool.stashLogs(event); // Should log error but not throw
        assertTrue(true);
    }

    @Test
    void testStartWithoutInit() {
        AuditFileCacheProviderSpool uninitSpool = new AuditFileCacheProviderSpool(mockHandler);
        uninitSpool.start();
        assertNull(uninitSpool.destinationThread);
    }

    @Test
    void testFlushWithoutInit() {
        AuditFileCacheProviderSpool uninitSpool = new AuditFileCacheProviderSpool(mockHandler);
        assertDoesNotThrow(uninitSpool::flush);
    }

    @Test
    void testGetLastAttemptTimeDelta() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertEquals(0, spool.getLastAttemptTimeDelta());
    }

    @Test
    void testRollOverSpoolFileByTime() throws Exception {
        // Set up a very short rollover time
        props.setProperty("xasecure.audit.filespool.filespool.file.rollover.sec", "1"); // 1 second for quick testing
        spool.init(props, "xasecure.audit.filespool");

        // Get access to private field
        Field fileRolloverSecField = AuditFileCacheProviderSpool.class.getDeclaredField("fileRolloverSec");
        fileRolloverSecField.setAccessible(true);
        fileRolloverSecField.set(spool, 1); // 1 second for quick testing

        // Create initial log file
        AuditEventBase mockEvent = mock(AuditEventBase.class);
        spool.stashLogs(mockEvent);

        // Access the current writer record using reflection
        Field writerRecordField = AuditFileCacheProviderSpool.class.getDeclaredField("currentWriterIndexRecord");
        writerRecordField.setAccessible(true);
        AuditFileCacheProviderSpool.AuditIndexRecord firstRecord =
                (AuditFileCacheProviderSpool.AuditIndexRecord) writerRecordField.get(spool);
        String firstFilePath = firstRecord.filePath;

        // Sleep to trigger rollover time
        Thread.sleep(1500);

        // Write another event which should trigger rollover
        spool.stashLogs(mockEvent);

        // Get the new writer record
        AuditFileCacheProviderSpool.AuditIndexRecord secondRecord =
                (AuditFileCacheProviderSpool.AuditIndexRecord) writerRecordField.get(spool);

        // Assert file has changed
        assertNotEquals(firstFilePath, secondRecord.filePath);

        // Verify first file was added to the index queue
        Field indexQueueField = AuditFileCacheProviderSpool.class.getDeclaredField("indexQueue");
        indexQueueField.setAccessible(true);
        BlockingQueue<AuditFileCacheProviderSpool.AuditIndexRecord> indexQueue =
                (BlockingQueue<AuditFileCacheProviderSpool.AuditIndexRecord>) indexQueueField.get(spool);

        boolean fileInQueue = false;
        for (AuditFileCacheProviderSpool.AuditIndexRecord record : indexQueue) {
            if (record.filePath.equals(firstFilePath)) {
                fileInQueue = true;
                break;
            }
        }
        assertTrue(fileInQueue, "First file should be in the index queue after rollover");
    }

    @Test
    void testCloseFileIfNeeded() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create log file by writing an event
        AuditEventBase mockEvent = mock(AuditEventBase.class);
        spool.stashLogs(mockEvent);

        // Set closeFile flag to true
        Field closeFileField = AuditFileCacheProviderSpool.class.getDeclaredField("closeFile");
        closeFileField.setAccessible(true);
        closeFileField.set(spool, true);

        // Get access to private closeFileIfNeeded method
        Method closeFileIfNeededMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod("closeFileIfNeeded");
        closeFileIfNeededMethod.setAccessible(true);

        // Get current writer record before closing
        Field writerRecordField = AuditFileCacheProviderSpool.class.getDeclaredField("currentWriterIndexRecord");
        writerRecordField.setAccessible(true);
        AuditFileCacheProviderSpool.AuditIndexRecord recordBeforeClose =
                (AuditFileCacheProviderSpool.AuditIndexRecord) writerRecordField.get(spool);

        // Invoke the method
        closeFileIfNeededMethod.invoke(spool);

        // Verify the writer is now null
        Field logWriterField = AuditFileCacheProviderSpool.class.getDeclaredField("logWriter");
        logWriterField.setAccessible(true);
        assertNull(logWriterField.get(spool));

        // Verify currentWriterIndexRecord is null
        assertNull(writerRecordField.get(spool));

        // Verify record was added to indexQueue
        Field indexQueueField = AuditFileCacheProviderSpool.class.getDeclaredField("indexQueue");
        indexQueueField.setAccessible(true);
        BlockingQueue<AuditFileCacheProviderSpool.AuditIndexRecord> indexQueue =
                (BlockingQueue<AuditFileCacheProviderSpool.AuditIndexRecord>) indexQueueField.get(spool);

        boolean found = false;
        for (AuditFileCacheProviderSpool.AuditIndexRecord record : indexQueue) {
            if (record.filePath.equals(recordBeforeClose.filePath)) {
                found = true;
                assertEquals(AuditFileCacheProviderSpool.SPOOL_FILE_STATUS.pending, record.status);
                break;
            }
        }
        assertTrue(found, "Closed file should be added to the index queue with pending status");
    }

    @Test
    void testSendEvent() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create mock events
        List<AuditEventBase> mockEvents = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            mockEvents.add(mock(AuditEventBase.class));
        }

        // Create index record
        AuditFileCacheProviderSpool.AuditIndexRecord indexRecord = new AuditFileCacheProviderSpool.AuditIndexRecord();
        indexRecord.id = UUID.randomUUID().toString();
        indexRecord.filePath = "test_path";

        // Mock the handler to succeed
        when(mockHandler.log(anyCollection())).thenReturn(true);

        // Get access to private sendEvent method
        Method sendEventMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod(
                "sendEvent", List.class, AuditFileCacheProviderSpool.AuditIndexRecord.class, int.class);
        sendEventMethod.setAccessible(true);

        // Invoke the method
        boolean result = (Boolean) sendEventMethod.invoke(spool, mockEvents, indexRecord, 3);

        // Verify result
        assertTrue(result);
        verify(mockHandler).log(mockEvents);

        // Verify the lastSuccessTime was set
        assertNotNull(indexRecord.lastSuccessTime);
    }

    @Test
    void testAppendToDoneFile() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create a test file
        File testFile = new File(tempDir, "test_file.log");
        testFile.createNewFile();

        // Create index record
        AuditFileCacheProviderSpool.AuditIndexRecord indexRecord = new AuditFileCacheProviderSpool.AuditIndexRecord();
        indexRecord.id = UUID.randomUUID().toString();
        indexRecord.filePath = testFile.getAbsolutePath();
        indexRecord.status = AuditFileCacheProviderSpool.SPOOL_FILE_STATUS.done;
        indexRecord.writeCompleteTime = new Date();

        // Get access to appendToDoneFile method
        Method appendToDoneFileMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod(
                "appendToDoneFile", AuditFileCacheProviderSpool.AuditIndexRecord.class);
        appendToDoneFileMethod.setAccessible(true);

        // Invoke the method
        appendToDoneFileMethod.invoke(spool, indexRecord);

        // Verify the done file was created and contains data
        assertTrue(spool.indexDoneFile.exists());

        // Read the file content
        BufferedReader reader = new BufferedReader(new FileReader(spool.indexDoneFile));
        StringBuilder content = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            content.append(line);
        }
        reader.close();

        // Verify the content contains the record ID
        assertTrue(content.toString().contains(indexRecord.id));

        // Verify flush was called
        verify(mockHandler, times(2)).flush();

        // Verify file was archived (moved to archive folder)
        File archiveFile = new File(spool.archiveFolder, testFile.getName());
        assertTrue(archiveFile.exists() || !testFile.exists(),
                "Either the file should be moved to archive or deleted");
    }

    @Test
    void testSaveIndexFile() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Add some records to indexRecords
        Field indexRecordsField = AuditFileCacheProviderSpool.class.getDeclaredField("indexRecords");
        indexRecordsField.setAccessible(true);
        List<AuditFileCacheProviderSpool.AuditIndexRecord> indexRecords =
                (List<AuditFileCacheProviderSpool.AuditIndexRecord>) indexRecordsField.get(spool);

        // Create and add sample records
        AuditFileCacheProviderSpool.AuditIndexRecord record1 = new AuditFileCacheProviderSpool.AuditIndexRecord();
        record1.id = "test-id-1";
        record1.filePath = "/test/path1";
        record1.status = AuditFileCacheProviderSpool.SPOOL_FILE_STATUS.pending;

        AuditFileCacheProviderSpool.AuditIndexRecord record2 = new AuditFileCacheProviderSpool.AuditIndexRecord();
        record2.id = "test-id-2";
        record2.filePath = "/test/path2";
        record2.status = AuditFileCacheProviderSpool.SPOOL_FILE_STATUS.write_inprogress;

        indexRecords.add(record1);
        indexRecords.add(record2);

        // Call saveIndexFile
        Method saveIndexFileMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod("saveIndexFile");
        saveIndexFileMethod.setAccessible(true);
        saveIndexFileMethod.invoke(spool);

        // Verify the index file was created and contains expected content
        assertTrue(spool.indexFile.exists());

        // Read the file content
        BufferedReader reader = new BufferedReader(new FileReader(spool.indexFile));
        List<String> fileLines = new ArrayList<>();
        String line;
        while ((line = reader.readLine()) != null) {
            fileLines.add(line);
        }
        reader.close();

        // Verify the content includes both records
        assertEquals(2, fileLines.size());
        assertTrue(fileLines.get(0).contains("test-id-1"));
        assertTrue(fileLines.get(1).contains("test-id-2"));
    }

    @Test
    void testRemoveIndexRecord() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Add some records to indexRecords
        Field indexRecordsField = AuditFileCacheProviderSpool.class.getDeclaredField("indexRecords");
        indexRecordsField.setAccessible(true);
        List<AuditFileCacheProviderSpool.AuditIndexRecord> indexRecords =
                (List<AuditFileCacheProviderSpool.AuditIndexRecord>) indexRecordsField.get(spool);

        // Create and add sample records
        AuditFileCacheProviderSpool.AuditIndexRecord record1 = new AuditFileCacheProviderSpool.AuditIndexRecord();
        record1.id = "test-id-1";
        record1.filePath = "/test/path1";

        AuditFileCacheProviderSpool.AuditIndexRecord record2 = new AuditFileCacheProviderSpool.AuditIndexRecord();
        record2.id = "test-id-2";
        record2.filePath = "/test/path2";

        indexRecords.add(record1);
        indexRecords.add(record2);

        // Call removeIndexRecord
        Method removeIndexRecordMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod(
                "removeIndexRecord", AuditFileCacheProviderSpool.AuditIndexRecord.class);
        removeIndexRecordMethod.setAccessible(true);
        removeIndexRecordMethod.invoke(spool, record1);

        // Verify record1 was removed
        assertEquals(1, indexRecords.size());
        assertEquals("test-id-2", indexRecords.get(0).id);

        // Remove the last record
        removeIndexRecordMethod.invoke(spool, record2);

        // Verify all records removed
        assertTrue(indexRecords.isEmpty());

        // Verify isDestDown was reset when all records are removed
        Field isDestDownField = AuditFileCacheProviderSpool.class.getDeclaredField("isDestDown");
        isDestDownField.setAccessible(true);
        assertFalse((Boolean) isDestDownField.get(spool));
    }

    @Test
    void testLogError() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Get access to logError and lastErrorLogMS field
        Method logErrorMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod("logError", String.class);
        logErrorMethod.setAccessible(true);

        Field lastErrorLogMSField = AuditFileCacheProviderSpool.class.getDeclaredField("lastErrorLogMS");
        lastErrorLogMSField.setAccessible(true);

        // Set lastErrorLogMS to a value in the past
        lastErrorLogMSField.set(spool, System.currentTimeMillis() - 60000); // 1 minute ago

        // Call logError
        logErrorMethod.invoke(spool, "Test error message");

        // Verify lastErrorLogMS was updated
        long currentLastErrorLogMS = (Long) lastErrorLogMSField.get(spool);
        assertTrue(System.currentTimeMillis() - currentLastErrorLogMS < 1000); // Should be recent

        // Call logError again immediately (should not log)
        logErrorMethod.invoke(spool, "Another test error");

        // lastErrorLogMS should not have changed
        assertEquals(currentLastErrorLogMS, (Long) lastErrorLogMSField.get(spool));
    }

    @Test
    void testGetLogFileStream() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Get access to getLogFileStream method
        Method getLogFileStreamMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod("getLogFileStream");
        getLogFileStreamMethod.setAccessible(true);

        // Access the logWriter field
        Field logWriterField = AuditFileCacheProviderSpool.class.getDeclaredField("logWriter");
        logWriterField.setAccessible(true);

        // First call - should create new file
        PrintWriter writer1 = (PrintWriter) getLogFileStreamMethod.invoke(spool);
        assertNotNull(writer1);

        // Writer should be stored in logWriter field
        assertEquals(writer1, logWriterField.get(spool));

        // Second call - should return same writer
        PrintWriter writer2 = (PrintWriter) getLogFileStreamMethod.invoke(spool);
        assertEquals(writer1, writer2);

        // Verify currentWriterIndexRecord was created
        Field currentWriterIndexRecordField = AuditFileCacheProviderSpool.class.getDeclaredField("currentWriterIndexRecord");
        currentWriterIndexRecordField.setAccessible(true);
        assertNotNull(currentWriterIndexRecordField.get(spool));
    }

    @Test
    void testPrintIndex() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Add some records to indexRecords
        Field indexRecordsField = AuditFileCacheProviderSpool.class.getDeclaredField("indexRecords");
        indexRecordsField.setAccessible(true);
        List<AuditFileCacheProviderSpool.AuditIndexRecord> indexRecords =
                (List<AuditFileCacheProviderSpool.AuditIndexRecord>) indexRecordsField.get(spool);

        // Create and add sample records
        AuditFileCacheProviderSpool.AuditIndexRecord record1 = new AuditFileCacheProviderSpool.AuditIndexRecord();
        record1.id = "test-id-1";
        record1.filePath = "/test/path1";

        indexRecords.add(record1);

        // Get access to printIndex method
        Method printIndexMethod = AuditFileCacheProviderSpool.class.getDeclaredMethod("printIndex");
        printIndexMethod.setAccessible(true);

        // Call printIndex - just verify it doesn't throw an exception
        assertDoesNotThrow(() -> printIndexMethod.invoke(spool));
    }
}
