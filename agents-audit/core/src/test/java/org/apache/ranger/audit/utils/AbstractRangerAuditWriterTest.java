/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.audit.utils;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.CommonPathCapabilities;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AbstractRangerAuditWriter
 * */
class AbstractRangerAuditWriterTest {
    private TestRangerAuditWriter auditWriter;
    private Properties properties;
    private Map<String, String> auditConfigs;
    private String propPrefix = "xasecure.audit.destination.hdfs";
    private String auditProviderName = "hdfs";

    @TempDir
    File tempDir;

    @BeforeEach
    void setUp() {
        auditWriter = new TestRangerAuditWriter();
        properties = new Properties();
        auditConfigs = new HashMap<>();

        // Set up basic properties
        properties.setProperty(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_DIR, "file://" + tempDir.getAbsolutePath());
        properties.setProperty(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_SUBDIR, "audit/%app-type%/%time:yyyyMMdd%");
        properties.setProperty(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_FILE_NAME_FORMAT, "test_audit_%hostname%.log");
        properties.setProperty(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_FILE_ROLLOVER, "86400");
    }

    @Test
    void testInit() {
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);

        assertNotNull(auditWriter.auditConfigs);
        assertEquals(auditProviderName, auditWriter.auditProviderName);
        assertEquals("file://" + tempDir.getAbsolutePath() + "/audit/%app-type%/%time:yyyyMMdd%", auditWriter.logFolder);
        assertEquals("test_audit_%hostname%.log", auditWriter.logFileNameFormat);
        assertEquals(86400, auditWriter.fileRolloverSec);
        assertFalse(auditWriter.reUseLastLogFile);
        assertNotNull(auditWriter.nextRollOverTime);
    }

    @Test
    void testInitWithMissingFolder() {
        properties.remove(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_DIR);
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);

        // Should log error but not throw exception
        assertNull(auditWriter.logFolder);
    }

    @Test
    void testInitWithDefaultValues() {
        properties.remove(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_SUBDIR);
        properties.remove(propPrefix + "." + AbstractRangerAuditWriter.PROP_FILESYSTEM_FILE_NAME_FORMAT);

        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);

        assertTrue(auditWriter.logFolder.endsWith("/%app-type%/%time:yyyyMMdd%"));
        assertTrue(auditWriter.logFileNameFormat.contains("_ranger_audit_"));
    }

    @Test
    void testCreateConfiguration() {
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);

        auditConfigs.put("fs.defaultFS", "hdfs://localhost:9000");
        auditConfigs.put("empty.value", "");

        Configuration conf = auditWriter.createConfiguration();

        assertNotNull(conf);
        assertEquals("hdfs://localhost:9000", conf.get("fs.defaultFS"));
        // Empty value should be skipped
        assertNull(conf.get("empty.value"));
    }

    @Test
    void testFlushWithoutHFlushCapability() throws Exception {
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);

        // Mock stream without HFLUSH capability
        FSDataOutputStream mockStream = mock(FSDataOutputStream.class);
        when(mockStream.hasCapability(any())).thenReturn(false);

        auditWriter.ostream = mockStream;

        auditWriter.flush();

        verify(mockStream, times(1)).flush();
        verify(mockStream, never()).hflush();
    }

    @Test
    void testCloseWriter() {
        PrintWriter mockPrintWriter = mock(PrintWriter.class);
        FSDataOutputStream mockStream = mock(FSDataOutputStream.class);

        auditWriter.logWriter = mockPrintWriter;
        auditWriter.ostream = mockStream;

        auditWriter.closeWriter();

        verify(mockPrintWriter, times(1)).close();
        try {
            verify(mockStream, times(1)).close();
        } catch (Exception e) {
            fail("Exception should not be thrown: " + e.getMessage());
        }

        // Second call should be no-op
        auditWriter.closeWriter();
    }

    @Test
    void testResetWriter() {
        auditWriter.logWriter = mock(PrintWriter.class);
        auditWriter.ostream = mock(FSDataOutputStream.class);

        auditWriter.resetWriter();

        assertNull(auditWriter.logWriter);
        assertNull(auditWriter.ostream);
    }

    @Test
    void testGetFileSystemScheme() {
        auditWriter.logFolder = "hdfs://localhost:9000/audit/logs";
        assertEquals("HDFS", auditWriter.getFileSystemScheme());

        auditWriter.logFolder = "file:///tmp/audit/logs";
        assertEquals("FILE", auditWriter.getFileSystemScheme());

        auditWriter.logFolder = "s3a://bucket/audit/logs";
        assertEquals("S3A", auditWriter.getFileSystemScheme());
    }

    @Test
    void testIsAppendEnabled() throws Exception {
        FileSystem mockFs = mock(FileSystem.class);
        when(mockFs.hasPathCapability(any(Path.class), eq(CommonPathCapabilities.FS_APPEND)))
                .thenReturn(true);

        auditWriter.fileSystem = mockFs;
        auditWriter.auditPath = new Path("/tmp/test");

        // Use reflection to access private method
        java.lang.reflect.Method method = AbstractRangerAuditWriter.class.getDeclaredMethod("isAppendEnabled");
        method.setAccessible(true);

        boolean result = (boolean) method.invoke(auditWriter);
        assertTrue(result);

        // Test exception handling
        when(mockFs.hasPathCapability(any(Path.class), eq(CommonPathCapabilities.FS_APPEND)))
                .thenThrow(new RuntimeException("Test exception"));

        boolean result2 = (boolean) method.invoke(auditWriter);
        assertFalse(result2);
    }

    @Test
    void testCloseFileIfNeededWhenTimeToRollover() throws Exception {
        PrintWriter mockWriter = mock(PrintWriter.class);
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);
        auditWriter.logWriter = mockWriter;
        auditWriter.nextRollOverTime = new Date(System.currentTimeMillis() - 1000); // Past time

        auditWriter.closeFileIfNeeded();

        verify(mockWriter, times(1)).flush();
        assertNull(auditWriter.currentFileName);
        assertNull(auditWriter.auditPath);
        assertNull(auditWriter.fullPath);
        assertTrue(auditWriter.nextRollOverTime.getTime() > System.currentTimeMillis());
    }

    @Test
    void testCloseFileIfNeededWhenNotTimeToRollover() {
        PrintWriter mockWriter = mock(PrintWriter.class);
        auditWriter.logWriter = mockWriter;
        auditWriter.nextRollOverTime = new Date(System.currentTimeMillis() + 3600000); // Future time

        auditWriter.closeFileIfNeeded();

        verify(mockWriter, never()).flush();
    }

    @Test
    void testCloseFileIfNeededWithNullLogWriter() {
        auditWriter.logWriter = null;
        auditWriter.closeFileIfNeeded(); // Should not throw exception
    }

    @Test
    void testCreateParents() throws Exception {
        FileSystem mockFs = mock(FileSystem.class);
        Path testPath = new Path("/tmp/parent/child/file.log");
        Path parentPath = testPath.getParent();

        when(mockFs.exists(parentPath)).thenReturn(false);

        auditWriter.createParents(testPath, mockFs);

        verify(mockFs, times(1)).mkdirs(parentPath);

        // Test when parent already exists
        when(mockFs.exists(parentPath)).thenReturn(true);
        auditWriter.createParents(testPath, mockFs);

        // Should not call mkdirs again
        verify(mockFs, times(1)).mkdirs(parentPath);
    }

    @Test
    void testRollOverByDuration() {
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);
        auditWriter.fileRolloverSec = 3600; // 1 hour

        Date now = new Date();
        auditWriter.nextRollOverTime = now;

        Date nextRolloverTime = auditWriter.rollOverByDuration();

        // Should be about an hour later
        long diff = nextRolloverTime.getTime() - now.getTime();
        assertTrue(diff >= 3600000 - 1000 && diff <= 3600000 + 1000);
    }

    @Test
    void testCreateWriterWithAppend() throws Exception {
        auditWriter.init(properties, propPrefix, auditProviderName, auditConfigs);
        auditWriter.reUseLastLogFile = true;

        // Mock FileSystem
        FileSystem mockFs = mock(FileSystem.class);
        FSDataOutputStream mockStream = mock(FSDataOutputStream.class);

        when(mockFs.hasPathCapability(any(Path.class), eq(CommonPathCapabilities.FS_APPEND))).thenReturn(true);
        when(mockFs.append(any(Path.class))).thenReturn(mockStream);
        when(mockStream.hasCapability(any())).thenReturn(true);

        auditWriter.fileSystem = mockFs;
        auditWriter.fullPath = "file:///tmp/test/audit.log";
        auditWriter.auditPath = new Path(auditWriter.fullPath);

        PrintWriter writer = auditWriter.createWriter();

        assertNotNull(writer);
        verify(mockFs, times(1)).append(any(Path.class));
        verify(mockFs, never()).create(any(Path.class));
    }

    private static class TestRangerAuditWriter extends AbstractRangerAuditWriter {
        // Fix the implementation to properly override all abstract methods
        public boolean log(Object message) throws Exception {
            return true;
        }

        public boolean log(String line) throws Exception {
            return true;
        }

        // Add the missing method that's causing the compilation error
        @Override
        public boolean log(Collection<String> lines) throws Exception {
            return true;
        }

        @Override
        public boolean logFile(File file) throws Exception {
            return true;
        }

        // Add the missing start() method
        @Override
        public void start() {
            // No-op implementation for testing purposes
        }

        @Override
        public void stop() {
            // No-op implementation for testing purposes
        }

        @Override
        public void init(Properties props, String propPrefix) {
            super.init(props, propPrefix);
        }
    }
}
