/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.queue;

import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.provider.AuditHandler;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyLong;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AuditBatchQueue
 * */
class AuditBatchQueueTest {
    private AuditHandler mockHandler;
    private AuditBatchQueue queue;

    @BeforeEach
    void setUp() {
        mockHandler = mock(AuditHandler.class);
        queue = new AuditBatchQueue(mockHandler);
        queue.setMaxQueueSize(10);
        queue.setMaxBatchSize(5);
        queue.setMaxBatchInterval(100);
    }

    @Test
    void testLogSingleEvent() {
        queue.start();
        AuditEventBase event = mock(AuditEventBase.class);
        assertTrue(queue.log(event));
    }

    @Test
    void testLogMultipleEvents() {
        queue.start();
        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        assertTrue(queue.log(Arrays.asList(event1, event2)));
    }

    @Test
    void testStartAndStop() throws InterruptedException {
        queue.start();
        assertNotNull(queue.consumerThread);
        assertTrue(queue.consumerThread.isAlive());

        queue.stop();
        TimeUnit.MILLISECONDS.sleep(100);
        assertNull(queue.consumerThread);
    }

    @Test
    void testStopCallsConsumerStop() throws InterruptedException {
        queue.start();
        queue.stop();
        TimeUnit.MILLISECONDS.sleep(100);
        verify(mockHandler, atLeastOnce()).stop();
    }

    @Test
    void testDoubleStartDoesNotCreateNewThread() {
        queue.start();
        Thread firstThread = queue.consumerThread;
        queue.start(); // Should not create a new thread
        assertEquals(firstThread, queue.consumerThread);
    }

    @Test
    void testLogAfterStopDoesNotThrow() {
        queue.start();
        queue.stop();
        AuditEventBase event = mock(AuditEventBase.class);
        assertDoesNotThrow(() -> queue.log(event));
    }

    @Test
    void testFlushCallsConsumerFlush() {
        queue.start();
        queue.flush();
        verify(mockHandler, atLeastOnce()).flush();
    }

    @Test
    void testWaitToCompleteCallsConsumerWaitToComplete() {
        queue.start();
        queue.waitToComplete();
        verify(mockHandler, atLeastOnce()).waitToComplete(anyLong());
    }

    @Test
    void testLogEmptyCollectionReturnsTrue() {
        queue.start();
        assertTrue(queue.log(Collections.emptyList()));
    }

    @Test
    void testWaitToCompleteWithTimeout() {
        queue.start();
        queue.waitToComplete(100);
        verify(mockHandler).waitToComplete(100);
    }

    @Test
    void testFlush() {
        queue.start();
        queue.flush();
        verify(mockHandler).flush();
    }

    @Test
    void testRunLogAuditWithFileSpooling() throws Exception {
        // Setup fileSpooler
        AuditFileSpool mockSpooler = mock(AuditFileSpool.class);
        when(mockSpooler.isPending()).thenReturn(true);
        when(mockSpooler.getLastAttemptTimeDelta()).thenReturn(6000L); // Greater than default maxWaitTime

        // Set fileSpooler using reflection
        Field fileSpoolerField = AuditQueue.class.getDeclaredField("fileSpooler");
        fileSpoolerField.setAccessible(true);
        fileSpoolerField.set(queue, mockSpooler);

        queue.fileSpoolerEnabled = true;
        queue.fileSpoolMaxWaitTime = 5000;
        queue.fileSpoolDrainThresholdPercent = 80;

        queue.start();

        // Add event to trigger processing
        AuditEventBase mockEvent = mock(AuditEventBase.class);
        queue.log(mockEvent);

        // Wait for processing
        TimeUnit.MILLISECONDS.sleep(200);

        // Verify event was spooled due to fileSpoolDrain condition
        verify(mockSpooler, atLeastOnce()).stashLogs(anyCollection());

        queue.stop();
    }

    @Test
    void testRunLogAuditWithDestinationFailure() throws Exception {
        // Setup consumer to return failure
        when(mockHandler.log(anyCollection())).thenReturn(false);

        // Setup fileSpooler
        AuditFileSpool mockSpooler = mock(AuditFileSpool.class);

        // Set fileSpooler using reflection
        Field fileSpoolerField = AuditQueue.class.getDeclaredField("fileSpooler");
        fileSpoolerField.setAccessible(true);
        fileSpoolerField.set(queue, mockSpooler);

        queue.fileSpoolerEnabled = true;

        queue.start();

        // Add event to trigger processing
        AuditEventBase mockEvent = mock(AuditEventBase.class);
        queue.log(mockEvent);

        // Wait for processing
        TimeUnit.MILLISECONDS.sleep(200);

        // Verify event was stashed due to consumer failure
        verify(mockSpooler, atLeastOnce()).stashLogs(anyCollection());

        queue.stop();
    }

    @Test
    void testWaitToCompleteStaticLoop() throws Exception {
        queue.start();
        Field queueField = AuditBatchQueue.class.getDeclaredField("queue");
        queueField.setAccessible(true);
        BlockingQueue<AuditEventBase> blockingQueue = mock(BlockingQueue.class);
        when(blockingQueue.isEmpty()).thenReturn(false);
        when(blockingQueue.size()).thenReturn(1);
        queueField.set(queue, blockingQueue);

        Field localBatchBufferField = AuditBatchQueue.class.getDeclaredField("localBatchBuffer");
        localBatchBufferField.setAccessible(true);
        localBatchBufferField.set(queue, new ArrayList<>());

        // This will cause staticLoopCount to exceed 5 and break
        queue.waitToComplete(10);
        verify(mockHandler, atLeastOnce()).waitToComplete(anyLong());
    }

    @Test
    void testRunHandlesThrowable() throws Exception {
        AuditBatchQueue testQueue = spy(new AuditBatchQueue(mockHandler));
        doThrow(new RuntimeException("test")).when(testQueue).runLogAudit();
        testQueue.run(); // Should log error, not throw
    }

    @Test
    void testRunLogAuditDrainModeExits() throws Exception {
        queue.start();
        queue.setDrain(true);
        // Wait for thread to exit
        TimeUnit.MILLISECONDS.sleep(200);
        assertTrue(queue.isDrain());
        queue.stop();
    }

    @Test
    void testFlushWithFileSpooler() throws Exception {
        AuditFileSpool mockSpooler = mock(AuditFileSpool.class);
        Field fileSpoolerField = AuditQueue.class.getDeclaredField("fileSpooler");
        fileSpoolerField.setAccessible(true);
        fileSpoolerField.set(queue, mockSpooler);
        queue.fileSpoolerEnabled = true;
        queue.flush();
        verify(mockSpooler).flush();
        verify(mockHandler).flush();
    }

    @Test
    void testLogInterruptedException() throws Exception {
        queue.start();
        Field queueField = AuditBatchQueue.class.getDeclaredField("queue");
        queueField.setAccessible(true);
        BlockingQueue<AuditEventBase> blockingQueue = mock(BlockingQueue.class);
        doThrow(new InterruptedException()).when(blockingQueue).put(any());
        queueField.set(queue, blockingQueue);
        AuditEventBase event = mock(AuditEventBase.class);
        assertThrows(RuntimeException.class, () -> queue.log(event));
    }
}
