/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.queue;

import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.model.AuditIndexRecord;
import org.apache.ranger.audit.model.SPOOL_FILE_STATUS;
import org.apache.ranger.audit.provider.AuditHandler;
import org.apache.ranger.audit.provider.MiscUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AuditFileSpool
 * */
class AuditFileSpoolTest {
    private AuditQueue mockQueue;
    private AuditHandler mockHandler;
    private AuditFileSpool spool;
    private File tempDir;
    private Properties props;

    @BeforeEach
    void setUp() throws Exception {
        mockQueue = mock(AuditQueue.class);
        when(mockQueue.getName()).thenReturn("testQueue");
        when(mockQueue.getMaxBatchSize()).thenReturn(10);

        mockHandler = mock(AuditHandler.class);
        when(mockHandler.getName()).thenReturn("testHandler");

        tempDir = Files.createTempDirectory("auditspooltest").toFile();
        tempDir.deleteOnExit();

        props = new Properties();
        props.setProperty("xasecure.audit.filespool.filespool.dir", tempDir.getAbsolutePath());
        props.setProperty("xasecure.audit.filespool.filespool.archive.dir", new File(tempDir, "archive").getAbsolutePath());
        props.setProperty("xasecure.audit.filespool.filespool.index.filename", "index_test.json");

        spool = new AuditFileSpool(mockQueue, mockHandler);
    }

    @AfterEach
    void tearDown() {
        if (spool != null) {
            spool.stop();
        }
        if (tempDir != null && tempDir.exists()) {
            File[] files = tempDir.listFiles();
            if (files != null) {
                for (File f : files) {
                    f.delete();
                }
            }
            tempDir.delete();
        }
    }

    @Test
    void testInitCreatesFilesAndFolders() {
        boolean result = spool.init(props, "xasecure.audit.filespool");
        assertTrue(result);
        assertTrue(spool.logFolder.exists());
        assertTrue(spool.archiveFolder.exists());
        assertTrue(spool.indexFile.exists());
        assertTrue(spool.indexDoneFile.exists());
    }

    @Test
    void testStartAndStopThread() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        spool.start();
        assertNotNull(spool.destinationThread);
        assertTrue(spool.destinationThread.isAlive());
        spool.stop();
        assertNull(spool.destinationThread);
    }

    @Test
    void testStashSingleEvent() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        AuditEventBase event = mock(AuditEventBase.class);
        spool.stashLogs(event);
        assertTrue(spool.isPending());
    }

    @Test
    void testStashMultipleEvents() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        List<AuditEventBase> events = Arrays.asList(event1, event2);
        spool.stashLogs(events);
        assertTrue(spool.isPending());
    }

    @Test
    void testFlushDoesNotThrow() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertDoesNotThrow(() -> spool.flush());
    }

    @Test
    void testIsPendingBeforeAndAfterInit() {
        assertFalse(spool.isPending());
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertFalse(spool.isPending());
    }

    @Test
    void testDoubleInitReturnsTrue() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertTrue(spool.init(props, "xasecure.audit.filespool")); // Should log error and return true
    }

    @Test
    void testStashLogsStringCollection() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        List<String> events = Arrays.asList("event1", "event2", "event3");
        assertDoesNotThrow(() -> spool.stashLogsString(events));
    }

    @Test
    void testStashLogsStringAfterStop() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        spool.stop();
        assertDoesNotThrow(() -> spool.stashLogsString("event after stop"));
    }

    @Test
    void testStashLogsAfterStop() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        spool.stop();
        AuditEventBase event = mock(AuditEventBase.class);
        assertDoesNotThrow(() -> spool.stashLogs(event));
    }

    @Test
    void testStartWithoutInit() {
        AuditFileSpool uninitSpool = new AuditFileSpool(mockQueue, mockHandler);
        uninitSpool.start();
        assertNull(uninitSpool.destinationThread);
    }

    @Test
    void testFlushWithoutInit() {
        AuditFileSpool uninitSpool = new AuditFileSpool(mockQueue, mockHandler);
        assertDoesNotThrow(uninitSpool::flush);
    }

    @Test
    void testIsPendingWithPendingIndexRecord() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        // Simulate a pending record by setting isPending manually
        spool.isPending = true;
        assertTrue(spool.isPending());
    }

    @Test
    void testGetLastAttemptTimeDelta() {
        assertTrue(spool.init(props, "xasecure.audit.filespool"));
        assertEquals(0, spool.getLastAttemptTimeDelta());
        spool.lastAttemptTime = System.currentTimeMillis() - 1000;
        assertTrue(spool.getLastAttemptTimeDelta() >= 1000);
    }

    @Test
    void testRollOverSpoolFileByTime() throws Exception {
        // Set up a very short rollover time
        props.setProperty("xasecure.audit.filespool.filespool.file.rollover.sec", "1"); // 1 second for quick testing
        spool.init(props, "xasecure.audit.filespool");

        // Access fileRolloverSec using reflection to ensure it's set properly
        java.lang.reflect.Field fileRolloverSecField = AuditFileSpool.class.getDeclaredField("fileRolloverSec");
        fileRolloverSecField.setAccessible(true);
        fileRolloverSecField.set(spool, 1); // 1 second for quick testing

        // Create initial log file
        AuditEventBase mockEvent = mock(AuditEventBase.class);
        spool.stashLogs(mockEvent);

        // Access the current writer record using reflection
        java.lang.reflect.Field writerRecordField = AuditFileSpool.class.getDeclaredField("currentWriterIndexRecord");
        writerRecordField.setAccessible(true);
        AuditIndexRecord firstRecord = (AuditIndexRecord) writerRecordField.get(spool);
        String firstFilePath = firstRecord.getFilePath();

        // Sleep to trigger rollover time
        Thread.sleep(1500);

        // Write another event which should trigger rollover
        spool.stashLogs(mockEvent);

        // Get the new writer record
        AuditIndexRecord secondRecord = (AuditIndexRecord) writerRecordField.get(spool);

        // Assert file has changed
        assertNotEquals(firstFilePath, secondRecord.getFilePath());

        // Check if the first file is in the queue
        java.lang.reflect.Field indexQueueField = AuditFileSpool.class.getDeclaredField("indexQueue");
        indexQueueField.setAccessible(true);
        BlockingQueue<AuditIndexRecord> indexQueue = (BlockingQueue<AuditIndexRecord>) indexQueueField.get(spool);

        boolean fileInQueue = false;
        for (AuditIndexRecord record : indexQueue) {
            if (record.getFilePath().equals(firstFilePath)) {
                fileInQueue = true;
                break;
            }
        }
        assertTrue(fileInQueue, "First file should be in the index queue after rollover");
    }

    @Test
    void testRunLogAudit() throws Exception {
        // Set up quick retry time
        props.setProperty("xasecure.audit.filespool.filespool.destination.retry.ms", "100"); // 100ms for quick testing
        spool.init(props, "xasecure.audit.filespool");

        // Create a test file
        File testFile = new File(tempDir, "test_audit_events.log");
        try (PrintWriter writer = new PrintWriter(testFile)) {
            writer.println("{\"type\":\"ranger_audit\",\"id\":\"test_id_1\"}");
            writer.println("{\"type\":\"ranger_audit\",\"id\":\"test_id_2\"}");
        }

        // Create an index record for this file and add it to the queue
        AuditIndexRecord record = new AuditIndexRecord();
        record.setId(UUID.randomUUID().toString());
        record.setFilePath(testFile.getAbsolutePath());
        record.setStatus(SPOOL_FILE_STATUS.pending);

        // Add to the queue using reflection
        java.lang.reflect.Field indexQueueField = AuditFileSpool.class.getDeclaredField("indexQueue");
        indexQueueField.setAccessible(true);
        BlockingQueue<AuditIndexRecord> indexQueue = (BlockingQueue<AuditIndexRecord>) indexQueueField.get(spool);
        indexQueue.add(record);

        // Set the mock handler to accept events
        when(mockHandler.log(anyCollection())).thenReturn(true);
        when(mockHandler.logFile(any(File.class))).thenReturn(true);

        // Get access to runLogAudit method
        java.lang.reflect.Method runLogAuditMethod = AuditFileSpool.class.getDeclaredMethod("runLogAudit");
        runLogAuditMethod.setAccessible(true);

        // Create a flag for stopping the test
        java.util.concurrent.atomic.AtomicBoolean stopTest = new java.util.concurrent.atomic.AtomicBoolean(false);

        // Create a thread to run runLogAudit for a limited time
        Thread testThread = new Thread(() -> {
            try {
                // Set isDrain to true after a delay to stop processing
                new Thread(() -> {
                    try {
                        Thread.sleep(1000);
                        java.lang.reflect.Field isDrainField = AuditFileSpool.class.getDeclaredField("isDrain");
                        isDrainField.setAccessible(true);
                        isDrainField.set(spool, true);
                        stopTest.set(true);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }).start();

                // Run the audit processing method
                runLogAuditMethod.invoke(spool);
            } catch (Exception e) {
                // Ignore exceptions during test shutdown
            }
        });

        // Start the thread and wait for completion
        testThread.start();
        while (!stopTest.get()) {
            Thread.sleep(100);
        }
        testThread.join(2000);

        // Verify handler interactions
        verify(mockHandler, atLeastOnce()).getName();
    }

    @Test
    void testLoadIndexFile() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create a test index file with some records
        try (PrintWriter writer = new PrintWriter(spool.indexFile)) {
            writer.println("{\"id\":\"test-id-1\",\"filePath\":\"/test/path1\",\"status\":\"pending\"}");
            writer.println("{\"id\":\"test-id-2\",\"filePath\":\"/test/path2\",\"status\":\"write_inprogress\"}");
        }

        // Clear existing records
        java.lang.reflect.Field indexRecordsField = AuditFileSpool.class.getDeclaredField("indexRecords");
        indexRecordsField.setAccessible(true);
        List<AuditIndexRecord> indexRecords = (List<AuditIndexRecord>) indexRecordsField.get(spool);
        indexRecords.clear();

        // Call loadIndexFile
        java.lang.reflect.Method loadIndexFileMethod = AuditFileSpool.class.getDeclaredMethod("loadIndexFile");
        loadIndexFileMethod.setAccessible(true);
        loadIndexFileMethod.invoke(spool);

        // Verify records were loaded
        assertTrue(indexRecords.size() >= 2);
        boolean foundId1 = false;
        boolean foundId2 = false;

        for (AuditIndexRecord record : indexRecords) {
            if ("test-id-1".equals(record.getId())) {
                foundId1 = true; }
            if ("test-id-2".equals(record.getId())) {
                foundId2 = true; }
        }

        assertTrue(foundId1);
        assertTrue(foundId2);
    }

    @Test
    void testSendFileAndEvents() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create test data
        File testFile = new File(tempDir, "test_log_event.log");
        try (PrintWriter writer = new PrintWriter(testFile)) {
            writer.println("{ \"event\": \"test event 1\" }");
            writer.println("{ \"event\": \"test event 2\" }");
        }

        // Setup mock behavior
        when(mockHandler.logFile(any(File.class))).thenReturn(true);
        when(mockHandler.logJSON(anyCollection())).thenReturn(true);

        // Create a test index record
        AuditIndexRecord indexRecord = new AuditIndexRecord();
        indexRecord.setId(UUID.randomUUID().toString());
        indexRecord.setFilePath(testFile.getAbsolutePath());
        indexRecord.setStatus(SPOOL_FILE_STATUS.pending);

        // Access sendEvent method by its actual name
        java.lang.reflect.Method sendEventMethod = AuditFileSpool.class.getDeclaredMethod(
                "sendEvent", List.class, AuditIndexRecord.class, int.class);
        sendEventMethod.setAccessible(true);

        // Test the method with some lines
        List<String> lines = new ArrayList<>();
        lines.add("{ \"event\": \"test event 1\" }");
        lines.add("{ \"event\": \"test event 2\" }");

        boolean result = (Boolean) sendEventMethod.invoke(spool, lines, indexRecord, 3);
        assertTrue(result);

        // Verify handler was called
        verify(mockHandler).logJSON(lines);
    }

    @Test
    void testLogEventWithBufferedReader() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create a file with audit events
        File testFile = new File(tempDir, "test_log_event.log");
        try (PrintWriter writer = new PrintWriter(testFile)) {
            writer.println("{ \"event\": \"test event 1\" }");
            writer.println("{ \"event\": \"test event 2\" }");
        }

        // Create a BufferedReader for the file
        BufferedReader reader = new BufferedReader(new FileReader(testFile));

        // Prepare for the runLogAudit method which is what actually processes events
        // The private method we need to test is actually part of the runLogAudit flow

        // Setup mock behavior
        when(mockHandler.logJSON(anyCollection())).thenReturn(true);

        // Since we can't directly test logEvent (as it doesn't exist as a separate method),
        // we'll test the main processing logic in runLogAudit with a custom setup

        // Set up the currentConsumerIndexRecord field
        AuditIndexRecord record = new AuditIndexRecord();
        record.setId(UUID.randomUUID().toString());
        record.setFilePath(testFile.getAbsolutePath());
        record.setLinePosition(0);
        record.setStatus(SPOOL_FILE_STATUS.pending);

        java.lang.reflect.Field currentConsumerIndexRecordField =
                AuditFileSpool.class.getDeclaredField("currentConsumerIndexRecord");
        currentConsumerIndexRecordField.setAccessible(true);
        currentConsumerIndexRecordField.set(spool, record);

        // Now we can use the sendEvent method which is used internally
        java.lang.reflect.Method sendEventMethod = AuditFileSpool.class.getDeclaredMethod(
                "sendEvent", List.class, AuditIndexRecord.class, int.class);
        sendEventMethod.setAccessible(true);

        List<String> lines = new ArrayList<>();
        String line;
        while ((line = reader.readLine()) != null) {
            lines.add(line);
        }

        boolean result = (Boolean) sendEventMethod.invoke(spool, lines, record, lines.size());
        assertTrue(result);

        // Verify handler was called
        verify(mockHandler).logJSON(lines);

        reader.close();
    }

    @Test
    void testArchiveCleanup() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create archive files with dates in the past
        File archiveDir = spool.archiveFolder;

        // Create more than maxArchiveFiles (default 100) files
        // We'll create 10 for the test to keep it quick
        int maxArchiveFiles = 5; // Testing with a small number

        // Set maxArchiveFiles using reflection
        java.lang.reflect.Field maxArchiveFilesField =
                AuditFileSpool.class.getDeclaredField("maxArchiveFiles");
        maxArchiveFilesField.setAccessible(true);
        maxArchiveFilesField.set(spool, maxArchiveFiles);

        // Create archive files
        List<File> createdFiles = new ArrayList<>();
        for (int i = 0; i < maxArchiveFiles + 5; i++) {
            File archiveFile = new File(archiveDir, "test_archive_" + i + ".log");
            archiveFile.createNewFile();
            createdFiles.add(archiveFile);
        }

        // Create test index done file entries for these files
        try (PrintWriter writer = new PrintWriter(spool.indexDoneFile)) {
            for (int i = 0; i < maxArchiveFiles + 5; i++) {
                AuditIndexRecord record = new AuditIndexRecord();
                record.setId(UUID.randomUUID().toString());
                record.setFilePath(createdFiles.get(i).getAbsolutePath());
                record.setStatus(SPOOL_FILE_STATUS.done);
                record.setWriteCompleteTime(new Date());
                writer.println(MiscUtil.stringify(record));
            }
        }

        // Call appendToDoneFile which triggers archive cleanup
        AuditIndexRecord testRecord = new AuditIndexRecord();
        testRecord.setId(UUID.randomUUID().toString());
        testRecord.setFilePath(new File(tempDir, "test_trigger.log").getAbsolutePath());
        testRecord.setStatus(SPOOL_FILE_STATUS.done);
        testRecord.setWriteCompleteTime(new Date());

        // Access the appendToDoneFile method
        java.lang.reflect.Method appendToDoneFileMethod =
                AuditFileSpool.class.getDeclaredMethod("appendToDoneFile", AuditIndexRecord.class);
        appendToDoneFileMethod.setAccessible(true);

        // Call the method which should trigger archive cleanup
        appendToDoneFileMethod.invoke(spool, testRecord);

        // Verify that files were cleaned up (should only be maxArchiveFiles files left)
        File[] remainingFiles = archiveDir.listFiles(file -> file.getName().endsWith(".log"));
        assertNotNull(remainingFiles);
        assertTrue(remainingFiles.length <= maxArchiveFiles + 1); // +1 for the test_trigger.log
    }

    @Test
    void testCloseFileIfNeeded() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create a test file
        spool.stashLogsString("test event");

        // Get access to fields
        java.lang.reflect.Field logWriterField =
                AuditFileSpool.class.getDeclaredField("logWriter");
        logWriterField.setAccessible(true);

        java.lang.reflect.Field currentWriterIndexRecordField =
                AuditFileSpool.class.getDeclaredField("currentWriterIndexRecord");
        currentWriterIndexRecordField.setAccessible(true);

        // Verify writer was created
        assertNotNull(logWriterField.get(spool));
        assertNotNull(currentWriterIndexRecordField.get(spool));

        // Get access to indexQueue
        java.lang.reflect.Field indexQueueField =
                AuditFileSpool.class.getDeclaredField("indexQueue");
        indexQueueField.setAccessible(true);
        BlockingQueue<AuditIndexRecord> indexQueue =
                (BlockingQueue<AuditIndexRecord>) indexQueueField.get(spool);

        // Remember queue size
        int initialQueueSize = indexQueue.size();

        // Access closeFileIfNeeded method
        java.lang.reflect.Method closeFileIfNeededMethod =
                AuditFileSpool.class.getDeclaredMethod("closeFileIfNeeded");
        closeFileIfNeededMethod.setAccessible(true);

        // Set isDrain to true to force close
        java.lang.reflect.Field isDrainField =
                AuditFileSpool.class.getDeclaredField("isDrain");
        isDrainField.setAccessible(true);
        isDrainField.set(spool, true);

        // Call the method
        closeFileIfNeededMethod.invoke(spool);

        // Verify file was closed
        assertNull(logWriterField.get(spool));

        // And that record was moved to the queue
        assertTrue(indexQueue.size() > initialQueueSize);
    }

    @Test
    void testPrintIndex() throws Exception {
        spool.init(props, "xasecure.audit.filespool");

        // Create a test record
        AuditIndexRecord record = new AuditIndexRecord();
        record.setId(UUID.randomUUID().toString());
        record.setFilePath(new File(tempDir, "test_log.log").getAbsolutePath());
        record.setStatus(SPOOL_FILE_STATUS.pending);

        // Access indexRecords field
        java.lang.reflect.Field indexRecordsField =
                AuditFileSpool.class.getDeclaredField("indexRecords");
        indexRecordsField.setAccessible(true);
        List<AuditIndexRecord> indexRecords =
                (List<AuditIndexRecord>) indexRecordsField.get(spool);

        // Add our test record
        indexRecords.add(record);

        // Get access to printIndex method
        java.lang.reflect.Method printIndexMethod =
                AuditFileSpool.class.getDeclaredMethod("printIndex");
        printIndexMethod.setAccessible(true);

        // Call printIndex - just verify it doesn't throw an exception
        assertDoesNotThrow(() -> printIndexMethod.invoke(spool));
    }
}
