/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.provider;

import org.apache.ranger.audit.model.AuditEventBase;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Properties;
import java.util.concurrent.atomic.AtomicLong;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;

/**
 * @generated by copilot
 * @description Unit Test cases for AsyncAuditProvider
 */
class AsyncAuditProviderTest {
    private AsyncAuditProvider provider;
    private AuditHandler mockHandler;

    @BeforeEach
    void setUp() {
        mockHandler = mock(AuditHandler.class);
        provider = new AsyncAuditProvider("test", 10, 100);
        provider.addAuditProvider(mockHandler);
    }

    @Test
    void testLogEventIsQueued() {
        AuditEventBase event = mock(AuditEventBase.class);
        assertTrue(provider.log(event));
    }

    @Test
    void testInitCallsSuper() {
        Properties props = new Properties();
        assertDoesNotThrow(() -> provider.init(props));
    }

    @Test
    void testStartAndStopThread() throws InterruptedException {
        provider.start();
        // Use reflection to check if mThread is alive
        boolean isAlive = isThreadAlive(provider);
        assertTrue(isAlive);

        provider.stop();
        // Check again after stopping
        isAlive = isThreadAlive(provider);
        assertFalse(isAlive);
    }

    @Test
    void testWaitToCompleteReturns() {
        provider.waitToComplete(1);
        // Should return without exception
    }

    @Test
    void testSetAndGetIntervalLogDurationMS() {
        provider.setIntervalLogDurationMS(1234);
        assertEquals(1234, provider.getIntervalLogDurationMS());
    }

    @Test
    void testQueueOverflowDropsEvents() {
        AsyncAuditProvider smallProvider = new AsyncAuditProvider("small", 1, 100);
        smallProvider.addAuditProvider(mockHandler);
        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        smallProvider.log(event1);
        smallProvider.log(event2); // Should be dropped

        // Use reflection to get lifeTimeDropCount value
        long dropCount = getLifeTimeDropCount(smallProvider);
        assertEquals(1, dropCount);
    }

    @Test
    void testConstructorWithInvalidQueueSizeUsesDefault() {
        AsyncAuditProvider invalidProvider = new AsyncAuditProvider("invalid", -1, 100);
        assertNotNull(invalidProvider);
    }

    @Test
    void testDequeueEventTimeout() throws Exception {
        // Use reflection to call private dequeueEvent and simulate empty queue with flush interval
        java.lang.reflect.Method method = AsyncAuditProvider.class.getDeclaredMethod("dequeueEvent");
        method.setAccessible(true);
        Object result = method.invoke(provider);
        assertNull(result);
    }

    @Test
    void testIsEmptyReturnsTrueWhenQueueIsEmpty() throws Exception {
        java.lang.reflect.Method method = AsyncAuditProvider.class.getDeclaredMethod("isEmpty");
        method.setAccessible(true);
        boolean isEmpty = (boolean) method.invoke(provider);
        assertTrue(isEmpty);
    }

    @Test
    void testGetTimeTillNextFlushReturnsNonNegative() throws Exception {
        java.lang.reflect.Method method = AsyncAuditProvider.class.getDeclaredMethod("getTimeTillNextFlush");
        method.setAccessible(true);
        long time = (long) method.invoke(provider);
        assertTrue(time >= 0);
    }

    @Test
    void testLogSummaryIfRequiredDoesNotThrow() throws Exception {
        java.lang.reflect.Method method = AsyncAuditProvider.class.getDeclaredMethod("logSummaryIfRequired");
        method.setAccessible(true);
        method.invoke(provider);
    }

    // Helper method to access private mThread field using reflection
    private boolean isThreadAlive(AsyncAuditProvider provider) {
        try {
            java.lang.reflect.Field threadField = AsyncAuditProvider.class.getDeclaredField("mThread");
            threadField.setAccessible(true);
            Thread thread = (Thread) threadField.get(provider);
            return thread != null && thread.isAlive();
        } catch (Exception e) {
            fail("Failed to access mThread field: " + e.getMessage());
            return false;
        }
    }

    // Helper method to access private lifeTimeDropCount field using reflection
    private long getLifeTimeDropCount(AsyncAuditProvider provider) {
        try {
            java.lang.reflect.Field dropCountField = AsyncAuditProvider.class.getDeclaredField("lifeTimeDropCount");
            dropCountField.setAccessible(true);
            AtomicLong dropCount = (AtomicLong) dropCountField.get(provider);
            return dropCount.get();
        } catch (Exception e) {
            fail("Failed to access lifeTimeDropCount field: " + e.getMessage());
            return -1;
        }
    }
}
