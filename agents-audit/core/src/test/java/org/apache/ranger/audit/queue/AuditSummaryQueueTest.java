/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.queue;

import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.provider.AuditHandler;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AuditSummaryQueue
 * */
class AuditSummaryQueueTest {
    private AuditHandler mockHandler;
    private AuditSummaryQueue queue;
    private Properties props;

    @BeforeEach
    void setUp() {
        mockHandler = mock(AuditHandler.class);
        when(mockHandler.getName()).thenReturn("mockHandler");
        queue = new AuditSummaryQueue(mockHandler);

        props = new Properties();
        props.setProperty("test.summary.interval.ms", "1234");
    }

    @Test
    void testInitSetsSummaryInterval() {
        queue.init(props, "test");
        // Reflection to access private field
        try {
            Field field = AuditSummaryQueue.class.getDeclaredField("maxSummaryIntervalMs");
            field.setAccessible(true);
            int interval = (int) field.get(queue);
            assertEquals(1234, interval);
        } catch (Exception e) {
            fail("Reflection failed: " + e.getMessage());
        }
    }

    @Test
    void testLogSingleEvent() {
        AuditEventBase event = mock(AuditEventBase.class);
        assertTrue(queue.log(event));
    }

    @Test
    void testLogMultipleEvents() {
        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        List<AuditEventBase> events = Arrays.asList(event1, event2);
        assertTrue(queue.log(events));
    }

    @Test
    void testStartAndStopThread() {
        queue.start();
        assertNotNull(queue.consumerThread);
        assertTrue(queue.consumerThread.isAlive());
        queue.stop();
        assertNull(queue.consumerThread);
    }

    @Test
    void testLogReturnsFalseWhenQueueFull() throws Exception {
        queue.setMaxQueueSize(0); // Set max size to 0 to simulate full queue
        AuditEventBase event = mock(AuditEventBase.class);
        assertFalse(queue.log(event));
    }

    @Test
    void testDoubleInitDoesNotThrow() {
        queue.init(props, "test");
        assertDoesNotThrow(() -> queue.init(props, "test"));
    }

    @Test
    void testLogAfterStopDoesNotThrow() {
        queue.start();
        queue.stop();
        AuditEventBase event = mock(AuditEventBase.class);
        assertDoesNotThrow(() -> queue.log(event));
    }

    @Test
    void testStartIsIdempotent() {
        queue.start();
        Thread firstThread = queue.consumerThread;
        assertNotNull(firstThread);
        assertTrue(firstThread.isAlive());

        // Second start should not throw and should create a new thread
        assertDoesNotThrow(() -> queue.start());
        Thread secondThread = queue.consumerThread;
        assertNotNull(secondThread);
        assertTrue(secondThread.isAlive());
    }

    @Test
    void testStopIsIdempotent() {
        queue.start();
        queue.stop();
        assertNull(queue.consumerThread);
        // Second stop should not throw
        assertDoesNotThrow(() -> queue.stop());
    }

    @Test
    void testLogEmptyCollectionReturnsTrue() {
        assertTrue(queue.log(Collections.emptyList()));
    }

    @Test
    void testRunLogAuditDispatchesSummary() {
        AuditEventBase event = mock(AuditEventBase.class);
        when(event.getEventKey()).thenReturn("key1");
        when(event.getEventTime()).thenReturn(new Date());
        queue.log(event);

        // Set drain to true to force dispatch
        queue.setDrain(true);

        // Specify the type to resolve ambiguity
        when(mockHandler.log(any(AuditEventBase.class))).thenReturn(true);
        queue.runLogAudit();

        // After dispatch, summaryMap should be empty
        try {
            Field field = AuditSummaryQueue.class.getDeclaredField("summaryMap");
            field.setAccessible(true);
            Map<?, ?> map = (Map<?, ?>) field.get(queue);
            assertTrue(map.isEmpty());
        } catch (Exception e) {
            fail("Reflection failed: " + e.getMessage());
        }
        verify(mockHandler, atLeastOnce()).log(any(AuditEventBase.class));
    }

    @Test
    void testRunLogAuditWithInterruptedException() throws Exception {
        // Setup mock consumer
        when(mockHandler.log(any(AuditEventBase.class))).thenReturn(true);

        // Start the queue
        queue.start();

        // Add an event to the queue
        AuditEventBase event = mock(AuditEventBase.class);
        when(event.getEventKey()).thenReturn("test-key");
        when(event.getEventTime()).thenReturn(new Date());
        queue.log(event);

        // Interrupt the thread
        queue.consumerThread.interrupt();

        // Wait for a short time
        Thread.sleep(200);

        // Thread should still be alive after interrupt since it catches InterruptedException
        assertTrue(queue.consumerThread.isAlive());

        // Cleanup
        queue.stop();
    }

    @Test
    void testMultipleEventsWithSameKey() throws Exception {
        // Create events with the same key but different times
        AuditEventBase event1 = mock(AuditEventBase.class);
        when(event1.getEventKey()).thenReturn("same-key");
        Date startTime = new Date(System.currentTimeMillis() - 10000); // 10 seconds ago
        when(event1.getEventTime()).thenReturn(startTime);

        AuditEventBase event2 = mock(AuditEventBase.class);
        when(event2.getEventKey()).thenReturn("same-key");
        Date endTime = new Date(); // Now
        when(event2.getEventTime()).thenReturn(endTime);

        // Add events to queue
        queue.log(event1);
        queue.log(event2);

        // Set drain to true to force dispatch
        queue.setDrain(true);

        // Mock handler to return success
        when(mockHandler.log(any(AuditEventBase.class))).thenReturn(true);

        // Run the audit processing
        queue.runLogAudit();

        // Verify the event was updated with combined info
        verify(event1).setEventCount(2); // Should count both events

        // Verify duration is approximately 10 seconds (allow some buffer)
        ArgumentCaptor<Long> durationCaptor = ArgumentCaptor.forClass(Long.class);
        verify(event1).setEventDurationMS(durationCaptor.capture());
        long capturedDuration = durationCaptor.getValue();
        assertTrue(capturedDuration >= 9000 && capturedDuration <= 11000,
                "Duration should be around 10000ms but was " + capturedDuration);

        // Verify the event was logged
        verify(mockHandler).log(event1);
    }

    @Test
    void testTimeoutTriggersDispatch() throws Exception {
        // Set a very short summary interval
        Field maxSummaryIntervalMsField = AuditSummaryQueue.class.getDeclaredField("maxSummaryIntervalMs");
        maxSummaryIntervalMsField.setAccessible(true);
        maxSummaryIntervalMsField.set(queue, 100); // 100ms interval

        // Create a test event
        AuditEventBase event = mock(AuditEventBase.class);
        when(event.getEventKey()).thenReturn("test-key");
        when(event.getEventTime()).thenReturn(new Date());

        // Add event to queue
        queue.log(event);

        // Mock handler to return success
        when(mockHandler.log(any(AuditEventBase.class))).thenReturn(true);

        // Start processing
        queue.start();

        // Wait for interval to elapse and processing to occur
        Thread.sleep(200);

        // Verify the event was logged
        verify(mockHandler, timeout(500).atLeastOnce()).log(any(AuditEventBase.class));

        // Cleanup
        queue.stop();
    }

    @Test
    void testQueueDrainToWithMultipleEvents() {
        // Create more events than initial fetch
        List<AuditEventBase> events = new ArrayList<>();
        for (int i = 0; i < 500; i++) {
            AuditEventBase event = mock(AuditEventBase.class);
            when(event.getEventKey()).thenReturn("key-" + i);
            when(event.getEventTime()).thenReturn(new Date());
            events.add(event);
        }

        // Add all events to queue
        assertTrue(queue.log(events));

        // Set drain to true
        queue.setDrain(true);

        // Mock handler to return success
        when(mockHandler.log(any(AuditEventBase.class))).thenReturn(true);

        // Run the audit processing
        queue.runLogAudit();

        // Verify all events were processed
        verify(mockHandler, times(500)).log(any(AuditEventBase.class));
    }

    @Test
    void testEmptySummaryMapStillExits() {
        // Set drain to true with empty queue and summary map
        queue.setDrain(true);

        // Run the audit processing
        queue.runLogAudit();

        // Verify consumer stop was called
        verify(mockHandler).stop();
    }

    @Test
    void testConsumerStopException() {
        // Set up mock to throw exception on stop
        doThrow(new RuntimeException("Test exception")).when(mockHandler).stop();

        // Set drain to true
        queue.setDrain(true);

        // Run the audit processing - should catch exception
        assertDoesNotThrow(() -> queue.runLogAudit());

        // Verify consumer stop was called
        verify(mockHandler).stop();
    }
}
