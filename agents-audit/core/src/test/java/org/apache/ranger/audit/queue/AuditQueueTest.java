/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.queue;

import org.apache.ranger.audit.destination.AuditDestination;
import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.provider.AuditHandler;
import org.apache.ranger.audit.provider.BaseAuditHandler;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;
import java.util.Collection;
import java.util.List;
import java.util.Properties;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AuditQueue
 * */
class AuditQueueTest {
    static class TestAuditQueue extends AuditQueue {
        private String name = "testQueue";

        public TestAuditQueue(AuditHandler consumer) {
            super(consumer);
        }

        @Override
        public String getName() {
            return name; }

        @Override
        public void setName(String name) {
            this.name = name;
            super.setName(name); }

        public boolean log(Object event) {
            return true; }

        public boolean log(List<?> events) {
            return true; }

        @Override
        public boolean log(Collection<AuditEventBase> events) {
            return true; }

        @Override
        public void start() {}

        @Override
        public void stop() {}
    }

    private AuditHandler mockConsumer;
    private TestAuditQueue queue;

    @BeforeEach
    void setUp() {
        mockConsumer = mock(AuditHandler.class);
        queue = new TestAuditQueue(mockConsumer);
    }

    @Test
    void testInitSetsProperties() {
        Properties props = new Properties();
        props.setProperty("test.batch.size", "123");
        props.setProperty("test.queue.size", "456");
        props.setProperty("test.batch.interval.ms", "789");
        queue.init(props, "test");
        assertEquals(123, queue.getMaxBatchSize());
        assertEquals(456, queue.getMaxQueueSize());
        assertEquals(789, queue.getMaxBatchInterval());
    }

    @Test
    void testSetAndGetMaxBatchSize() {
        queue.setMaxBatchSize(42);
        assertEquals(42, queue.getMaxBatchSize());
    }

    @Test
    void testSetAndGetMaxQueueSize() {
        queue.setMaxQueueSize(99);
        assertEquals(99, queue.getMaxQueueSize());
    }

    @Test
    void testSetAndGetMaxBatchInterval() {
        queue.setMaxBatchInterval(77);
        assertEquals(77, queue.getMaxBatchInterval());
    }

    @Test
    void testFlushDelegatesToConsumer() {
        queue.flush();
        verify(mockConsumer).flush();
    }

    @Test
    void testWaitToCompleteDelegatesToConsumer() {
        queue.waitToComplete();
        verify(mockConsumer).waitToComplete(-1);
        queue.waitToComplete(100L);
        verify(mockConsumer).waitToComplete(100L);
    }

    @Test
    void testSetDrainAndIsDrain() {
        queue.setDrain(true);
        assertTrue(queue.isDrain());
        queue.setDrain(false);
        assertFalse(queue.isDrain());
    }

    @Test
    void testDoubleInitDoesNotThrow() {
        Properties props = new Properties();
        queue.init(props, "test");
        assertDoesNotThrow(() -> queue.init(props, "test"));
    }

    @Test
    void testSetNameUpdatesConsumerParentPath() {
        BaseAuditHandler baseHandler = mock(BaseAuditHandler.class);
        TestAuditQueue q = new TestAuditQueue(baseHandler);
        q.setName("newName");
        verify(baseHandler, atLeastOnce()).setParentPath("newName");
    }

    @Test
    void testSetParentPathUpdatesConsumerParentPath() {
        BaseAuditHandler baseHandler = mock(BaseAuditHandler.class);
        TestAuditQueue q = new TestAuditQueue(baseHandler);
        q.setParentPath("parentPath");
        verify(baseHandler, atLeastOnce()).setParentPath("testQueue");
    }

    @Test
    void testGetFinalPathWithBaseAuditHandler() {
        BaseAuditHandler baseHandler = mock(BaseAuditHandler.class);
        when(baseHandler.getFinalPath()).thenReturn("finalPath");
        TestAuditQueue q = new TestAuditQueue(baseHandler);
        assertEquals("finalPath", q.getFinalPath());
    }

    @Test
    void testGetFinalPathWithNullConsumer() {
        TestAuditQueue q = new TestAuditQueue(null);
        assertEquals("testQueue", q.getFinalPath());
    }

    @Test
    void testFileSpoolerInitFailure() {
        Properties props = new Properties();
        props.setProperty("test.filespool.enable", "true");
        props.setProperty("test.filespool.local.dir", System.getProperty("java.io.tmpdir") + "/audit_spool_test");

        // Mock the AuditFileSpool to simulate initialization failure
        AuditFileSpool mockSpool = mock(AuditFileSpool.class);
        when(mockSpool.init(any(), any())).thenReturn(false);

        // Use reflection to replace fileSpooler
        try {
            Field fileSpoolerField = AuditQueue.class.getDeclaredField("fileSpooler");
            fileSpoolerField.setAccessible(true);
            fileSpoolerField.set(queue, mockSpool);
        } catch (Exception e) {
            fail("Failed to set up test: " + e.getMessage());
        }

        queue.init(props, "test");

        assertFalse(queue.fileSpoolerEnabled);
    }

    @Test
    void testGetFinalPath() {
        // Case 1: consumer is a BaseAuditHandler
        BaseAuditHandler baseConsumer = mock(BaseAuditHandler.class);
        when(baseConsumer.getFinalPath()).thenReturn("finalPath");

        TestAuditQueue queueWithBaseHandler = new TestAuditQueue(baseConsumer);
        queueWithBaseHandler.setName("testQueue");

        assertEquals("finalPath", queueWithBaseHandler.getFinalPath());

        // Case 2: consumer is a regular AuditHandler
        AuditHandler regularConsumer = mock(AuditHandler.class);
        when(regularConsumer.getName()).thenReturn("consumerName");

        TestAuditQueue queueWithRegularHandler = new TestAuditQueue(regularConsumer);
        queueWithRegularHandler.setName("testQueue");

        assertEquals("consumerName", queueWithRegularHandler.getFinalPath());

        // Case 3: no consumer
        TestAuditQueue queueNoConsumer = new TestAuditQueue(null);
        queueNoConsumer.setName("testQueueNoConsumer");

        assertEquals("testQueueNoConsumer", queueNoConsumer.getFinalPath());
    }

    @Test
    void testWaitToComplete() {
        AuditHandler mockHandler = mock(AuditHandler.class);
        TestAuditQueue queueWithHandler = new TestAuditQueue(mockHandler);

        // Test waitToComplete without timeout
        queueWithHandler.waitToComplete();
        verify(mockHandler).waitToComplete(-1);

        // Test waitToComplete with timeout
        queueWithHandler.waitToComplete(5000);
        verify(mockHandler).waitToComplete(5000);

        // Test with null consumer
        TestAuditQueue queueWithNull = new TestAuditQueue(null);
        queueWithNull.waitToComplete(); // Should not throw exception
        queueWithNull.waitToComplete(5000); // Should not throw exception
    }

    @Test
    void testFlush() {
        AuditHandler mockHandler = mock(AuditHandler.class);
        TestAuditQueue queueWithHandler = new TestAuditQueue(mockHandler);

        queueWithHandler.flush();
        verify(mockHandler).flush();

        // Test with null consumer
        TestAuditQueue queueWithNull = new TestAuditQueue(null);
        queueWithNull.flush(); // Should not throw exception
    }

    @Test
    void testConsumerDestinationDetection() {
        // Test with a consumer that is an AuditDestination
        AuditDestination mockDestination = mock(AuditDestination.class);
        TestAuditQueue queueWithDestination = new TestAuditQueue(mockDestination);

        assertTrue(queueWithDestination.isConsumerDestination);

        // Test with a regular consumer
        AuditHandler mockHandler = mock(AuditHandler.class);
        TestAuditQueue queueWithHandler = new TestAuditQueue(mockHandler);

        assertFalse(queueWithHandler.isConsumerDestination);
    }
}
