/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.audit.provider;

import org.apache.ranger.audit.model.AuditEventBase;
import org.apache.ranger.audit.queue.AuditFileCacheProviderSpool;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.Collection;
import java.util.Properties;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by copilot
 * @description Unit Test cases for AuditFileCacheProvider
 * */
class AuditFileCacheProviderTest {
    @Mock
    private AuditHandler mockConsumer;

    @Mock
    private AuditFileCacheProviderSpool mockFileSpooler;

    @Mock
    private AuditEventBase mockEvent;

    private AuditFileCacheProvider provider;
    private Properties props;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);

        provider = new AuditFileCacheProvider(mockConsumer);

        // Use reflection to inject mock spooler
        try {
            java.lang.reflect.Field field = AuditFileCacheProvider.class.getDeclaredField("fileSpooler");
            field.setAccessible(true);
            field.set(provider, mockFileSpooler);
        } catch (Exception e) {
            fail("Failed to inject mock spooler: " + e.getMessage());
        }

        props = new Properties();
        props.setProperty("xasecure.audit.filecache.is.enabled", "true");
        props.setProperty("xasecure.audit.filecache.filespool.dir", "/tmp/audit/filespool");
    }

    @Test
    void testLogSingleEvent() {
        when(mockFileSpooler.isSpoolingSuccessful()).thenReturn(true);

        boolean result = provider.log(mockEvent);

        verify(mockFileSpooler).stashLogs(mockEvent);
        verify(mockFileSpooler).isSpoolingSuccessful();
        assertTrue(result);
    }

    @Test
    void testLogSingleEventFailure() {
        when(mockFileSpooler.isSpoolingSuccessful()).thenReturn(false);

        boolean result = provider.log(mockEvent);

        verify(mockFileSpooler).stashLogs(mockEvent);
        verify(mockFileSpooler).isSpoolingSuccessful();
        assertFalse(result);
    }

    @Test
    void testLogNullEvent() {
        boolean result = provider.log((AuditEventBase) null);

        verify(mockFileSpooler, never()).stashLogs(any(AuditEventBase.class));
        assertFalse(result);
    }

    @Test
    void testLogMultipleEvents() {
        when(mockFileSpooler.isSpoolingSuccessful()).thenReturn(true);

        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        Collection<AuditEventBase> events = Arrays.asList(event1, event2);

        boolean result = provider.log(events);

        verify(mockFileSpooler).stashLogs(event1);
        verify(mockFileSpooler).stashLogs(event2);
        verify(mockFileSpooler, times(2)).isSpoolingSuccessful();
        assertTrue(result);
    }

    @Test
    void testLogMultipleEventsWithFailure() {
        // First call returns true, second call returns false
        when(mockFileSpooler.isSpoolingSuccessful()).thenReturn(true, false);

        AuditEventBase event1 = mock(AuditEventBase.class);
        AuditEventBase event2 = mock(AuditEventBase.class);
        Collection<AuditEventBase> events = Arrays.asList(event1, event2);

        boolean result = provider.log(events);

        verify(mockFileSpooler).stashLogs(event1);
        verify(mockFileSpooler).stashLogs(event2);
        assertFalse(result);
    }

    @Test
    void testLogNullCollection() {
        boolean result = provider.log((Collection<AuditEventBase>) null);

        verify(mockFileSpooler, never()).stashLogs(any(AuditEventBase.class));
        assertTrue(result);
    }

    @Test
    void testInit() {
        // Create a provider that will create a real file spooler
        AuditFileCacheProvider realProvider = new AuditFileCacheProvider(mockConsumer);

        realProvider.init(props, null);

        // Verify consumer was initialized
        verify(mockConsumer).init(eq(props), eq("xasecure.audit.filecache"));

        // Verify file spooler was created and initialized
        assertNotNull(realProvider.fileSpooler);
    }

    @Test
    void testInitWithCustomPrefix() {
        // Create a provider that will create a real file spooler
        AuditFileCacheProvider realProvider = new AuditFileCacheProvider(mockConsumer);

        realProvider.init(props, "custom.prefix");

        // Verify consumer was initialized with custom prefix
        verify(mockConsumer).init(eq(props), eq("custom.prefix"));
    }

    @Test
    void testStart() {
        provider.start();

        verify(mockConsumer).start();
        verify(mockFileSpooler).start();
    }

    @Test
    void testStop() {
        provider.stop();

        verify(mockConsumer).stop();
    }

    @Test
    void testWaitToComplete() {
        provider.waitToComplete();

        verify(mockConsumer).waitToComplete();
    }

    @Test
    void testWaitToCompleteWithTimeout() {
        provider.waitToComplete(1000);

        verify(mockConsumer).waitToComplete(1000);
    }

    @Test
    void testFlush() {
        provider.flush();

        verify(mockConsumer).flush();
    }

    @Test
    void testStartWithNullConsumerAndSpooler() {
        // Create provider with null consumer
        AuditFileCacheProvider providerWithNullConsumer = new AuditFileCacheProvider(null);

        // This should not throw exception
        assertDoesNotThrow(providerWithNullConsumer::start);
    }

    @Test
    void testStopWithNullConsumer() {
        // Create provider with null consumer
        AuditFileCacheProvider providerWithNullConsumer = new AuditFileCacheProvider(null);

        // This should not throw exception
        assertDoesNotThrow(providerWithNullConsumer::stop);
    }

    @Test
    void testWaitToCompleteWithNullConsumer() {
        // Create provider with null consumer
        AuditFileCacheProvider providerWithNullConsumer = new AuditFileCacheProvider(null);

        // Use explicit method call without parameters to avoid ambiguity
        assertDoesNotThrow(() -> providerWithNullConsumer.waitToComplete());
    }

    @Test
    void testWaitToCompleteWithTimeoutNullConsumer() {
        // Create provider with null consumer
        AuditFileCacheProvider providerWithNullConsumer = new AuditFileCacheProvider(null);

        // This should not throw exception
        assertDoesNotThrow(() -> providerWithNullConsumer.waitToComplete(1000));
    }

    @Test
    void testFlushWithNullConsumer() {
        // Create provider with null consumer
        AuditFileCacheProvider providerWithNullConsumer = new AuditFileCacheProvider(null);

        // This should not throw exception
        assertDoesNotThrow(providerWithNullConsumer::flush);
    }
}
