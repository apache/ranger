/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXResourceDefDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.entity.XXAccessTypeDef;
import org.apache.ranger.entity.XXResourceDef;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.store.AbstractServiceStore;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.util.CLIUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForAtlasServiceDefUpdate_J10013 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForAtlasServiceDefUpdate_J10013 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);
            setIfPresent(patch, "daoMgr", daoMgr);

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testCheckIfHasOlderServiceDef_trueAndFalse() throws Exception {
        PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXResourceDefDao rdefDao = Mockito.mock(XXResourceDefDao.class);
        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(rdefDao);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);

        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(1L);

        XXResourceDef r1 = new XXResourceDef();
        r1.setName("entity");
        XXResourceDef r2 = new XXResourceDef();
        r2.setName("type");
        XXResourceDef r3 = new XXResourceDef();
        r3.setName("operation");
        XXResourceDef r4 = new XXResourceDef();
        r4.setName("taxonomy");
        XXResourceDef r5 = new XXResourceDef();
        r5.setName("term");
        Mockito.when(rdefDao.findByServiceDefId(1L)).thenReturn(Arrays.asList(r1, r2, r3, r4, r5));
        XXAccessTypeDef a1 = new XXAccessTypeDef();
        a1.setName("read");
        XXAccessTypeDef a2 = new XXAccessTypeDef();
        a2.setName("create");
        XXAccessTypeDef a3 = new XXAccessTypeDef();
        a3.setName("update");
        XXAccessTypeDef a4 = new XXAccessTypeDef();
        a4.setName("delete");
        XXAccessTypeDef a5 = new XXAccessTypeDef();
        a5.setName("all");
        Mockito.when(atDao.findByServiceDefId(1L)).thenReturn(Arrays.asList(a1, a2, a3, a4, a5));

        Method chk = PatchForAtlasServiceDefUpdate_J10013.class.getDeclaredMethod("checkIfHasOlderServiceDef",
                XXServiceDef.class);
        chk.setAccessible(true);
        boolean ok = (boolean) chk.invoke(patch, sdef);
        assertTrue(ok);

        XXResourceDef rBad = new XXResourceDef();
        rBad.setName("bad");
        Mockito.when(rdefDao.findByServiceDefId(1L)).thenReturn(Arrays.asList(r1, r2, r3, r4, rBad));
        boolean notOk = (boolean) chk.invoke(patch, sdef);
        assertFalse(notOk);
    }

    @Test
    public void testFindAccessTypeDef_foundAndNotFound() throws Exception {
        PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
        Method find = PatchForAtlasServiceDefUpdate_J10013.class.getDeclaredMethod("findAccessTypeDef", long.class,
                List.class);
        find.setAccessible(true);

        RangerServiceDef.RangerAccessTypeDef a = new RangerServiceDef.RangerAccessTypeDef();
        a.setItemId(10L);
        List<RangerServiceDef.RangerAccessTypeDef> list = new ArrayList<>();
        list.add(a);
        Object res = find.invoke(patch, 10L, list);
        assertNotNull(res);
        Object res2 = find.invoke(patch, 11L, list);
        assertTrue(res2 == null);
    }

    @Test
    public void testUpdateTagAccessTypeDef_compareAndImpliedGrants() throws Exception {
        PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
        Method upd = PatchForAtlasServiceDefUpdate_J10013.class.getDeclaredMethod("updateTagAccessTypeDef",
                RangerServiceDef.RangerAccessTypeDef.class, RangerServiceDef.RangerAccessTypeDef.class, String.class);
        upd.setAccessible(true);

        RangerServiceDef.RangerAccessTypeDef tag = new RangerServiceDef.RangerAccessTypeDef();
        tag.setName("atlas.read");
        RangerServiceDef.RangerAccessTypeDef svc = new RangerServiceDef.RangerAccessTypeDef();
        svc.setName("read");
        svc.setImpliedGrants(new HashSet<>(Collections.singleton("write")));
        boolean changed = (boolean) upd.invoke(patch, tag, svc, "atlas.");
        assertTrue(changed);
        assertEquals("atlas.read", tag.getName());
        assertTrue(tag.getImpliedGrants().contains("atlas.write"));

        // no change when already aligned
        tag.setName("atlas.read");
        svc.setName("read");
        svc.setImpliedGrants(new HashSet<>());
        boolean changed2 = (boolean) upd.invoke(patch, tag, svc, "atlas.");
        assertFalse(!changed2 && tag.getImpliedGrants() != null && tag.getImpliedGrants().isEmpty());
    }

    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
        Assertions.assertDoesNotThrow(() -> patch.init());
    }

    @Test
    public void testMain_Success_ExitZero() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchForAtlasServiceDefUpdate_J10013.class)).thenReturn(patch);
            CLIUtil cli = Mockito.mock(CLIUtil.class);
            cliMock.when(() -> CLIUtil.getBean(CLIUtil.class)).thenReturn(cli);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForAtlasServiceDefUpdate_J10013.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertNotNull(se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_Failure_ExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchForAtlasServiceDefUpdate_J10013.class))
                    .thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForAtlasServiceDefUpdate_J10013.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testUpdateTagAccessTypeDefs_trueAndFalse() throws Exception {
        PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
        Method m = PatchForAtlasServiceDefUpdate_J10013.class.getDeclaredMethod("updateTagAccessTypeDefs", List.class,
                List.class, long.class, String.class, String.class);
        m.setAccessible(true);

        // true case: one tag access with matching prefix gets updated
        RangerServiceDef.RangerAccessTypeDef svc = new RangerServiceDef.RangerAccessTypeDef();
        svc.setItemId(10L);
        svc.setName("read");
        svc.setImpliedGrants(new HashSet<>(Collections.singleton("write")));
        List<RangerServiceDef.RangerAccessTypeDef> svcDefs = new ArrayList<>();
        svcDefs.add(svc);

        RangerServiceDef.RangerAccessTypeDef tag = new RangerServiceDef.RangerAccessTypeDef();
        tag.setItemId(5005L + 10L); // offset + svc itemId
        tag.setName("atlas:" + "old");
        List<RangerServiceDef.RangerAccessTypeDef> tagDefs = new ArrayList<>();
        tagDefs.add(tag);

        boolean changed = (boolean) m.invoke(patch, svcDefs, tagDefs, 5005L,
                EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME
                        + AbstractServiceStore.COMPONENT_ACCESSTYPE_SEPARATOR,
                EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME
                        + AbstractServiceStore.COMPONENT_ACCESSTYPE_SEPARATOR);
        assertTrue(changed);

        // false case: no tag starts with prefix or already aligned
        RangerServiceDef.RangerAccessTypeDef svc2 = new RangerServiceDef.RangerAccessTypeDef();
        svc2.setItemId(20L);
        svc2.setName("create");
        svc2.setImpliedGrants(new HashSet<>());
        List<RangerServiceDef.RangerAccessTypeDef> svcDefs2 = new ArrayList<>();
        svcDefs2.add(svc2);

        RangerServiceDef.RangerAccessTypeDef tag2 = new RangerServiceDef.RangerAccessTypeDef();
        tag2.setItemId(6006L + 20L);
        tag2.setName("atlas:create");
        tag2.setImpliedGrants(new HashSet<>());
        List<RangerServiceDef.RangerAccessTypeDef> tagDefs2 = new ArrayList<>();
        tagDefs2.add(tag2);

        boolean changed2 = (boolean) m.invoke(patch, svcDefs2, tagDefs2, 6006L, "noMatch:", "noMatch:");
        assertFalse(changed2);
    }

    @Test
    public void testUpdateAtlasServiceDef_serviceDefMissing_andNoOlderVersion() throws Exception {
        PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchForAtlasServiceDefUpdate_J10013.class.getDeclaredMethod("updateAtlasServiceDef");
        m.setAccessible(true);

        // service-def missing: should return without error
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(null);
        Assertions.assertDoesNotThrow(() -> {
            try {
                m.invoke(patch);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });

        // present but older version not found: returns without further actions
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(7L);
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(sdef);
        XXResourceDefDao rdefDao = Mockito.mock(XXResourceDefDao.class);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(rdefDao);
        XXResourceDef badResource = new XXResourceDef();
        badResource.setName("bad");
        Mockito.when(rdefDao.findByServiceDefId(7L)).thenReturn(Collections.singletonList(badResource));
        Assertions.assertDoesNotThrow(() -> {
            try {
                m.invoke(patch);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testUpdateAtlasServiceDef_successFlow_updatesTagAndServices() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getTagServiceDefId()).thenReturn(100L);

            PatchForAtlasServiceDefUpdate_J10013 patch = new PatchForAtlasServiceDefUpdate_J10013();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            XXServiceDao serviceDao = Mockito.mock(XXServiceDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            Mockito.when(daoMgr.getXXService()).thenReturn(serviceDao);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);

            // existing atlas service-def
            XXServiceDef sdef = new XXServiceDef();
            sdef.setId(5L);
            sdef.setName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME);
            Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME)).thenReturn(sdef);
            Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME + ".v1"))
                    .thenReturn(null);

            // older version present: resources and access types match expected sets
            XXResourceDefDao rdefDao = Mockito.mock(XXResourceDefDao.class);
            XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
            Mockito.when(daoMgr.getXXResourceDef()).thenReturn(rdefDao);
            Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
            List<XXResourceDef> resDefs = Arrays.asList(namedRes("entity"), namedRes("type"), namedRes("operation"),
                    namedRes("taxonomy"), namedRes("term"));
            Mockito.when(rdefDao.findByServiceDefId(5L)).thenReturn(resDefs);
            List<XXAccessTypeDef> accDefs = Arrays.asList(namedAcc("read"), namedAcc("create"), namedAcc("update"),
                    namedAcc("delete"), namedAcc("all"));
            Mockito.when(atDao.findByServiceDefId(5L)).thenReturn(accDefs);

            // atlas and tag RangerServiceDef access types to trigger update
            RangerServiceDef atlasDef = new RangerServiceDef();
            RangerServiceDef.RangerAccessTypeDef svc = new RangerServiceDef.RangerAccessTypeDef();
            svc.setItemId(10L);
            svc.setName("read");
            atlasDef.setAccessTypes(new ArrayList<>(Collections.singletonList(svc)));
            Mockito.when(svcDBStore.getServiceDefByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(atlasDef);

            RangerServiceDef tagDef = new RangerServiceDef();
            RangerServiceDef.RangerAccessTypeDef tag = new RangerServiceDef.RangerAccessTypeDef();
            tag.setItemId(5L * (1000 + 1) + 10L);
            tag.setName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME
                    + AbstractServiceStore.COMPONENT_ACCESSTYPE_SEPARATOR + "old");
            tagDef.setAccessTypes(new ArrayList<>(Collections.singletonList(tag)));
            Mockito.when(svcDBStore.getServiceDef(100L)).thenReturn(tagDef);

            // services under atlas def to be renamed
            XXService xs = new XXService();
            xs.setId(21L);
            xs.setName("atlas_svc");
            Mockito.when(serviceDao.findByServiceDefId(5L)).thenReturn(Collections.singletonList(xs));
            Mockito.when(serviceDao.findIdByName("atlas_svc.v1")).thenReturn(null);

            Method m = PatchForAtlasServiceDefUpdate_J10013.class.getDeclaredMethod("updateAtlasServiceDef");
            m.setAccessible(true);
            Assertions.assertDoesNotThrow(() -> {
                try {
                    m.invoke(patch);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });

            Mockito.verify(sdefDao, Mockito.times(1)).update(Mockito.any(XXServiceDef.class));
            Mockito.verify(serviceDao, Mockito.times(1)).update(Mockito.any(XXService.class));
            Mockito.verify(svcDBStore, Mockito.times(1)).updateServiceDef(Mockito.eq(tagDef));
        }
    }

    private XXResourceDef namedRes(String name) {
        XXResourceDef r = new XXResourceDef();
        r.setName(name);
        return r;
    }

    private XXAccessTypeDef namedAcc(String name) {
        XXAccessTypeDef a = new XXAccessTypeDef();
        a.setName(name);
        return a;
    }
}
