/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.common.JSONUtil;
import org.apache.ranger.common.StringUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItem;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyItemAccess;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.util.CLIUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoad_NoPolicies() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            embeddedAtlas.setId(11L);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(embeddedAtlas);

            RangerServiceDef embeddedTag = new RangerServiceDef();
            embeddedTag.setId(22L);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_TAG_NAME))
                    .thenReturn(embeddedTag);

            PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();

            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            JSONUtil jsonUtil = Mockito.mock(JSONUtil.class);
            StringUtil stringUtil = Mockito.mock(StringUtil.class);

            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            XXServiceDef xxServiceDef = new XXServiceDef();
            xxServiceDef.setDefOptions(null);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(xxServiceDef);

            Mockito.when(jsonUtil.readMapToString(Mockito.anyMap())).thenReturn("{}");

            XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
            Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
            Mockito.when(xxPolicyDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());

            XXAccessTypeDefDao xxAccessTypeDefDao = Mockito.mock(XXAccessTypeDefDao.class);
            Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(xxAccessTypeDefDao);
            Mockito.when(xxAccessTypeDefDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());
            // Mockito.doNothing().when(svcStore).deleteXXAccessTypeDef(Mockito.any());

            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcStore", svcStore);
            setIfPresent(patch, "jsonUtil", jsonUtil);
            setIfPresent(patch, "stringUtil", stringUtil);

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testExecLoad_RemoveAtlasAccessesFromTagPolicies() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            embeddedAtlas.setId(11L);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(embeddedAtlas);

            RangerServiceDef embeddedTag = new RangerServiceDef();
            embeddedTag.setId(22L);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_TAG_NAME))
                    .thenReturn(embeddedTag);

            PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();

            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            JSONUtil jsonUtil = Mockito.mock(JSONUtil.class);
            StringUtil stringUtil = Mockito.mock(StringUtil.class);

            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            XXServiceDef xxServiceDef = new XXServiceDef();
            xxServiceDef.setDefOptions(null);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(xxServiceDef);
            Mockito.when(jsonUtil.readMapToString(Mockito.anyMap())).thenReturn("{}");

            XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
            Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
            XXPolicy xxPolicy = new XXPolicy();
            xxPolicy.setId(999L);
            Mockito.when(xxPolicyDao.findByServiceDefId(Mockito.anyLong()))
                    .thenReturn(Collections.singletonList(xxPolicy));

            XXAccessTypeDefDao xxAccessTypeDefDao = Mockito.mock(XXAccessTypeDefDao.class);
            Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(xxAccessTypeDefDao);
            Mockito.when(xxAccessTypeDefDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());
            // Mockito.doNothing().when(svcStore).deleteXXAccessTypeDef(Mockito.any());

            // Prepare a RangerPolicy with atlas:* access that should be removed
            RangerPolicy rp = new RangerPolicy();
            rp.setId(999L);
            List<RangerPolicyItem> items = new ArrayList<>();
            RangerPolicyItem item = new RangerPolicyItem();
            List<RangerPolicyItemAccess> accesses = new ArrayList<>();
            RangerPolicyItemAccess acc = new RangerPolicyItemAccess();
            acc.setType("atlas:view");
            accesses.add(acc);
            item.setAccesses(accesses);
            items.add(item);
            rp.setPolicyItems(items);

            Mockito.when(svcStore.getPolicy(Mockito.eq(999L))).thenReturn(rp);
            Mockito.when(svcStore.updatePolicy(Mockito.any(RangerPolicy.class))).thenReturn(rp);

            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcStore", svcStore);
            setIfPresent(patch, "jsonUtil", jsonUtil);
            setIfPresent(patch, "stringUtil", stringUtil);

            patch.execLoad();
        }
    }

    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();
        Assertions.assertDoesNotThrow(() -> patch.init());
    }

    @Test
    public void testMain_Success_ExitZero() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063.class))
                    .thenReturn(patch);
            CLIUtil cli = Mockito.mock(CLIUtil.class);
            cliMock.when(() -> CLIUtil.getBean(CLIUtil.class)).thenReturn(cli);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertNotNull(se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_Failure_ExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063.class))
                    .thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testJsonStringToMap_Various() throws Exception {
        PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();
        setIfPresent(patch, "jsonUtil", Mockito.mock(JSONUtil.class));

        Mockito.when(patch.jsonUtil.jsonToMap("{\"k\":\"v\"}")).thenReturn(new HashMap<String, String>() {
            {
                put("k", "v");
            }
        });
        Method m = PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063.class.getDeclaredMethod("jsonStringToMap",
                String.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        Map<String, String> parsed = (Map<String, String>) m.invoke(patch, "{\"k\":\"v\"}");
        Assertions.assertEquals("v", parsed.get("k"));

        Mockito.when(patch.jsonUtil.jsonToMap("a=b;c=d")).thenThrow(new RuntimeException("bad"));
        @SuppressWarnings("unchecked")
        Map<String, String> fallback = (Map<String, String>) m.invoke(patch, "a=b;c=d");
        Assertions.assertEquals("b", fallback.get("a"));
        Assertions.assertEquals("d", fallback.get("c"));

        @SuppressWarnings("unchecked")
        Map<String, String> empty = (Map<String, String>) m.invoke(patch, "");
        Assertions.assertNull(empty);
    }

    @Test
    public void testMapToJsonString_SuccessAndNull() throws Exception {
        PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();
        setIfPresent(patch, "jsonUtil", Mockito.mock(JSONUtil.class));

        Mockito.when(patch.jsonUtil.readMapToString(Mockito.anyMap())).thenReturn("{}");
        Method m = PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063.class.getDeclaredMethod("mapToJsonString",
                Map.class);
        m.setAccessible(true);
        String val = (String) m.invoke(patch, new HashMap<String, String>() {
            {
                put("a", "b");
            }
        });
        Assertions.assertEquals("{}", val);

        String nullVal = (String) m.invoke(patch, (Object) null);
        Assertions.assertNull(nullVal);
    }

    @Test
    public void testExecLoad_UpdateAtlasServiceDefReturnsFalse_TagNotProcessed() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(null);

            PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcStore", svcStore);

            Assertions.assertDoesNotThrow(() -> patch.execLoad());
            Mockito.verify(svcStore, Mockito.never()).getPolicy(Mockito.anyLong());
        }
    }

    @Test
    public void testDisableAtlasAccessForTagPolicies_EmbeddedTagMissing() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            embeddedAtlas.setId(1L);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(embeddedAtlas);
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_TAG_NAME))
                    .thenReturn(null);

            PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063 patch = new PatchForUpdatingAtlasSvcDefAndTagPolicies_J10063();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            XXServiceDef xxServiceDef = new XXServiceDef();
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(xxServiceDef);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcStore", svcStore);
            setIfPresent(patch, "jsonUtil", Mockito.mock(JSONUtil.class));
            setIfPresent(patch, "stringUtil", Mockito.mock(StringUtil.class));

            Assertions.assertDoesNotThrow(() -> patch.execLoad());
        }
    }
}
