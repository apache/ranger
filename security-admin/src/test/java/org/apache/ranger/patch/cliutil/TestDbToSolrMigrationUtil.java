/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch.cliutil;

import org.apache.ranger.common.PropertiesUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessAuditDao;
import org.apache.ranger.entity.XXAccessAudit;
import org.apache.ranger.entity.XXAccessAuditV4;
import org.apache.ranger.entity.XXAccessAuditV5;
import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.impl.HttpSolrClient;
import org.apache.solr.client.solrj.response.UpdateResponse;
import org.apache.solr.common.SolrInputDocument;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.Permission;
import java.util.Arrays;
import java.util.Collections;

/**
 * @generated by Cursor
 * @description <Unit Test for DbToSolrMigrationUtil class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestDbToSolrMigrationUtil {
    @Mock
    RangerDaoManager daoManager;
    @Mock
    XXAccessAuditDao xxAccessAuditDao;
    @Mock
    SolrClient solrClient;
    @Mock
    UpdateResponse updateResponse;

    @InjectMocks
    private DbToSolrMigrationUtil util = new DbToSolrMigrationUtil();

    @Test
    public void testSend2solr_v4AndV5AndV6() throws Throwable {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(updateResponse.getStatus()).thenReturn(0);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);

        XXAccessAuditV4 v4 = new XXAccessAuditV4();
        v4.setId(1L);
        util.send2solr(v4);

        XXAccessAuditV5 v5 = new XXAccessAuditV5();
        v5.setId(2L);
        util.send2solr(v5);

        XXAccessAudit v6 = new XXAccessAudit();
        v6.setId(3L);
        util.send2solr(v6);

        Mockito.verify(solrClient, Mockito.times(3)).add(Mockito.any(SolrInputDocument.class));
    }

    @Test
    public void testPrintStats() {
        util.printStats();
    }

    @Test
    public void testInit_noProperties_noThrow() throws Exception {
        util.init();
    }

    @Test
    public void testExecLoad_earlyReturn() {
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(0L);

        util.execLoad();

        Mockito.verify(xxAccessAuditDao).getMaxIdOfXXAccessAudit();
    }

    @Test
    public void testRegisterSolrClientJAAS_viaReflection() throws Exception {
        Method m = DbToSolrMigrationUtil.class.getDeclaredMethod("registerSolrClientJAAS");
        m.setAccessible(true);
        m.invoke(util);
    }

    @Test
    public void testMain_invokesExit() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                DbToSolrMigrationUtil.main(new String[] {});
            } catch (SecurityException ignored) {
            }
        } catch (Exception ignored) {
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testWriteAndReadMigrationStatusFile_viaReflection() throws Exception {
        Path tmp = Files.createTempFile("ranger-mig-", ".txt");
        Method write = DbToSolrMigrationUtil.class.getDeclaredMethod("writeMigrationStatusFile", Long.class,
                String.class);
        write.setAccessible(true);
        write.invoke(util, 123L, tmp.toString());

        Method read = DbToSolrMigrationUtil.class.getDeclaredMethod("readMigrationStatusFile", String.class);
        read.setAccessible(true);
        Object val = read.invoke(util, tmp.toString());

        Assertions.assertEquals(123L, ((Long) val).longValue());
    }

    @Test
    public void testMigrateAuditDbLogsToSolr_earlyReturn() {
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(0L);

        util.migrateAuditDbLogsToSolr();

        Mockito.verify(xxAccessAuditDao).getMaxIdOfXXAccessAudit();
    }

    @Test
    public void testCreateSolrClient_withZkHosts_attemptsCloudPath() throws Exception {
        try {
            PropertiesUtil.getPropertiesMap().put(DbToSolrMigrationUtil.SOLR_ZK_HOSTS, "host1:2181,host2:2181");
            PropertiesUtil.getPropertiesMap().put(DbToSolrMigrationUtil.SOLR_COLLECTION_NAME, "ranger_audits");

            Method m = DbToSolrMigrationUtil.class.getDeclaredMethod("createSolrClient");
            m.setAccessible(true);
            Assertions.assertThrows(Exception.class, () -> {
                try {
                    m.invoke(util);
                } catch (Throwable t) {
                    if (t instanceof Exception) {
                        throw (Exception) t;
                    }
                    throw new RuntimeException(t);
                }
            });
        } finally {
            PropertiesUtil.getPropertiesMap().remove(DbToSolrMigrationUtil.SOLR_ZK_HOSTS);
            PropertiesUtil.getPropertiesMap().remove(DbToSolrMigrationUtil.SOLR_COLLECTION_NAME);
        }
    }

    @Test
    public void testCreateSolrClient_withUrl_returnsHttp() throws Exception {
        try {
            PropertiesUtil.getPropertiesMap().put(DbToSolrMigrationUtil.SOLR_URLS_PROP, "http://localhost:8983/solr");

            Method m = DbToSolrMigrationUtil.class.getDeclaredMethod("createSolrClient");
            m.setAccessible(true);
            Object client = m.invoke(util);

            Assertions.assertTrue(client instanceof HttpSolrClient);
        } finally {
            PropertiesUtil.getPropertiesMap().remove(DbToSolrMigrationUtil.SOLR_URLS_PROP);
        }
    }

    @Test
    public void testReadMigrationStatusFile_nonexistent_returnsZero() throws Exception {
        Method read = DbToSolrMigrationUtil.class.getDeclaredMethod("readMigrationStatusFile", String.class);
        read.setAccessible(true);
        Object val = read.invoke(util, Paths.get("nonexistent-file-" + System.nanoTime()).toString());
        Assertions.assertEquals(0L, ((Long) val).longValue());
    }

    @Test
    public void testReadMigrationStatusFile_invalidContent_returnsZero() throws Exception {
        Path tmp = Files.createTempFile("ranger-mig-invalid-", ".txt");
        Files.write(tmp, Arrays.asList("abc"));
        Method read = DbToSolrMigrationUtil.class.getDeclaredMethod("readMigrationStatusFile", String.class);
        read.setAccessible(true);
        Object val = read.invoke(util, tmp.toString());
        Assertions.assertEquals(0L, ((Long) val).longValue());
    }

    @Test
    public void testSend2solr_v4_nonzeroStatus_throws() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(updateResponse.getStatus()).thenReturn(1);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);
        XXAccessAuditV4 v4 = new XXAccessAuditV4();
        v4.setId(11L);
        Assertions.assertThrows(Exception.class, () -> {
            try {
                util.send2solr(v4);
            } catch (Throwable t) {
                if (t instanceof Exception) {
                    throw (Exception) t;
                }
                throw new RuntimeException(t);
            }
        });
    }

    @Test
    public void testSend2solr_v5_nonzeroStatus_throws() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(updateResponse.getStatus()).thenReturn(1);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);
        XXAccessAuditV5 v5 = new XXAccessAuditV5();
        v5.setId(12L);
        Assertions.assertThrows(Exception.class, () -> {
            try {
                util.send2solr(v5);
            } catch (Throwable t) {
                if (t instanceof Exception) {
                    throw (Exception) t;
                }
                throw new RuntimeException(t);
            }
        });
    }

    @Test
    public void testSend2solr_v6_nonzeroStatus_throws() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(updateResponse.getStatus()).thenReturn(1);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);
        XXAccessAudit v6 = new XXAccessAudit();
        v6.setId(13L);
        Assertions.assertThrows(Exception.class, () -> {
            try {
                util.send2solr(v6);
            } catch (Throwable t) {
                if (t instanceof Exception) {
                    throw (Exception) t;
                }
                throw new RuntimeException(t);
            }
        });
    }

    @Test
    public void testMigrateAuditDbLogsToSolr_v4_success_closesClient() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(1L);
        Mockito.when(xxAccessAuditDao.getColumnNames(Mockito.anyString())).thenReturn(Collections.emptyList());
        XXAccessAuditV4 rec = new XXAccessAuditV4();
        rec.setId(1L);
        Mockito.when(xxAccessAuditDao.getByIdRangeV4(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(Collections.singletonList(rec));
        Mockito.when(updateResponse.getStatus()).thenReturn(0);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);

        util.migrateAuditDbLogsToSolr();

        Mockito.verify(solrClient, Mockito.times(1)).add(Mockito.any(SolrInputDocument.class));
        Mockito.verify(solrClient, Mockito.times(1)).close();
        Assertions.assertNull(DbToSolrMigrationUtil.solrClient);
        Files.deleteIfExists(Paths.get("migration_check_file.txt"));
    }

    @Test
    public void testMigrateAuditDbLogsToSolr_v4_failure_doesNotCloseClient() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(1L);
        Mockito.when(xxAccessAuditDao.getColumnNames(Mockito.anyString())).thenReturn(Collections.emptyList());
        XXAccessAuditV4 rec = new XXAccessAuditV4();
        rec.setId(1L);
        Mockito.when(xxAccessAuditDao.getByIdRangeV4(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(Collections.singletonList(rec));
        Mockito.when(updateResponse.getStatus()).thenReturn(1);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);

        util.migrateAuditDbLogsToSolr();

        Mockito.verify(solrClient, Mockito.times(1)).add(Mockito.any(SolrInputDocument.class));
        Mockito.verify(solrClient, Mockito.never()).close();
        Assertions.assertNotNull(DbToSolrMigrationUtil.solrClient);
        Files.deleteIfExists(Paths.get("migration_check_file.txt"));
    }

    @Test
    public void testMigrateAuditDbLogsToSolr_v5_success_closesClient() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(1L);
        Mockito.when(xxAccessAuditDao.getColumnNames(Mockito.anyString()))
                .thenReturn(Arrays.asList("seq_num", "event_count", "event_dur_ms"));

        XXAccessAuditV5 rec = new XXAccessAuditV5();
        rec.setId(1L);
        Mockito.when(xxAccessAuditDao.getByIdRangeV5(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(Collections.singletonList(rec));
        Mockito.when(updateResponse.getStatus()).thenReturn(0);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);

        util.migrateAuditDbLogsToSolr();

        Mockito.verify(solrClient, Mockito.times(1)).add(Mockito.any(SolrInputDocument.class));
        Mockito.verify(solrClient, Mockito.times(1)).close();
        Assertions.assertNull(DbToSolrMigrationUtil.solrClient);
        Files.deleteIfExists(Paths.get("migration_check_file.txt"));
    }

    @Test
    public void testMigrateAuditDbLogsToSolr_v6_success_closesClient() throws Exception {
        DbToSolrMigrationUtil.solrClient = solrClient;
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(1L);
        Mockito.when(xxAccessAuditDao.getColumnNames(Mockito.anyString())).thenReturn(Arrays.asList("tags"));

        XXAccessAudit rec = new XXAccessAudit();
        rec.setId(1L);
        Mockito.when(xxAccessAuditDao.getByIdRangeV6(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(Collections.singletonList(rec));
        Mockito.when(updateResponse.getStatus()).thenReturn(0);
        Mockito.when(solrClient.add(Mockito.any(SolrInputDocument.class))).thenReturn(updateResponse);

        util.migrateAuditDbLogsToSolr();

        Mockito.verify(solrClient, Mockito.times(1)).add(Mockito.any(SolrInputDocument.class));
        Mockito.verify(solrClient, Mockito.times(1)).close();
        Assertions.assertNull(DbToSolrMigrationUtil.solrClient);
        Files.deleteIfExists(Paths.get("migration_check_file.txt"));
    }

    @Test
    public void testMigrateAuditDbLogsToSolr_alreadyMigrated_returnsEarly() throws Exception {
        Mockito.when(daoManager.getXXAccessAudit()).thenReturn(xxAccessAuditDao);
        Mockito.when(xxAccessAuditDao.getMaxIdOfXXAccessAudit()).thenReturn(5L);

        // Simulate already migrated status
        Path tmp = Paths.get("migration_check_file.txt");
        Files.write(tmp, Collections.singletonList("5"));

        util.migrateAuditDbLogsToSolr();

        // No interactions with solrClient expected
        Mockito.verifyNoInteractions(solrClient);
        Files.deleteIfExists(tmp);
    }
}
