/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.common.RangerValidatorFactory;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefValidator;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.util.CLIUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForAtlasAdminAudits_J10043 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForAtlasAdminAudits_J10043 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            embeddedAtlas.setResources(Collections.emptyList());
            embeddedAtlas.setAccessTypes(Collections.emptyList());
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(embeddedAtlas);

            PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerValidatorFactory validatorFactory = Mockito.mock(RangerValidatorFactory.class);
            RangerServiceDefValidator validator = Mockito.mock(RangerServiceDefValidator.class);

            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(new XXServiceDef());

            RangerServiceDef dbAtlas = new RangerServiceDef();
            Mockito.when(
                    svcDBStore.getServiceDefByName(Mockito.eq(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME)))
                    .thenReturn(dbAtlas);
            Mockito.when(validatorFactory.getServiceDefValidator(Mockito.any(ServiceDBStore.class)))
                    .thenReturn(validator);
            Mockito.when(svcDBStore.updateServiceDef(Mockito.any(RangerServiceDef.class)))
                    .thenAnswer(inv -> inv.getArgument(0));

            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "validatorFactory", validatorFactory);
            setIfPresent(patch, "svcStore", svcDBStore);

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
        Assertions.assertDoesNotThrow(() -> patch.init());
    }

    @Test
    public void testMain_Success_ExitZero() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchForAtlasAdminAudits_J10043.class)).thenReturn(patch);
            CLIUtil cli = Mockito.mock(CLIUtil.class);
            cliMock.when(() -> CLIUtil.getBean(CLIUtil.class)).thenReturn(cli);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForAtlasAdminAudits_J10043.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertNotNull(se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_Failure_ExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchForAtlasAdminAudits_J10043.class)).thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForAtlasAdminAudits_J10043.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testAddAdminAuditsPermissionInServiceDef_ServiceDefNotFound_ReturnsEarly() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            embeddedAtlas.setResources(new ArrayList<>());
            embeddedAtlas.setAccessTypes(new ArrayList<>());
            Mockito.when(util.getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME)).thenReturn(embeddedAtlas);

            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);

            PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", Mockito.mock(ServiceDBStore.class));
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));
            setIfPresent(patch, "svcStore", Mockito.mock(ServiceDBStore.class));

            Assertions.assertDoesNotThrow(() -> patch.execLoad());
        }
    }

    @Test
    public void testExecLoad_UpdateReturnsNull_ThrowsRuntime() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            // Embedded Atlas with required resource and access type
            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            RangerServiceDef.RangerResourceDef res = new RangerServiceDef.RangerResourceDef();
            res.setName("atlas-service");
            embeddedAtlas.setResources(new ArrayList<>(Collections.singletonList(res)));
            embeddedAtlas.setAccessTypes(new ArrayList<>(Collections.singletonList(new RangerServiceDef.RangerAccessTypeDef("admin-audits"))));
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance().getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME)).thenReturn(embeddedAtlas);

            PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(new XXServiceDef());
            setIfPresent(patch, "daoMgr", daoMgr);

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerServiceDef dbAtlas = new RangerServiceDef();
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(dbAtlas);
            Mockito.when(svcDBStore.updateServiceDef(Mockito.any())).thenReturn(null);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "svcStore", svcDBStore);

            RangerValidatorFactory validatorFactory = Mockito.mock(RangerValidatorFactory.class);
            RangerServiceDefValidator validator = Mockito.mock(RangerServiceDefValidator.class);
            Mockito.when(validatorFactory.getServiceDefValidator(Mockito.any(ServiceDBStore.class))).thenReturn(validator);
            setIfPresent(patch, "validatorFactory", validatorFactory);

            Assertions.assertThrows(RuntimeException.class, patch::execLoad);
        }
    }

    @Test
    public void testPrivate_Checkers() throws Exception {
        PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
        Method cr = PatchForAtlasAdminAudits_J10043.class.getDeclaredMethod("checkResourcePresent", List.class);
        Method ca = PatchForAtlasAdminAudits_J10043.class.getDeclaredMethod("checkAccessPresent", List.class);
        cr.setAccessible(true);
        ca.setAccessible(true);

        RangerServiceDef.RangerResourceDef r = new RangerServiceDef.RangerResourceDef();
        r.setName("atlas-service");
        List<RangerServiceDef.RangerResourceDef> rList = new ArrayList<>();
        rList.add(r);
        Assertions.assertTrue((Boolean) cr.invoke(patch, rList));

        RangerServiceDef.RangerAccessTypeDef a = new RangerServiceDef.RangerAccessTypeDef("admin-audits");
        List<RangerServiceDef.RangerAccessTypeDef> aList = new ArrayList<>();
        aList.add(a);
        Assertions.assertTrue((Boolean) ca.invoke(patch, aList));
    }

    @Test
    public void testPrivate_Checkers_FalseBranches() throws Exception {
        PatchForAtlasAdminAudits_J10043 patch = new PatchForAtlasAdminAudits_J10043();
        Method cr = PatchForAtlasAdminAudits_J10043.class.getDeclaredMethod("checkResourcePresent", List.class);
        Method ca = PatchForAtlasAdminAudits_J10043.class.getDeclaredMethod("checkAccessPresent", List.class);
        cr.setAccessible(true);
        ca.setAccessible(true);

        // Resource not present
        RangerServiceDef.RangerResourceDef r = new RangerServiceDef.RangerResourceDef();
        r.setName("not-atlas");
        List<RangerServiceDef.RangerResourceDef> rList = new ArrayList<>();
        rList.add(r);
        Assertions.assertFalse((Boolean) cr.invoke(patch, rList));

        // Access not present
        RangerServiceDef.RangerAccessTypeDef a = new RangerServiceDef.RangerAccessTypeDef("not-admin-audits");
        List<RangerServiceDef.RangerAccessTypeDef> aList = new ArrayList<>();
        aList.add(a);
        Assertions.assertFalse((Boolean) ca.invoke(patch, aList));
    }
}
