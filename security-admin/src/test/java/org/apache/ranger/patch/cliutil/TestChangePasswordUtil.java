/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch.cliutil;

import org.apache.ranger.authorization.hadoop.config.RangerAdminConfig;
import org.apache.ranger.biz.UserMgr;
import org.apache.ranger.common.MessageEnums;
import org.apache.ranger.common.RESTErrorUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.entity.XXPortalUser;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;

/**
 * @generated by Cursor
 * @description <Unit Test for ChangePasswordUtil class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestChangePasswordUtil {
    @Mock
    RangerDaoManager daoMgr;
    @Mock
    UserMgr userMgr;
    @Mock
    RESTErrorUtil restErrorUtil;
    @Mock
    XXPortalUserDao xXPortalUserDao;

    @InjectMocks
    private ChangePasswordUtil util = new ChangePasswordUtil();

    @Test
    public void testPrintStats() {
        util.printStats();
    }

    @Test
    public void testInit() throws Exception {
        util.init();
    }

    @Test
    public void testExecLoad_nonFips_adminPath() throws Exception {
        ChangePasswordUtil.userLoginId = "admin";
        ChangePasswordUtil.currentPassword = "Admin#123";
        ChangePasswordUtil.newPassword = "Admin#234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;
        ChangePasswordUtil.userPwdArgs = new String[] {"admin", "Admin#123", "Admin#234"};

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("admin");
        user.setPassword("enc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("admin")).thenReturn(user);
        Mockito.when(userMgr.encrypt("admin", "Admin#123")).thenReturn("enc");

        util.execLoad();
        Mockito.verify(userMgr).updatePasswordInSHA256("admin", "Admin#234", true);
    }

    @Test
    public void testExecLoad_defaultPasswordBranch_md5() throws Exception {
        ChangePasswordUtil.userLoginId = "admin";
        ChangePasswordUtil.currentPassword = "Admin#123";
        ChangePasswordUtil.newPassword = "Admin#234";
        ChangePasswordUtil.defaultPwdChangeRequest = true;
        ChangePasswordUtil.userPwdArgs = new String[] {"admin", "Admin#123", "Admin#234", "-default"};

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("admin");
        user.setPassword("md5");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("admin")).thenReturn(user);
        Mockito.when(userMgr.encrypt("admin", "Admin#123")).thenReturn("not-md5");
        Mockito.when(userMgr.encryptWithOlderAlgo("admin", "Admin#123")).thenReturn("md5");

        util.execLoad();
        Mockito.verify(userMgr).updatePasswordInSHA256("admin", "Admin#234", true);
    }

    @Test
    public void testMain_invokesExit() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"admin", "Admin#123", "Admin#234"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidatePassword_blank_throws() {
        Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), Mockito.any(MessageEnums.class),
                Mockito.isNull(), Mockito.anyString(), Mockito.isNull()))
                .thenThrow(new RuntimeException("bad password"));

        try {
            Method m = ChangePasswordUtil.class.getDeclaredMethod("validatePassword", String.class);
            m.setAccessible(true);
            m.invoke(util, new Object[] {null});
        } catch (Exception ignored) {
        }
    }

    @Test
    public void testValidatePassword_invalidPattern_throws() throws Exception {
        Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), Mockito.any(MessageEnums.class),
                Mockito.isNull(), Mockito.anyString(), Mockito.isNull()))
                .thenThrow(new RuntimeException("bad password"));

        try {
            Method m = ChangePasswordUtil.class.getDeclaredMethod("validatePassword", String.class);
            m.setAccessible(true);
            m.invoke(util, "short");
        } catch (Exception ignored) {
        }
    }

    @Test
    public void testUpdateMultiplePasswords_validPath() throws Exception {
        ChangePasswordUtil.userPwdArgs = new String[] {"bob", "Bob#1234", "Bob#2345", "carol", "Carol#1234", "Carol#2345"};
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser bob = new XXPortalUser();
        bob.setLoginId("bob");
        bob.setPassword("encB");
        XXPortalUser carol = new XXPortalUser();
        carol.setLoginId("carol");
        carol.setPassword("encC");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("bob")).thenReturn(bob);
        Mockito.when(xXPortalUserDao.findByLoginId("carol")).thenReturn(carol);
        Mockito.when(userMgr.encrypt("bob", "Bob#1234")).thenReturn("encB");
        Mockito.when(userMgr.encrypt("carol", "Carol#1234")).thenReturn("encC");

        util.updateMultiplePasswords();

        Mockito.verify(userMgr).updatePasswordInSHA256("bob", "Bob#2345", true);
        Mockito.verify(userMgr).updatePasswordInSHA256("carol", "Carol#2345", true);
    }

    @Test
    public void testValidatePassword_valid_ok() throws Exception {
        Method m = ChangePasswordUtil.class.getDeclaredMethod("validatePassword", String.class);
        m.setAccessible(true);
        m.invoke(util, "ValidPass1");
    }

    @Test
    public void testUpdateAdminPassword_userNotFound_exits() {
        ChangePasswordUtil.userLoginId = "ghost";
        ChangePasswordUtil.currentPassword = "Some#123";
        ChangePasswordUtil.newPassword = "Some#234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("ghost")).thenReturn(null);

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                util.updateAdminPassword();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testUpdateAdminPassword_encryptMismatch_nonDefault_exits() {
        ChangePasswordUtil.userLoginId = "alice";
        ChangePasswordUtil.currentPassword = "Alice#123";
        ChangePasswordUtil.newPassword = "Alice#234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("alice");
        user.setPassword("encDb");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("alice")).thenReturn(user);
        Mockito.when(userMgr.encrypt("alice", "Alice#123")).thenReturn("differentEnc");

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                util.updateAdminPassword();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testUpdateMultiplePasswords_defaultMismatch_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"bob", "Bob#1234", "Bob#2345", "-default"};
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser bob = new XXPortalUser();
        bob.setLoginId("bob");
        bob.setPassword("encB");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("bob")).thenReturn(bob);
        Mockito.when(userMgr.encrypt("bob", "Bob#1234")).thenReturn("encOther");
        Mockito.lenient().when(userMgr.encryptWithOlderAlgo("bob", "Bob#1234")).thenReturn("notEncB");

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                util.updateMultiplePasswords();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_incorrectArgs_exits() {
        Integer status = runAndCaptureExitCode(() -> ChangePasswordUtil.main(new String[] {"onlyTwo", "args"}));
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateAdminPassword_nonFips_valid_updates() throws Exception {
        ChangePasswordUtil.userLoginId = "dave";
        ChangePasswordUtil.currentPassword = "Dave#123";
        ChangePasswordUtil.newPassword = "Dave#234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("dave");
        user.setPassword("dbEnc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("dave")).thenReturn(user);
        Mockito.when(userMgr.encrypt("dave", "Dave#123")).thenReturn("dbEnc");

        util.updateAdminPassword();

        Mockito.verify(userMgr).updatePasswordInSHA256("dave", "Dave#234", true);
    }

    @Test
    public void testUpdateAdminPassword_fips_default_mismatch_exits() {
        ChangePasswordUtil.userLoginId = "erin";
        ChangePasswordUtil.currentPassword = "Erin#123";
        ChangePasswordUtil.newPassword = "Erin#234";
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("erin");
        user.setPassword("dbEnc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("erin")).thenReturn(user);

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                util.updateAdminPassword();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testUpdateMultiplePasswords_invalidArgs_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"", "c", "n"};

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                util.updateMultiplePasswords();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_missingNewPassword_exits() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"u", "p", ""});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_withDefaultFlag_runs() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"u", "p1", "p2", "-default"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_moreThanFourArgs_withDefaultFlag_runs() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"u1", "p1", "n1", "u2", "p2", "n2", "-default"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testUpdateAdminPassword_fips_default_matches_updates() throws Exception {
        ChangePasswordUtil.userLoginId = "fips";
        ChangePasswordUtil.currentPassword = "Old#1234";
        ChangePasswordUtil.newPassword = "New#1234";
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fips");
        user.setPassword("md5enc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fips")).thenReturn(user);
        Mockito.when(userMgr.encrypt("fips", "Old#1234")).thenReturn("otherEnc");
        // Simulate FIPS enabled path via isPasswordValid not used in default path
        Mockito.when(userMgr.encryptWithOlderAlgo("fips", "Old#1234")).thenReturn("md5enc");

        util.updateAdminPassword();

        Mockito.verify(userMgr).updatePasswordInSHA256("fips", "New#1234", true);
    }

    @Test
    public void testMain_blankNewPassword_exits() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"u", "p", ""});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_blankLogin_exits() {
        Integer status = runAndCaptureExitCode(() -> ChangePasswordUtil.main(new String[] {"", "p", "n"}));
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testMain_blankCurrent_exits() {
        Integer status = runAndCaptureExitCode(() -> ChangePasswordUtil.main(new String[] {"u", "", "n"}));
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateMultiplePasswords_skipDefaultToken_noExit() {
        ChangePasswordUtil.userPwdArgs = new String[] {"-default", "ignored1", "ignored2"};
        util.updateMultiplePasswords();
    }

    @Test
    public void testUpdateMultiplePasswords_emptyCurrent_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"u", "", "n"};
        Integer status = runAndCaptureExitCode(() -> util.updateMultiplePasswords());
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testMain_fourArgs_nonDefault_runs() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"u", "p1", "p2", "someFlag"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_moreThanFourArgs_withoutDefault_runs() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                ChangePasswordUtil.main(new String[] {"u1", "p1", "n1", "u2", "p2", "n2"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testUpdateMultiplePasswords_emptyNew_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"u", "c", ""};
        Integer status = runAndCaptureExitCode(() -> util.updateMultiplePasswords());
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateMultiplePasswords_userNotFound_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"nouser", "c", "n"};
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("nouser")).thenReturn(null);
        Integer status = runAndCaptureExitCode(() -> util.updateMultiplePasswords());
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateMultiplePasswords_mismatchNonDefault_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"user", "cur", "new"};
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("user");
        user.setPassword("dbEnc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("user")).thenReturn(user);
        Mockito.when(userMgr.encrypt("user", "cur")).thenReturn("notDbEnc");

        Integer status = runAndCaptureExitCode(() -> util.updateMultiplePasswords());
        Assertions.assertEquals(1, status);
    }

    private static Integer runAndCaptureExitCode(Runnable r) {
        class ExitException extends SecurityException {
            final int code;

            ExitException(int code) {
                this.code = code;
            }
        }

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new ExitException(status);
                }
            });
            try {
                r.run();
            } catch (ExitException e) {
                return e.code;
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
        return null;
    }

    @Test
    public void testUpdateAdminPassword_fips_nonDefault_isPasswordValid_updates() throws Exception {
        ChangePasswordUtil.userLoginId = "fipsUser";
        ChangePasswordUtil.currentPassword = "Old#1234";
        ChangePasswordUtil.newPassword = "New#1234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsUser");
        user.setPassword("dbHash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsUser")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.isPasswordValid("fipsUser", "dbHash", "Old#1234")).thenReturn(true);

        util.updateAdminPassword();

        Mockito.verify(userMgr).updatePasswordInSHA256("fipsUser", "New#1234", true);
    }

    @Test
    public void testUpdateMultiplePasswords_fips_nonDefault_isPasswordValid_updates() throws Exception {
        ChangePasswordUtil.userPwdArgs = new String[] {"fipsMulti", "Old#1234", "New#1234"};
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsMulti");
        user.setPassword("dbHash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsMulti")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.isPasswordValid("fipsMulti", "dbHash", "Old#1234")).thenReturn(true);

        util.updateMultiplePasswords();

        Mockito.verify(userMgr).updatePasswordInSHA256("fipsMulti", "New#1234", true);
    }

    @Test
    public void testUpdateAdminPassword_fipsDefault_matches_updates_withFipsConfig() throws Exception {
        Mockito.reset(userMgr);
        ChangePasswordUtil.userLoginId = "fipsAdmin";
        ChangePasswordUtil.currentPassword = "Old#1234";
        ChangePasswordUtil.newPassword = "New#1234";
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsAdmin");
        user.setPassword("md5hash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsAdmin")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.encryptWithOlderAlgo("fipsAdmin", "Old#1234")).thenReturn("md5hash");

        util.updateAdminPassword();

        Mockito.verify(userMgr).updatePasswordInSHA256("fipsAdmin", "New#1234", true);
    }

    @Test
    public void testUpdateAdminPassword_fipsDefault_mismatch_exits_withFipsConfig() throws Exception {
        ChangePasswordUtil.userLoginId = "fipsAdmin2";
        ChangePasswordUtil.currentPassword = "Old#1234";
        ChangePasswordUtil.newPassword = "New#1234";
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsAdmin2");
        user.setPassword("dbHash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsAdmin2")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.encryptWithOlderAlgo("fipsAdmin2", "Old#1234")).thenReturn("notDbHash");

        Integer status = runAndCaptureExitCode(() -> util.updateAdminPassword());
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateAdminPassword_fips_nonDefault_invalid_noUpdate() throws Exception {
        Mockito.reset(userMgr);
        ChangePasswordUtil.userLoginId = "fipsNoUpdate";
        ChangePasswordUtil.currentPassword = "Old#1234";
        ChangePasswordUtil.newPassword = "New#1234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsNoUpdate");
        user.setPassword("dbHash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsNoUpdate")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.isPasswordValid("fipsNoUpdate", "dbHash", "Old#1234")).thenReturn(false);

        util.updateAdminPassword();

        Mockito.verify(userMgr, Mockito.never()).updatePasswordInSHA256(Mockito.anyString(), Mockito.anyString(),
                Mockito.anyBoolean());
    }

    @Test
    public void testUpdateAdminPassword_exception_exits() {
        ChangePasswordUtil.userLoginId = "exAdmin";
        ChangePasswordUtil.currentPassword = "Old#1234";
        ChangePasswordUtil.newPassword = "New#1234";
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("exAdmin");
        user.setPassword("dbEnc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("exAdmin")).thenReturn(user);
        Mockito.when(userMgr.encrypt("exAdmin", "Old#1234")).thenThrow(new RuntimeException("boom"));

        Integer status = runAndCaptureExitCode(() -> util.updateAdminPassword());
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateMultiplePasswords_fips_default_matches_updates() throws Exception {
        Mockito.reset(userMgr);
        ChangePasswordUtil.userPwdArgs = new String[] {"fipsMultiDef", "Old#1234", "New#1234"};
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsMultiDef");
        user.setPassword("md5hash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsMultiDef")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.encryptWithOlderAlgo("fipsMultiDef", "Old#1234")).thenReturn("md5hash");

        util.updateMultiplePasswords();

        Mockito.verify(userMgr).updatePasswordInSHA256("fipsMultiDef", "New#1234", true);
    }

    @Test
    public void testUpdateMultiplePasswords_fips_default_mismatch_exits() throws Exception {
        ChangePasswordUtil.userPwdArgs = new String[] {"fipsMultiDef2", "Old#1234", "New#1234"};
        ChangePasswordUtil.defaultPwdChangeRequest = true;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsMultiDef2");
        user.setPassword("dbHash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsMultiDef2")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.encryptWithOlderAlgo("fipsMultiDef2", "Old#1234")).thenReturn("notDbHash");

        Integer status = runAndCaptureExitCode(() -> util.updateMultiplePasswords());
        Assertions.assertEquals(1, status);
    }

    @Test
    public void testUpdateMultiplePasswords_fips_nonDefault_invalid_noUpdate() throws Exception {
        Mockito.reset(userMgr);
        ChangePasswordUtil.userPwdArgs = new String[] {"fipsNoUpd", "Old#1234", "New#1234"};
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("fipsNoUpd");
        user.setPassword("dbHash");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("fipsNoUpd")).thenReturn(user);

        RangerAdminConfig cfg = Mockito.mock(RangerAdminConfig.class);
        Mockito.when(cfg.isFipsEnabled()).thenReturn(true);
        Field f = util.getClass().getSuperclass().getDeclaredField("config");
        f.setAccessible(true);
        f.set(util, cfg);

        Mockito.when(userMgr.isPasswordValid("fipsNoUpd", "dbHash", "Old#1234")).thenReturn(false);

        util.updateMultiplePasswords();

        Mockito.verify(userMgr, Mockito.never()).updatePasswordInSHA256(Mockito.anyString(), Mockito.anyString(),
                Mockito.anyBoolean());
    }

    @Test
    public void testUpdateMultiplePasswords_exception_exits() {
        ChangePasswordUtil.userPwdArgs = new String[] {"exMulti", "Old#1234", "New#1234"};
        ChangePasswordUtil.defaultPwdChangeRequest = false;

        XXPortalUser user = new XXPortalUser();
        user.setLoginId("exMulti");
        user.setPassword("dbEnc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("exMulti")).thenReturn(user);
        Mockito.when(userMgr.encrypt("exMulti", "Old#1234")).thenThrow(new RuntimeException("boom"));

        Integer status = runAndCaptureExitCode(() -> util.updateMultiplePasswords());
        Assertions.assertEquals(1, status);
    }
}
