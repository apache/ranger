/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.PolicyRefUpdater;
import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXDataMaskTypeDefDao;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXPolicyConditionDefDao;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXPolicyItemAccessDao;
import org.apache.ranger.db.XXPolicyItemConditionDao;
import org.apache.ranger.db.XXPolicyItemDao;
import org.apache.ranger.db.XXPolicyItemDataMaskInfoDao;
import org.apache.ranger.db.XXPolicyItemGroupPermDao;
import org.apache.ranger.db.XXPolicyItemRowFilterInfoDao;
import org.apache.ranger.db.XXPolicyItemUserPermDao;
import org.apache.ranger.db.XXPolicyRefAccessTypeDao;
import org.apache.ranger.db.XXPolicyRefConditionDao;
import org.apache.ranger.db.XXPolicyRefDataMaskTypeDao;
import org.apache.ranger.db.XXPolicyRefGroupDao;
import org.apache.ranger.db.XXPolicyRefResourceDao;
import org.apache.ranger.db.XXPolicyRefUserDao;
import org.apache.ranger.db.XXPolicyResourceDao;
import org.apache.ranger.db.XXPolicyResourceMapDao;
import org.apache.ranger.db.XXResourceDefDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.db.XXUserDao;
import org.apache.ranger.entity.XXAccessTypeDef;
import org.apache.ranger.entity.XXDataMaskTypeDef;
import org.apache.ranger.entity.XXGroup;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXPolicyConditionDef;
import org.apache.ranger.entity.XXResourceDef;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXUser;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerPolicy.RangerPolicyResource;
import org.apache.ranger.plugin.model.RangerService;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForMigratingOldRegimePolicyJson_J10046 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForMigratingOldRegimePolicyJson_J10046 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testCleanupOldRefTables_NullPolicy_ReturnsFalse() {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();
        Assertions.assertFalse(patch.cleanupOldRefTables(null));
    }

    @Test
    public void testCleanupOldRefTables_ValidPolicy_ReturnsTrue() {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        Mockito.when(daoMgr.getXXPolicyItemGroupPerm()).thenReturn(Mockito.mock(XXPolicyItemGroupPermDao.class));
        Mockito.when(daoMgr.getXXPolicyItemUserPerm()).thenReturn(Mockito.mock(XXPolicyItemUserPermDao.class));
        Mockito.when(daoMgr.getXXPolicyItemAccess()).thenReturn(Mockito.mock(XXPolicyItemAccessDao.class));
        Mockito.when(daoMgr.getXXPolicyItemCondition()).thenReturn(Mockito.mock(XXPolicyItemConditionDao.class));
        Mockito.when(daoMgr.getXXPolicyItemDataMaskInfo()).thenReturn(Mockito.mock(XXPolicyItemDataMaskInfoDao.class));
        Mockito.when(daoMgr.getXXPolicyItemRowFilterInfo()).thenReturn(Mockito.mock(XXPolicyItemRowFilterInfoDao.class));
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(Mockito.mock(XXPolicyItemDao.class));
        Mockito.when(daoMgr.getXXPolicyResourceMap()).thenReturn(Mockito.mock(XXPolicyResourceMapDao.class));
        Mockito.when(daoMgr.getXXPolicyResource()).thenReturn(Mockito.mock(XXPolicyResourceDao.class));

        setIfPresent(patch, "daoMgr", daoMgr);

        RangerPolicy policy = new RangerPolicy();
        policy.setId(7L);

        Assertions.assertTrue(patch.cleanupOldRefTables(policy));
    }

    @Test
    public void testExecLoad_NoPolicies() {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
        PlatformTransactionManager txManager = Mockito.mock(PlatformTransactionManager.class);
        PolicyRefUpdater policyRefUpdater = Mockito.mock(PolicyRefUpdater.class);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);

        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        Mockito.when(xxPolicyDao.getAllByPolicyItem()).thenReturn(Collections.<XXPolicy>emptyList());

        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "svcStore", svcStore);
        setIfPresent(patch, "txManager", txManager);
        setIfPresent(patch, "policyRefUpdater", policyRefUpdater);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        patch.execLoad();
    }

    @Test
    public void testExecLoad_WithPolicies_Success() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
        PlatformTransactionManager txManager = Mockito.mock(PlatformTransactionManager.class);
        PolicyRefUpdater policyRefUpdater = Mockito.mock(PolicyRefUpdater.class);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);

        // Transaction behavior
        TransactionStatus txStatus = Mockito.mock(TransactionStatus.class);
        Mockito.when(txManager.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(txStatus);

        // Policy list
        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        XXPolicy xxPolicy = new XXPolicy();
        xxPolicy.setId(11L);
        List<XXPolicy> xxPolicies = new ArrayList<>();
        xxPolicies.add(xxPolicy);
        Mockito.when(xxPolicyDao.getAllByPolicyItem()).thenReturn(xxPolicies);

        // Return policy for id
        RangerPolicy policy = new RangerPolicy();
        policy.setId(11L);
        policy.setService("svc1");
        policy.setPolicyItems(new ArrayList<>());
        policy.setDenyPolicyItems(new ArrayList<>());
        policy.setAllowExceptions(new ArrayList<>());
        policy.setDenyExceptions(new ArrayList<>());
        policy.setDataMaskPolicyItems(new ArrayList<>());
        policy.setRowFilterPolicyItems(new ArrayList<>());
        policy.setResources(new HashMap<>());
        Mockito.when(svcStore.getPolicy(11L)).thenReturn(policy);

        // Service lookup
        RangerService service = new RangerService();
        service.setType("hive");
        Mockito.when(svcStore.getServiceByName("svc1")).thenReturn(service);

        // DAOs used in portPolicy() with empty lists/resources
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);

        Mockito.when(daoMgr.getXXPolicyRefUser()).thenReturn(Mockito.mock(XXPolicyRefUserDao.class));
        Mockito.when(daoMgr.getXXUser()).thenReturn(Mockito.mock(XXUserDao.class));
        Mockito.when(daoMgr.getXXPolicyRefGroup()).thenReturn(Mockito.mock(XXPolicyRefGroupDao.class));
        Mockito.when(daoMgr.getXXGroup()).thenReturn(Mockito.mock(XXGroupDao.class));
        Mockito.when(daoMgr.getXXPolicyRefAccessType()).thenReturn(Mockito.mock(XXPolicyRefAccessTypeDao.class));
        Mockito.when(daoMgr.getXXPolicyRefCondition()).thenReturn(Mockito.mock(XXPolicyRefConditionDao.class));
        Mockito.when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(Mockito.mock(XXPolicyRefDataMaskTypeDao.class));

        // Required for cleanupOldRefTables() at end of thread
        Mockito.when(daoMgr.getXXPolicyItemGroupPerm()).thenReturn(Mockito.mock(XXPolicyItemGroupPermDao.class));
        Mockito.when(daoMgr.getXXPolicyItemUserPerm()).thenReturn(Mockito.mock(XXPolicyItemUserPermDao.class));
        Mockito.when(daoMgr.getXXPolicyItemAccess()).thenReturn(Mockito.mock(XXPolicyItemAccessDao.class));
        Mockito.when(daoMgr.getXXPolicyItemCondition()).thenReturn(Mockito.mock(XXPolicyItemConditionDao.class));
        Mockito.when(daoMgr.getXXPolicyItemDataMaskInfo()).thenReturn(Mockito.mock(XXPolicyItemDataMaskInfoDao.class));
        Mockito.when(daoMgr.getXXPolicyItemRowFilterInfo())
                .thenReturn(Mockito.mock(XXPolicyItemRowFilterInfoDao.class));
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(Mockito.mock(XXPolicyItemDao.class));
        Mockito.when(daoMgr.getXXPolicyResourceMap()).thenReturn(Mockito.mock(XXPolicyResourceMapDao.class));
        Mockito.when(daoMgr.getXXPolicyResource()).thenReturn(Mockito.mock(XXPolicyResourceDao.class));

        // Policy update in portPolicy
        XXPolicyDao xxPolicyDaoForUpdate = xxPolicyDao;
        Mockito.when(xxPolicyDaoForUpdate.getById(11L)).thenReturn(new XXPolicy());

        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "svcStore", svcStore);
        setIfPresent(patch, "txManager", txManager);
        setIfPresent(patch, "policyRefUpdater", policyRefUpdater);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        // Should execute without throwing
        patch.execLoad();
    }

    @Test
    public void testPrivate_addResourceDefRef_unknownResource_throws() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        // Return null to simulate unknown resources for service type
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);

        setIfPresent(patch, "daoMgr", daoMgr);

        RangerPolicy policy = new RangerPolicy();
        policy.setId(5L);
        Map<String, RangerPolicyResource> res = new HashMap<>();
        res.put("unknownResource", new RangerPolicyResource());
        policy.setResources(res);

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addResourceDefRef",
                String.class, RangerPolicy.class);
        m.setAccessible(true);

        InvocationTargetException ex = Assertions.assertThrows(InvocationTargetException.class,
                () -> m.invoke(patch, "hive", policy));
        Assertions.assertTrue(ex.getCause().getMessage().contains("unknown resource"));
    }

    @Test
    public void testPrivate_addAccessDefRef_unknownAccess_throws() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        // No access types available
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);
        XXPolicyRefAccessTypeDao refDao = Mockito.mock(XXPolicyRefAccessTypeDao.class);
        Mockito.when(daoMgr.getXXPolicyRefAccessType()).thenReturn(refDao);

        setIfPresent(patch, "daoMgr", daoMgr);

        Set<String> accesses = new HashSet<>();
        accesses.add("select");

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addAccessDefRef", String.class,
                Long.class, Set.class);
        m.setAccessible(true);

        InvocationTargetException ex = Assertions.assertThrows(InvocationTargetException.class,
                () -> m.invoke(patch, "hive", 9L, accesses));
        Assertions.assertTrue(ex.getCause().getMessage().contains("unknown accessType"));
    }

    @Test
    public void testPrivate_addPolicyConditionDefRef_unknownCondition_throws() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);
        XXPolicyRefConditionDao refDao = Mockito.mock(XXPolicyRefConditionDao.class);
        Mockito.when(daoMgr.getXXPolicyRefCondition()).thenReturn(refDao);

        setIfPresent(patch, "daoMgr", daoMgr);

        Set<String> conditions = new HashSet<>();
        conditions.add("ip-range");

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addPolicyConditionDefRef",
                String.class, Long.class, Set.class);
        m.setAccessible(true);

        InvocationTargetException ex = Assertions.assertThrows(InvocationTargetException.class,
                () -> m.invoke(patch, "hive", 9L, conditions));
        Assertions.assertTrue(ex.getCause().getMessage().contains("unknown condition"));
    }

    @Test
    public void testPrivate_addDataMaskDefRef_unknownMask_throws() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);
        XXPolicyRefDataMaskTypeDao refDao = Mockito.mock(XXPolicyRefDataMaskTypeDao.class);
        Mockito.when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(refDao);

        setIfPresent(patch, "daoMgr", daoMgr);

        Set<String> masks = new HashSet<>();
        masks.add("redact");

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addDataMaskDefRef",
                String.class, Long.class, Set.class);
        m.setAccessible(true);

        InvocationTargetException ex = Assertions.assertThrows(InvocationTargetException.class,
                () -> m.invoke(patch, "hive", 9L, masks));
        Assertions.assertTrue(ex.getCause().getMessage().contains("unknown dataMaskType"));
    }

    @Test
    public void testAddResourceDefRef_successAndEmptyResources_noop() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        XXResourceDefDao xxResourceDefDao = Mockito.mock(XXResourceDefDao.class);
        XXPolicyRefResourceDao xxPolicyRefResourceDao = Mockito.mock(XXPolicyRefResourceDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(xxResourceDefDao);
        Mockito.when(daoMgr.getXXPolicyRefResource()).thenReturn(xxPolicyRefResourceDao);

        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(100L);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XXResourceDef resDef = new XXResourceDef();
        resDef.setId(200L);
        resDef.setName("database");
        Mockito.when(xxResourceDefDao.findByServiceDefId(100L)).thenReturn(new ArrayList<XXResourceDef>() {
            {
                add(resDef);
            }
        });

        setIfPresent(patch, "daoMgr", daoMgr);

        RangerPolicy policy = new RangerPolicy();
        policy.setId(5L);
        Map<String, RangerPolicy.RangerPolicyResource> resources = new HashMap<>();
        resources.put("database", new RangerPolicy.RangerPolicyResource());
        policy.setResources(resources);

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addResourceDefRef",
                String.class, RangerPolicy.class);
        m.setAccessible(true);
        m.invoke(patch, "hive", policy);
        Mockito.verify(xxPolicyRefResourceDao, Mockito.times(1)).create(Mockito.any());

        // empty resources -> noop
        policy.setResources(new HashMap<String, RangerPolicy.RangerPolicyResource>());
        m.invoke(patch, "hive", policy);
        Mockito.verifyNoMoreInteractions(xxPolicyRefResourceDao);
    }

    @Test
    public void testAddAccessDefRef_success() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        XXAccessTypeDefDao xxAccessTypeDefDao = Mockito.mock(XXAccessTypeDefDao.class);
        XXPolicyRefAccessTypeDao refDao = Mockito.mock(XXPolicyRefAccessTypeDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(xxAccessTypeDefDao);
        Mockito.when(daoMgr.getXXPolicyRefAccessType()).thenReturn(refDao);

        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(10L);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(77L);
        at.setName("select");
        Mockito.when(xxAccessTypeDefDao.findByServiceDefId(10L)).thenReturn(new ArrayList<XXAccessTypeDef>() {
            {
                add(at);
            }
        });

        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addAccessDefRef", String.class,
                Long.class, Set.class);
        m.setAccessible(true);
        Set<String> accesses = new HashSet<>();
        accesses.add("select");
        m.invoke(patch, "hive", 9L, accesses);
        Mockito.verify(refDao, Mockito.times(1)).create(Mockito.any());
    }

    @Test
    public void testAddPolicyConditionDefRef_success() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        XXPolicyConditionDefDao xxCondDao = Mockito.mock(XXPolicyConditionDefDao.class);
        XXPolicyRefConditionDao refDao = Mockito.mock(XXPolicyRefConditionDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(daoMgr.getXXPolicyConditionDef()).thenReturn(xxCondDao);
        Mockito.when(daoMgr.getXXPolicyRefCondition()).thenReturn(refDao);

        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(15L);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XXPolicyConditionDef cd = new XXPolicyConditionDef();
        cd.setId(88L);
        cd.setName("ip-range");
        Mockito.when(xxCondDao.findByServiceDefId(15L)).thenReturn(new ArrayList<XXPolicyConditionDef>() {
            {
                add(cd);
            }
        });

        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addPolicyConditionDefRef",
                String.class, Long.class, Set.class);
        m.setAccessible(true);
        Set<String> conds = new HashSet<>();
        conds.add("ip-range");
        m.invoke(patch, "hive", 9L, conds);
        Mockito.verify(refDao, Mockito.times(1)).create(Mockito.any());
    }

    @Test
    public void testAddDataMaskDefRef_success() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        XXDataMaskTypeDefDao xxDmDao = Mockito.mock(XXDataMaskTypeDefDao.class);
        XXPolicyRefDataMaskTypeDao refDao = Mockito.mock(XXPolicyRefDataMaskTypeDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(daoMgr.getXXDataMaskTypeDef()).thenReturn(xxDmDao);
        Mockito.when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(refDao);

        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(19L);
        Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XXDataMaskTypeDef dm = new XXDataMaskTypeDef();
        dm.setId(66L);
        dm.setName("redact");
        Mockito.when(xxDmDao.findByServiceDefId(19L)).thenReturn(new ArrayList<XXDataMaskTypeDef>() {
            {
                add(dm);
            }
        });

        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addDataMaskDefRef",
                String.class, Long.class, Set.class);
        m.setAccessible(true);
        Set<String> masks = new HashSet<>();
        masks.add("redact");
        m.invoke(patch, "hive", 9L, masks);
        Mockito.verify(refDao, Mockito.times(1)).create(Mockito.any());
    }

    @Test
    public void testAddUserNameRef_userFoundAndCached_andUserMissingThrows() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPolicyRefUserDao refUserDao = Mockito.mock(XXPolicyRefUserDao.class);
        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXPolicyRefUser()).thenReturn(refUserDao);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        setIfPresent(patch, "daoMgr", daoMgr);

        // found first time
        XXUser u = new XXUser();
        u.setId(123L);
        Mockito.when(userDao.findByUserName(Mockito.eq("alice"))).thenReturn(u);
        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addUserNameRef", Long.class,
                Set.class);
        m.setAccessible(true);
        Set<String> users = new HashSet<>();
        users.add("alice");
        m.invoke(patch, 1L, users);
        Mockito.verify(refUserDao, Mockito.times(1)).create(Mockito.any());
        Mockito.verify(userDao, Mockito.times(1)).findByUserName("alice");

        // missing even after create -> throws
        PlatformTransactionManager txManager = Mockito.mock(PlatformTransactionManager.class);
        TransactionStatus txStatus = Mockito.mock(TransactionStatus.class);
        Mockito.when(txManager.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(txStatus);
        setIfPresent(patch, "txManager", txManager);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        Mockito.when(userDao.findByUserName(Mockito.eq("bob"))).thenReturn(null);
        Set<String> users2 = new HashSet<>();
        users2.add("bob");
        Assertions.assertThrows(InvocationTargetException.class, () -> m.invoke(patch, 2L, users2));
    }

    @Test
    public void testAddGroupNameRef_successAndMissingThrows() throws Exception {
        PatchForMigratingOldRegimePolicyJson_J10046 patch = new PatchForMigratingOldRegimePolicyJson_J10046();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPolicyRefGroupDao refGroupDao = Mockito.mock(XXPolicyRefGroupDao.class);
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXPolicyRefGroup()).thenReturn(refGroupDao);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(groupDao);
        setIfPresent(patch, "daoMgr", daoMgr);

        // success
        XXGroup g = new XXGroup();
        g.setId(7L);
        Mockito.when(groupDao.findByGroupName("admins")).thenReturn(g);
        Method m = PatchForMigratingOldRegimePolicyJson_J10046.class.getDeclaredMethod("addGroupNameRef", Long.class,
                Set.class);
        m.setAccessible(true);
        Set<String> groups = new HashSet<>();
        groups.add("admins");
        m.invoke(patch, 3L, groups);
        Mockito.verify(refGroupDao, Mockito.times(1)).create(Mockito.any());

        // missing
        Mockito.when(groupDao.findByGroupName("devs")).thenReturn(null);
        Set<String> groups2 = new HashSet<>();
        groups2.add("devs");
        Assertions.assertThrows(InvocationTargetException.class, () -> m.invoke(patch, 3L, groups2));
    }
}
