/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.common.RangerFactory;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXPolicyLabelMapDao;
import org.apache.ranger.db.XXPolicyRefAccessTypeDao;
import org.apache.ranger.db.XXPolicyRefConditionDao;
import org.apache.ranger.db.XXPolicyRefDataMaskTypeDao;
import org.apache.ranger.db.XXPolicyRefGroupDao;
import org.apache.ranger.db.XXPolicyRefResourceDao;
import org.apache.ranger.db.XXPolicyRefRoleDao;
import org.apache.ranger.db.XXPolicyRefUserDao;
import org.apache.ranger.db.XXSecurityZoneDao;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXPolicyLabelMap;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerPolicyResourceSignature;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.transaction.PlatformTransactionManager;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() {
        PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 patch = new PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
        RangerFactory factory = Mockito.mock(RangerFactory.class);
        PlatformTransactionManager txManager = Mockito.mock(PlatformTransactionManager.class);

        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
        XXSecurityZoneDao xxSecurityZoneDao = Mockito.mock(XXSecurityZoneDao.class);
        XXPolicyLabelMapDao xxPolicyLabelMapDao = Mockito.mock(XXPolicyLabelMapDao.class);

        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        Mockito.when(daoMgr.getXXSecurityZoneDao()).thenReturn(xxSecurityZoneDao);
        Mockito.when(daoMgr.getXXPolicyLabelMap()).thenReturn(xxPolicyLabelMapDao);
        Mockito.when(xxPolicyDao.findByPolicyStatus(Mockito.anyBoolean()))
                .thenReturn(Collections.<XXPolicy>emptyList());
        Mockito.when(xxPolicyDao.findDuplicatePoliciesByServiceAndResourceSignature())
                .thenReturn(Collections.emptyMap());
        Mockito.when(xxPolicyLabelMapDao.findByPolicyId(Mockito.anyLong()))
                .thenReturn(Collections.<XXPolicyLabelMap>emptyList());
        Mockito.when(xxSecurityZoneDao.findByZoneId(Mockito.anyLong())).thenReturn(null);

        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "svcStore", svcStore);
        setIfPresent(patch, "factory", factory);
        setIfPresent(patch, "txManager", txManager);

        patch.execLoad();
        patch.printStats();
    }

    @Test
    public void testUpdateDisabledPolicyResourceSignature_withPolicies_updatesWhenPolicyParsed() throws Exception {
        PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 patch = new PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        XXPolicy p = new XXPolicy();
        p.setPolicyText("{}");
        Mockito.when(xxPolicyDao.findByPolicyStatus(Mockito.eq(false)))
                .thenReturn(new ArrayList<>(Collections.singletonList(p)));
        RangerFactory factory = Mockito.mock(RangerFactory.class);
        RangerPolicyResourceSignature sig = Mockito.mock(RangerPolicyResourceSignature.class);
        Mockito.when(sig.getSignature()).thenReturn("sig");
        Mockito.when(factory.createPolicyResourceSignature(Mockito.any(RangerPolicy.class))).thenReturn(sig);
        XXSecurityZoneDao xxSecurityZoneDao = Mockito.mock(XXSecurityZoneDao.class);
        Mockito.when(daoMgr.getXXSecurityZoneDao()).thenReturn(xxSecurityZoneDao);
        // daoMgr.getXXPolicy().update called
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "factory", factory);

        Method m = PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053.class
                .getDeclaredMethod("updateDisabledPolicyResourceSignature");
        m.setAccessible(true);
        m.invoke(patch);

        Mockito.verify(xxPolicyDao, Mockito.atLeastOnce()).update(Mockito.any(XXPolicy.class));
    }

    @Test
    public void testUpdateDisabledPolicyResourceSignature_withPolicies_policyParseNull_noUpdate() throws Exception {
        PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 patch = new PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        XXPolicy p = new XXPolicy();
        p.setPolicyText(null);
        Mockito.when(xxPolicyDao.findByPolicyStatus(Mockito.eq(false)))
                .thenReturn(new ArrayList<>(Collections.singletonList(p)));
        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053.class
                .getDeclaredMethod("updateDisabledPolicyResourceSignature");
        m.setAccessible(true);
        m.invoke(patch);

        Mockito.verify(xxPolicyDao, Mockito.never()).update(Mockito.any(XXPolicy.class));
    }

    @Test
    public void testRemoveDuplicatePolicies_removesSecondAndBeyond() throws Exception {
        PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 patch = new PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        Map<String, Long> dup = new HashMap<>();
        dup.put("sig", 7L);
        Mockito.when(xxPolicyDao.findDuplicatePoliciesByServiceAndResourceSignature()).thenReturn(dup);
        XXPolicy first = new XXPolicy();
        first.setId(1L);
        first.setName("p1");
        XXPolicy second = new XXPolicy();
        second.setId(2L);
        second.setName("p2");
        Mockito.when(xxPolicyDao.findByServiceIdAndResourceSignature(Mockito.eq(7L), Mockito.eq("sig")))
                .thenReturn(new ArrayList<>(Arrays.asList(first, second)));

        XXPolicyRefResourceDao refRes = Mockito.mock(XXPolicyRefResourceDao.class);
        XXPolicyRefRoleDao refRole = Mockito.mock(XXPolicyRefRoleDao.class);
        XXPolicyRefGroupDao refGroup = Mockito.mock(XXPolicyRefGroupDao.class);
        XXPolicyRefUserDao refUser = Mockito.mock(XXPolicyRefUserDao.class);
        XXPolicyRefAccessTypeDao refAcc = Mockito.mock(XXPolicyRefAccessTypeDao.class);
        XXPolicyRefConditionDao refCond = Mockito.mock(XXPolicyRefConditionDao.class);
        XXPolicyRefDataMaskTypeDao refMask = Mockito.mock(XXPolicyRefDataMaskTypeDao.class);
        XXPolicyLabelMapDao labelDao = Mockito.mock(XXPolicyLabelMapDao.class);
        Mockito.when(daoMgr.getXXPolicyRefResource()).thenReturn(refRes);
        Mockito.when(daoMgr.getXXPolicyRefRole()).thenReturn(refRole);
        Mockito.when(daoMgr.getXXPolicyRefGroup()).thenReturn(refGroup);
        Mockito.when(daoMgr.getXXPolicyRefUser()).thenReturn(refUser);
        Mockito.when(daoMgr.getXXPolicyRefAccessType()).thenReturn(refAcc);
        Mockito.when(daoMgr.getXXPolicyRefCondition()).thenReturn(refCond);
        Mockito.when(daoMgr.getXXPolicyRefDataMaskType()).thenReturn(refMask);
        Mockito.when(daoMgr.getXXPolicyLabelMap()).thenReturn(labelDao);
        Mockito.when(labelDao.findByPolicyId(Mockito.anyLong())).thenReturn(Collections.emptyList());

        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053.class
                .getDeclaredMethod("removeDuplicateResourceSignaturesPolicies");
        m.setAccessible(true);
        m.invoke(patch);

        Mockito.verify(xxPolicyDao, Mockito.times(1)).remove(Mockito.eq(2L));
    }

    @Test
    public void testCleanupRefTables_policyIdNull_returnsFalse() throws Exception {
        PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 patch = new PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053();
        Method m = PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053.class
                .getDeclaredMethod("cleanupRefTables", Long.class);
        m.setAccessible(true);
        Object ret = m.invoke(patch, new Object[] {null});
        Assertions.assertEquals(Boolean.FALSE, ret);
    }

    @Test
    public void testGetPolicy_whenXPolicyNull_returnsNull() throws Exception {
        PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053 patch = new PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053();
        Method m = PatchPreSql_058_ForUpdateToUniqueResoureceSignature_J10053.class.getDeclaredMethod("getPolicy",
                XXPolicy.class);
        m.setAccessible(true);
        Object ret = m.invoke(patch, new Object[] {null});
        Assertions.assertNull(ret);
    }
}
