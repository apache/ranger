/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.SecurityZoneDBStore;
import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.common.RangerValidatorFactory;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXAccessTypeDefGrantsDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.entity.XXAccessTypeDef;
import org.apache.ranger.entity.XXAccessTypeDefGrants;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerSecurityZone;
import org.apache.ranger.plugin.model.RangerSecurityZone.RangerSecurityZoneService;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerServiceConfigDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefValidator;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForSolrSvcDefAndPoliciesUpdate_J10055 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForSolrSvcDefAndPoliciesUpdate_J10055 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            // Embedded Solr service-def
            RangerServiceDef embeddedSolr = new RangerServiceDef();
            embeddedSolr.setId(101L);
            embeddedSolr.setResources(Collections.emptyList());
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME))
                    .thenReturn(embeddedSolr);

            // Embedded Atlas service-def for audit filter update
            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            RangerServiceConfigDef atlasCfg = new RangerServiceConfigDef();
            atlasCfg.setName(ServiceDBStore.RANGER_PLUGIN_AUDIT_FILTERS);
            atlasCfg.setDefaultValue("embd-audit");
            embeddedAtlas.setConfigs(Collections.singletonList(atlasCfg));
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(embeddedAtlas);

            // Tag service-def id
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance().getTagServiceDefId()).thenReturn(202L);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            PlatformTransactionManager txManager = Mockito.mock(PlatformTransactionManager.class);
            RangerValidatorFactory validatorFactory = Mockito.mock(RangerValidatorFactory.class);
            RangerServiceDefValidator validator = Mockito.mock(RangerServiceDefValidator.class);

            // Transaction behavior
            TransactionStatus txStatus = Mockito.mock(TransactionStatus.class);
            Mockito.when(txManager.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(txStatus);

            // DAO stubs used by patch
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(new XXServiceDef());

            XXServiceDao xxServiceDao = Mockito.mock(XXServiceDao.class);
            Mockito.when(daoMgr.getXXService()).thenReturn(xxServiceDao);
            Mockito.when(xxServiceDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());

            XXAccessTypeDefDao xxAccessTypeDefDao = Mockito.mock(XXAccessTypeDefDao.class);
            XXAccessTypeDefGrantsDao xxAccessTypeDefGrantsDao = Mockito.mock(XXAccessTypeDefGrantsDao.class);
            Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(xxAccessTypeDefDao);
            Mockito.when(daoMgr.getXXAccessTypeDefGrants()).thenReturn(xxAccessTypeDefGrantsDao);
            Mockito.when(xxAccessTypeDefDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());

            // ServiceDBStore behavior for Solr and Atlas
            RangerServiceDef dbSolr = new RangerServiceDef();
            dbSolr.setName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME);
            Mockito.when(
                    svcDBStore.getServiceDefByName(Mockito.eq(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME)))
                    .thenReturn(dbSolr);

            RangerServiceDef dbAtlas = new RangerServiceDef();
            RangerServiceConfigDef dbAtlasCfg = new RangerServiceConfigDef();
            dbAtlasCfg.setName(ServiceDBStore.RANGER_PLUGIN_AUDIT_FILTERS);
            dbAtlasCfg.setDefaultValue("old-audit");
            dbAtlas.setName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME);
            dbAtlas.setConfigs(new ArrayList<>(Collections.singletonList(dbAtlasCfg)));
            Mockito.when(
                    svcDBStore.getServiceDefByName(Mockito.eq(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME)))
                    .thenReturn(dbAtlas);

            Mockito.when(validatorFactory.getServiceDefValidator(Mockito.any(ServiceDBStore.class)))
                    .thenReturn(validator);
            Mockito.when(svcDBStore.updateServiceDef(Mockito.any(RangerServiceDef.class)))
                    .thenAnswer(inv -> inv.getArgument(0));

            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "txManager", txManager);
            setIfPresent(patch, "validatorFactory", validatorFactory);

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testUpdateDefaultAuditFilter() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            // Embedded Solr service-def to avoid System.exit
            RangerServiceDef embeddedSolr = new RangerServiceDef();
            embeddedSolr.setId(101L);
            embeddedSolr.setResources(Collections.emptyList());
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME))
                    .thenReturn(embeddedSolr);
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance().getTagServiceDefId()).thenReturn(202L);

            // Embedded Atlas service-def for audit filter update
            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            RangerServiceConfigDef atlasCfg = new RangerServiceConfigDef();
            atlasCfg.setName(ServiceDBStore.RANGER_PLUGIN_AUDIT_FILTERS);
            atlasCfg.setDefaultValue("embd-audit");
            embeddedAtlas.setConfigs(Collections.singletonList(atlasCfg));
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME))
                    .thenReturn(embeddedAtlas);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            PlatformTransactionManager txManager = Mockito.mock(PlatformTransactionManager.class);
            RangerValidatorFactory validatorFactory = Mockito.mock(RangerValidatorFactory.class);
            RangerServiceDefValidator validator = Mockito.mock(RangerServiceDefValidator.class);
            TransactionStatus txStatus = Mockito.mock(TransactionStatus.class);
            Mockito.when(txManager.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(txStatus);

            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(new XXServiceDef());

            XXServiceDao xxServiceDao = Mockito.mock(XXServiceDao.class);
            Mockito.when(daoMgr.getXXService()).thenReturn(xxServiceDao);
            Mockito.when(xxServiceDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());

            XXAccessTypeDefDao xxAccessTypeDefDao = Mockito.mock(XXAccessTypeDefDao.class);
            XXAccessTypeDefGrantsDao xxAccessTypeDefGrantsDao = Mockito.mock(XXAccessTypeDefGrantsDao.class);
            Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(xxAccessTypeDefDao);
            Mockito.when(daoMgr.getXXAccessTypeDefGrants()).thenReturn(xxAccessTypeDefGrantsDao);
            Mockito.when(xxAccessTypeDefDao.findByServiceDefId(Mockito.anyLong())).thenReturn(Collections.emptyList());

            RangerServiceDef dbSolr = new RangerServiceDef();
            dbSolr.setName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME);
            Mockito.when(
                    svcDBStore.getServiceDefByName(Mockito.eq(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME)))
                    .thenReturn(dbSolr);

            RangerServiceDef dbAtlas = new RangerServiceDef();
            RangerServiceConfigDef dbAtlasCfg = new RangerServiceConfigDef();
            dbAtlasCfg.setName(ServiceDBStore.RANGER_PLUGIN_AUDIT_FILTERS);
            dbAtlasCfg.setDefaultValue("old-audit");
            dbAtlas.setConfigs(Collections.singletonList(dbAtlasCfg));
            Mockito.when(
                    svcDBStore.getServiceDefByName(Mockito.eq(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME)))
                    .thenReturn(dbAtlas);

            Mockito.when(validatorFactory.getServiceDefValidator(Mockito.any(ServiceDBStore.class)))
                    .thenReturn(validator);
            Mockito.when(svcDBStore.updateServiceDef(Mockito.any(RangerServiceDef.class)))
                    .thenAnswer(inv -> inv.getArgument(0));

            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "txManager", txManager);
            setIfPresent(patch, "validatorFactory", validatorFactory);

            patch.execLoad();
        }
    }

    @Test
    public void testUpdateSolrSvcDef_whenValidatorOrUpdateThrows_runtimePropagated() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            RangerServiceDef embeddedSolr = new RangerServiceDef();
            embeddedSolr.setId(101L);
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME))
                    .thenReturn(embeddedSolr);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            RangerValidatorFactory validatorFactory = Mockito.mock(RangerValidatorFactory.class);
            RangerServiceDefValidator validator = Mockito.mock(RangerServiceDefValidator.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(new XXServiceDef());
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(new RangerServiceDef());
            Mockito.when(validatorFactory.getServiceDefValidator(Mockito.any())).thenReturn(validator);

            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "validatorFactory", validatorFactory);

            Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateSolrSvcDef");
            m.setAccessible(true);

            Mockito.doThrow(new RuntimeException("validate error")).when(validator)
                    .validate(Mockito.any(RangerServiceDef.class), Mockito.any());
            Assertions.assertThrows(RuntimeException.class, () -> {
                try {
                    m.invoke(patch);
                } catch (Exception e) {
                    throw (RuntimeException) e.getCause();
                }
            });
        }
    }

    @Test
    public void testUpdateServiceConfig_transformsAccessTypesAndUpdatesService() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "svcDBStore", svcDBStore);
        setIfPresent(patch, "daoMgr", daoMgr);

        XXService xService = new XXService();
        xService.setId(5L);

        RangerService rangerSvc = new RangerService();
        Map<String, String> cfg = new HashMap<>();
        cfg.put("foo.accessTypes", "others,solr_admin,custom");
        rangerSvc.setConfigs(cfg);
        Mockito.when(svcDBStore.getService(Mockito.eq(5L))).thenReturn(rangerSvc);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateServiceConfig",
                XXService.class);
        m.setAccessible(true);
        m.invoke(patch, xService);

        Mockito.verify(svcDBStore, Mockito.times(1)).updateService(Mockito.eq(rangerSvc), Mockito.isNull());
        String updated = rangerSvc.getConfigs().get("foo.accessTypes");
        Set<String> values = new HashSet<>();
        Collections.addAll(values, updated.split(","));
        Assertions.assertTrue(values.contains("query"));
        Assertions.assertTrue(values.contains("update"));
        Assertions.assertTrue(values.contains("custom"));
        Assertions.assertFalse(values.contains("others"));
        Assertions.assertFalse(values.contains("solr_admin"));
    }

    @Test
    public void testExecLoad_embeddedSolrMissing_exits() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.eq(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME)))
                    .thenReturn(null);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
            setIfPresent(patch, "svcDBStore", Mockito.mock(ServiceDBStore.class));
            setIfPresent(patch, "daoMgr", Mockito.mock(RangerDaoManager.class));
            setIfPresent(patch, "txManager", Mockito.mock(PlatformTransactionManager.class));

            SecurityManager orig = System.getSecurityManager();
            try {
                System.setSecurityManager(new SecurityManager() {
                    @Override
                    public void checkPermission(Permission perm) {
                    }

                    @Override
                    public void checkExit(int status) {
                        throw new SecurityException("exit");
                    }
                });
                Assertions.assertThrows(SecurityException.class, patch::execLoad);
            } finally {
                System.setSecurityManager(orig);
            }
        }
    }

    @Test
    public void testUpdateSolrSvcDef_xxServiceDefMissing_exits() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            RangerServiceDef embeddedSolr = new RangerServiceDef();
            embeddedSolr.setId(11L);
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance()
                    .getEmbeddedServiceDef(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_SOLR_NAME))
                    .thenReturn(embeddedSolr);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", Mockito.mock(ServiceDBStore.class));
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));

            SecurityManager orig = System.getSecurityManager();
            try {
                System.setSecurityManager(new SecurityManager() {
                    @Override
                    public void checkPermission(Permission perm) {
                    }

                    @Override
                    public void checkExit(int status) {
                        throw new SecurityException("exit");
                    }
                });
                Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateSolrSvcDef");
                m.setAccessible(true);
                Assertions.assertThrows(RuntimeException.class, () -> {
                    try {
                        m.invoke(patch);
                    } catch (Exception e) {
                        throw (RuntimeException) e.getCause();
                    }
                });
            } finally {
                System.setSecurityManager(orig);
            }
        }
    }

    @Test
    public void testDeleteOldAccessTypeRefs_removesGrantsAndDeprecatedTypes() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXAccessTypeDefDao atdDao = Mockito.mock(XXAccessTypeDefDao.class);
        XXAccessTypeDefGrantsDao grantsDao = Mockito.mock(XXAccessTypeDefGrantsDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atdDao);
        Mockito.when(daoMgr.getXXAccessTypeDefGrants()).thenReturn(grantsDao);
        setIfPresent(patch, "daoMgr", daoMgr);

        ArrayList<XXAccessTypeDef> list = new ArrayList<>();
        XXAccessTypeDef a = new XXAccessTypeDef();
        a.setId(1L);
        a.setName("solr_admin");
        XXAccessTypeDef b = new XXAccessTypeDef();
        b.setId(2L);
        b.setName("others");
        XXAccessTypeDef c = new XXAccessTypeDef();
        c.setId(3L);
        c.setName("solr:others");
        XXAccessTypeDef d = new XXAccessTypeDef();
        d.setId(4L);
        d.setName("solr:solr_admin");
        XXAccessTypeDef e = new XXAccessTypeDef();
        e.setId(5L);
        e.setName("query");
        list.add(a);
        list.add(b);
        list.add(c);
        list.add(d);
        list.add(e);
        Mockito.when(atdDao.findByServiceDefId(Mockito.anyLong())).thenReturn(list);

        ArrayList<XXAccessTypeDefGrants> grants = new ArrayList<>();
        XXAccessTypeDefGrants g1 = new XXAccessTypeDefGrants();
        g1.setId(10L);
        grants.add(g1);
        Mockito.when(grantsDao.findByATDId(Mockito.anyLong())).thenReturn(grants);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("deleteOldAccessTypeRefs",
                Long.class);
        m.setAccessible(true);
        m.invoke(patch, 99L);

        Mockito.verify(grantsDao, Mockito.atLeast(4)).remove(Mockito.anyLong());
        Mockito.verify(atdDao, Mockito.times(4))
                .remove(Mockito.longThat(id -> id == 1L || id == 2L || id == 3L || id == 4L));
        Mockito.verify(atdDao, Mockito.never()).remove(Mockito.eq(5L));
    }

    @Test
    public void testUpdateResPolicyItemAccess_coversBranches() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();

        List<RangerPolicy.RangerPolicyItem> items = new ArrayList<>();

        RangerPolicy.RangerPolicyItem adminItem = new RangerPolicy.RangerPolicyItem();
        adminItem.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr_admin", true))));
        items.add(adminItem);

        RangerPolicy.RangerPolicyItem upd = new RangerPolicy.RangerPolicyItem();
        upd.setAccesses(
                new ArrayList<>(Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("update", true))));
        items.add(upd);

        RangerPolicy.RangerPolicyItem qry = new RangerPolicy.RangerPolicyItem();
        qry.setAccesses(
                new ArrayList<>(Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("query", true))));
        items.add(qry);

        RangerPolicy.RangerPolicyItem oth = new RangerPolicy.RangerPolicyItem();
        oth.setAccesses(
                new ArrayList<>(Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("others", false))));
        items.add(oth);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateResPolicyItemAccess",
                List.class);
        m.setAccessible(true);
        m.invoke(patch, items);

        for (RangerPolicy.RangerPolicyItem it : items) {
            Set<String> types = new HashSet<>();
            for (RangerPolicy.RangerPolicyItemAccess acc : it.getAccesses()) {
                types.add(acc.getType());
            }
            Assertions.assertFalse(types.contains("solr_admin"));
        }
    }

    @Test
    public void testUpdateTagPolicyItemAccess_coversBranches() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        List<RangerPolicy.RangerPolicyItem> items = new ArrayList<>();

        RangerPolicy.RangerPolicyItem admin = new RangerPolicy.RangerPolicyItem();
        admin.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr:solr_admin", true))));
        items.add(admin);

        RangerPolicy.RangerPolicyItem upd = new RangerPolicy.RangerPolicyItem();
        upd.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr:update", true))));
        items.add(upd);

        RangerPolicy.RangerPolicyItem qry = new RangerPolicy.RangerPolicyItem();
        qry.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr:query", true))));
        items.add(qry);

        RangerPolicy.RangerPolicyItem oth = new RangerPolicy.RangerPolicyItem();
        oth.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr:others", false))));
        items.add(oth);

        RangerPolicy.RangerPolicyItem unknown = new RangerPolicy.RangerPolicyItem();
        unknown.setAccesses(
                new ArrayList<>(Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("custom", true))));
        items.add(unknown);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateTagPolicyItemAccess",
                List.class);
        m.setAccessible(true);
        m.invoke(patch, items);

        for (RangerPolicy.RangerPolicyItem it : items) {
            for (RangerPolicy.RangerPolicyItemAccess acc : it.getAccesses()) {
                Assertions.assertNotEquals("solr:solr_admin", acc.getType());
            }
        }
    }

    @Test
    public void testUpdateDefaultAuditFilter_embeddedEmpty_noChange() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            RangerServiceDef embeddedAtlas = new RangerServiceDef();
            embeddedAtlas.setConfigs(new ArrayList<>()); // empty configs -> empty default
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance().getEmbeddedServiceDef(Mockito.anyString()))
                    .thenReturn(embeddedAtlas);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
            ServiceDBStore svcDB = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "svcDBStore", svcDB);

            Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateDefaultAuditFilter",
                    String.class);
            m.setAccessible(true);
            m.invoke(patch, EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME);

            Mockito.verify(svcDB, Mockito.never()).updateServiceDef(Mockito.any());
        }
    }

    @Test
    public void testFilterPolicyItemsForAdminPermission_filtersOnlyAdmin() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();

        RangerPolicy.RangerPolicyItem admin = new RangerPolicy.RangerPolicyItem();
        admin.setUsers(new ArrayList<>());
        List<RangerPolicy.RangerPolicyItemAccess> adminAcc = new ArrayList<>();
        adminAcc.add(new RangerPolicy.RangerPolicyItemAccess("solr_admin", true));
        admin.setAccesses(adminAcc);

        RangerPolicy.RangerPolicyItem nonAdmin = new RangerPolicy.RangerPolicyItem();
        List<RangerPolicy.RangerPolicyItemAccess> nonAdminAcc = new ArrayList<>();
        nonAdminAcc.add(new RangerPolicy.RangerPolicyItemAccess("query", true));
        nonAdmin.setAccesses(nonAdminAcc);

        List<RangerPolicy.RangerPolicyItem> items = new ArrayList<>();
        items.add(admin);
        items.add(nonAdmin);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class
                .getDeclaredMethod("filterPolicyItemsForAdminPermission", List.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<RangerPolicy.RangerPolicyItem> res = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, items);

        Assertions.assertEquals(1, res.size());
        Set<String> types = new HashSet<>();
        for (RangerPolicy.RangerPolicyItemAccess a : res.get(0).getAccesses()) {
            types.add(a.getType());
        }
        Assertions.assertTrue(types.contains("query"));
        Assertions.assertTrue(types.contains("update"));
        Assertions.assertFalse(types.contains("solr_admin"));
    }

    @Test
    public void testCreateOrUpdatePolicy_splitFalse_onlyUpdatesExisting() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);

        RangerPolicy ex = new RangerPolicy();
        ex.setName("ex-policy");
        // No admin access anywhere -> splitPolicy should be false
        RangerPolicy.RangerPolicyItem item = new RangerPolicy.RangerPolicyItem();
        item.setAccesses(
                new ArrayList<>(Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("query", true))));
        ex.setPolicyItems(new ArrayList<>(Collections.singletonList(item)));
        Map<String, RangerPolicy.RangerPolicyResource> resMap = new HashMap<>();
        RangerPolicy.RangerPolicyResource res = new RangerPolicy.RangerPolicyResource();
        res.setValues(new ArrayList<>(Collections.singletonList("collectionA")));
        resMap.put("collection", res);
        ex.setResources(resMap);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("createOrUpdatePolicy",
                RangerPolicy.class);
        m.setAccessible(true);
        m.invoke(patch, ex);

        Mockito.verify(svc, Mockito.times(1)).updatePolicy(Mockito.eq(ex));
        Mockito.verify(svc, Mockito.never()).createPolicy(Mockito.any());
    }

    @Test
    public void testCreateOrUpdatePolicy_isAllResourcesFalse_createsSchemaOnly() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);

        RangerPolicy ex = new RangerPolicy();
        ex.setName("base");
        RangerPolicy.RangerPolicyItem adminItem = new RangerPolicy.RangerPolicyItem();
        adminItem.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr_admin", true))));
        ex.setPolicyItems(new ArrayList<>(Collections.singletonList(adminItem)));
        Map<String, RangerPolicy.RangerPolicyResource> resMap = new HashMap<>();
        RangerPolicy.RangerPolicyResource res = new RangerPolicy.RangerPolicyResource();
        res.setValues(new ArrayList<>(Collections.singletonList("myCollection")));
        resMap.put("collection", res);
        ex.setResources(resMap);

        ArgumentCaptor<RangerPolicy> created = ArgumentCaptor.forClass(RangerPolicy.class);
        Mockito.when(svc.createPolicy(created.capture())).thenAnswer(inv -> inv.getArgument(0));

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("createOrUpdatePolicy",
                RangerPolicy.class);
        m.setAccessible(true);
        m.invoke(patch, ex);

        // Only one new policy expected with name starting with schema -
        Assertions.assertEquals(1, created.getAllValues().size());
        Assertions.assertTrue(created.getValue().getName().startsWith("schema - 'base'"));
        Mockito.verify(svc, Mockito.times(1)).updatePolicy(Mockito.eq(ex));
    }

    @Test
    public void testCreateOrUpdatePolicy_isAllResourcesTrue_createsAllThree() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);

        RangerPolicy ex = new RangerPolicy();
        ex.setName("baseAll");
        RangerPolicy.RangerPolicyItem adminItem = new RangerPolicy.RangerPolicyItem();
        adminItem.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr_admin", true))));
        ex.setPolicyItems(new ArrayList<>(Collections.singletonList(adminItem)));
        Map<String, RangerPolicy.RangerPolicyResource> resMap = new HashMap<>();
        RangerPolicy.RangerPolicyResource res = new RangerPolicy.RangerPolicyResource();
        res.setValues(new ArrayList<>(Collections.singletonList("*")));
        resMap.put("collection", res);
        ex.setResources(resMap);

        List<String> createdNames = new ArrayList<>();
        Mockito.when(svc.createPolicy(Mockito.any(RangerPolicy.class))).thenAnswer(inv -> {
            RangerPolicy arg = inv.getArgument(0);
            createdNames.add(arg.getName());
            return arg;
        });

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("createOrUpdatePolicy",
                RangerPolicy.class);
        m.setAccessible(true);
        m.invoke(patch, ex);

        Assertions.assertEquals(3, createdNames.size());
        Set<String> names = new HashSet<>();
        for (String n : createdNames) {
            names.add(n.split(" ")[0]);
        }
        Assertions.assertTrue(names.contains("admin"));
        Assertions.assertTrue(names.contains("config"));
        Assertions.assertTrue(names.contains("schema"));
        Mockito.verify(svc, Mockito.times(1)).updatePolicy(Mockito.eq(ex));
    }

    @Test
    public void testUpdateResPolicies_whenUpdateThrows_wrapsAsRuntime() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        TransactionStatus status = Mockito.mock(TransactionStatus.class);
        Mockito.when(tx.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(status);
        setIfPresent(patch, "txManager", tx);

        RangerPolicy ex = new RangerPolicy();
        ex.setName("p1");
        Map<String, RangerPolicy.RangerPolicyResource> resMap = new HashMap<>();
        RangerPolicy.RangerPolicyResource res = new RangerPolicy.RangerPolicyResource();
        res.setValues(new ArrayList<>(Collections.singletonList("col1")));
        resMap.put("collection", res);
        ex.setResources(resMap);
        // Force updatePolicy to throw inside createOrUpdatePolicy
        Mockito.doThrow(new RuntimeException("boom")).when(svc).updatePolicy(Mockito.eq(ex));

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateResPolicies", List.class);
        m.setAccessible(true);

        Assertions.assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch, new ArrayList<>(Collections.singletonList(ex)));
            } catch (Exception e) {
                throw (RuntimeException) e.getCause();
            }
        });
    }

    @Test
    public void testUpdateTagPolicies_updatesPolicy() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        TransactionStatus status = Mockito.mock(TransactionStatus.class);
        Mockito.when(tx.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(status);
        setIfPresent(patch, "txManager", tx);

        RangerPolicy tagPol = new RangerPolicy();
        tagPol.setName("tagP");
        RangerPolicy.RangerPolicyItem item = new RangerPolicy.RangerPolicyItem();
        item.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr:others", true))));
        tagPol.setPolicyItems(new ArrayList<>(Collections.singletonList(item)));

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateTagPolicies", List.class);
        m.setAccessible(true);
        m.invoke(patch, new ArrayList<>(Collections.singletonList(tagPol)));

        Mockito.verify(svc, Mockito.times(1)).updatePolicy(Mockito.eq(tagPol));
    }

    @Test
    public void testUpdateZone_allResourceAndSpecificBranches() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        SecurityZoneDBStore zoneStore = Mockito.mock(SecurityZoneDBStore.class);
        setIfPresent(patch, "secZoneDBStore", zoneStore);

        // Case 1: values contain "*" -> add admin,config,schema
        RangerSecurityZone zone1 = new RangerSecurityZone();
        Map<String, RangerSecurityZoneService> services1 = new HashMap<>();
        RangerSecurityZoneService svc1 = new RangerSecurityZoneService();
        HashMap<String, List<String>> existingRes1 = new HashMap<>();
        existingRes1.put("collection", new ArrayList<>(Collections.singletonList("*")));
        svc1.setResources(new ArrayList<>(Collections.singletonList(existingRes1)));
        services1.put("solr-svc", svc1);
        zone1.setServices(services1);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateZone",
                RangerSecurityZone.class, String.class);
        m.setAccessible(true);
        m.invoke(patch, zone1, "solr-svc");

        Set<String> keys1 = new HashSet<>();
        for (HashMap<String, List<String>> mp : zone1.getServices().get("solr-svc").getResources()) {
            keys1.addAll(mp.keySet());
        }
        Assertions.assertTrue(keys1.contains("admin"));
        Assertions.assertTrue(keys1.contains("config"));
        Assertions.assertTrue(keys1.contains("schema"));
        Mockito.verify(zoneStore, Mockito.times(1)).updateSecurityZoneById(Mockito.eq(zone1));

        // Case 2: specific value -> only schema mapping added
        RangerSecurityZone zone2 = new RangerSecurityZone();
        Map<String, RangerSecurityZoneService> services2 = new HashMap<>();
        RangerSecurityZoneService svc2 = new RangerSecurityZoneService();
        HashMap<String, List<String>> existingRes2 = new HashMap<>();
        existingRes2.put("collection", new ArrayList<>(Collections.singletonList("val")));
        svc2.setResources(new ArrayList<>(Collections.singletonList(existingRes2)));
        services2.put("solr-svc", svc2);
        zone2.setServices(services2);

        m.invoke(patch, zone2, "solr-svc");

        Set<String> keys2 = new HashSet<>();
        for (HashMap<String, List<String>> mp : zone2.getServices().get("solr-svc").getResources()) {
            keys2.addAll(mp.keySet());
        }
        Assertions.assertTrue(keys2.contains("schema"));
        Mockito.verify(zoneStore, Mockito.times(1)).updateSecurityZoneById(Mockito.eq(zone2));
    }

    @Test
    public void testUpdateZoneResourceMapping_missingServiceMapping_throwsRuntime() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        SecurityZoneDBStore zoneStore = Mockito.mock(SecurityZoneDBStore.class);
        setIfPresent(patch, "secZoneDBStore", zoneStore);
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        TransactionStatus status = Mockito.mock(TransactionStatus.class);
        Mockito.when(tx.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(status);
        setIfPresent(patch, "txManager", tx);

        RangerSecurityZone zone = new RangerSecurityZone();
        // services map that does NOT contain the solr service name => updateZone will
        // throw NPE inside tx
        Map<String, RangerSecurityZoneService> services = new HashMap<>();
        services.put("other-svc", new RangerSecurityZoneService());
        zone.setServices(services);
        List<RangerSecurityZone> zones = new ArrayList<>();
        zones.add(zone);
        Mockito.when(zoneStore.getSecurityZones(Mockito.any())).thenReturn(zones);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateZoneResourceMapping",
                XXService.class);
        m.setAccessible(true);
        XXService dbService = new XXService();
        dbService.setName("solr-svc");

        Assertions.assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch, dbService);
            } catch (Exception e) {
                throw (RuntimeException) e.getCause();
            }
        });
    }

    @Test
    public void testUpdateTagPolicies_emptyOrNull_noUpdate() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        // TransactionStatus status = Mockito.mock(TransactionStatus.class);
        // Mockito.when(tx.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(status);
        setIfPresent(patch, "txManager", tx);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateTagPolicies", List.class);
        m.setAccessible(true);
        m.invoke(patch, new Object[] {null});
        m.invoke(patch, new ArrayList<RangerPolicy>());
        Mockito.verifyNoInteractions(svc);
    }

    @Test
    public void testUpdateResPolicies_emptyOrNull_noAction() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        // TransactionStatus status = Mockito.mock(TransactionStatus.class);
        // Mockito.when(tx.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(status);
        setIfPresent(patch, "txManager", tx);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateResPolicies", List.class);
        m.setAccessible(true);
        m.invoke(patch, new Object[] {null});
        m.invoke(patch, new ArrayList<RangerPolicy>());
        Mockito.verifyNoInteractions(svc);
    }

    @Test
    public void testUpdateResPolicyItemAccess_handlesNulls() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        List<RangerPolicy.RangerPolicyItem> items = new ArrayList<>();
        items.add(null);
        RangerPolicy.RangerPolicyItem emptyAccess = new RangerPolicy.RangerPolicyItem();
        emptyAccess.setAccesses(null);
        items.add(emptyAccess);
        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateResPolicyItemAccess",
                List.class);
        m.setAccessible(true);
        m.invoke(patch, items);
    }

    @Test
    public void testFilterPolicyItemsForAdminPermission_noAdmin_returnsEmpty() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        List<RangerPolicy.RangerPolicyItem> items = new ArrayList<>();
        RangerPolicy.RangerPolicyItem i = new RangerPolicy.RangerPolicyItem();
        i.setAccesses(
                new ArrayList<>(Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("query", true))));
        items.add(i);
        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class
                .getDeclaredMethod("filterPolicyItemsForAdminPermission", List.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<RangerPolicy.RangerPolicyItem> out = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, items);
        Assertions.assertTrue(out.isEmpty());
    }

    @Test
    public void testUpdateServiceConfig_noConfigs_noUpdate() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);
        RangerService rangerSvc = new RangerService();
        rangerSvc.setConfigs(null);
        Mockito.when(svc.getService(Mockito.eq(1L))).thenReturn(rangerSvc);
        XXService x = new XXService();
        x.setId(1L);
        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateServiceConfig",
                XXService.class);
        m.setAccessible(true);
        m.invoke(patch, x);
        Mockito.verify(svc, Mockito.never()).updateService(Mockito.any(), Mockito.any());
    }

    @Test
    public void testUpdateDefaultAuditFilter_sameDefault_noUpdate() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            // embedded default value
            RangerServiceDef embedded = new RangerServiceDef();
            RangerServiceConfigDef cfg = new RangerServiceConfigDef();
            cfg.setName(ServiceDBStore.RANGER_PLUGIN_AUDIT_FILTERS);
            cfg.setDefaultValue("same");
            embedded.setConfigs(new ArrayList<>(Collections.singletonList(cfg)));
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(embedded);

            PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
            ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "svcDBStore", svc);
            RangerServiceDef db = new RangerServiceDef();
            RangerServiceConfigDef dbCfg = new RangerServiceConfigDef();
            dbCfg.setName(ServiceDBStore.RANGER_PLUGIN_AUDIT_FILTERS);
            dbCfg.setDefaultValue("same");
            db.setConfigs(new ArrayList<>(Collections.singletonList(dbCfg)));
            Mockito.when(svc.getServiceDefByName(Mockito.anyString())).thenReturn(db);

            Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateDefaultAuditFilter",
                    String.class);
            m.setAccessible(true);
            m.invoke(patch, EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_ATLAS_NAME);
            Mockito.verify(svc, Mockito.never()).updateServiceDef(Mockito.any());
        }
    }

    @Test
    public void testUpdateExistingRangerResPolicy_invokesSubroutines() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        RangerDaoManager dao = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", dao);
        XXServiceDao xxServiceDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(dao.getXXService()).thenReturn(xxServiceDao);
        XXService svcRow = new XXService();
        svcRow.setId(42L);
        svcRow.setName("solr-svc");
        Mockito.when(xxServiceDao.findByServiceDefId(Mockito.eq(9L)))
                .thenReturn(new ArrayList<>(Collections.singletonList(svcRow)));

        ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svcStore);
        Mockito.when(svcStore.getServicePolicies(Mockito.eq(42L), Mockito.any())).thenReturn(new ArrayList<>());
        RangerService rangerSvc = new RangerService();
        rangerSvc.setConfigs(null);
        Mockito.when(svcStore.getService(Mockito.eq(42L))).thenReturn(rangerSvc);
        SecurityZoneDBStore zoneStore = Mockito.mock(SecurityZoneDBStore.class);
        setIfPresent(patch, "secZoneDBStore", zoneStore);
        Mockito.when(zoneStore.getSecurityZones(Mockito.any())).thenReturn(new ArrayList<>());
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        // TransactionStatus status = Mockito.mock(TransactionStatus.class);
        // Mockito.when(tx.getTransaction(Mockito.any(TransactionDefinition.class))).thenReturn(status);
        setIfPresent(patch, "txManager", tx);

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("updateExistingRangerResPolicy",
                Long.class);
        m.setAccessible(true);
        m.invoke(patch, 9L);

        Mockito.verify(svcStore, Mockito.times(1)).getServicePolicies(Mockito.eq(42L), Mockito.any());
    }

    @Test
    public void testCreateOrUpdatePolicy_createThrows_wrapsRuntime() throws Exception {
        PatchForSolrSvcDefAndPoliciesUpdate_J10055 patch = new PatchForSolrSvcDefAndPoliciesUpdate_J10055();
        ServiceDBStore svc = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svc);

        RangerPolicy ex = new RangerPolicy();
        ex.setName("baseAll");
        RangerPolicy.RangerPolicyItem adminItem = new RangerPolicy.RangerPolicyItem();
        adminItem.setAccesses(new ArrayList<>(
                Collections.singletonList(new RangerPolicy.RangerPolicyItemAccess("solr_admin", true))));
        ex.setPolicyItems(new ArrayList<>(Collections.singletonList(adminItem)));
        Map<String, RangerPolicy.RangerPolicyResource> resMap = new HashMap<>();
        RangerPolicy.RangerPolicyResource res = new RangerPolicy.RangerPolicyResource();
        res.setValues(new ArrayList<>(Collections.singletonList("*")));
        resMap.put("collection", res);
        ex.setResources(resMap);

        Mockito.doThrow(new RuntimeException("create-fail")).when(svc).createPolicy(Mockito.any(RangerPolicy.class));

        Method m = PatchForSolrSvcDefAndPoliciesUpdate_J10055.class.getDeclaredMethod("createOrUpdatePolicy",
                RangerPolicy.class);
        m.setAccessible(true);
        Assertions.assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch, ex);
            } catch (Exception e) {
                throw (RuntimeException) e.getCause();
            }
        });
    }
}
