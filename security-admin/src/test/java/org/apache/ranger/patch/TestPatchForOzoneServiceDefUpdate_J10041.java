/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.common.JSONUtil;
import org.apache.ranger.common.RangerValidatorFactory;
import org.apache.ranger.common.StringUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerResourceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerServiceConfigDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefValidator;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.plugin.util.SearchFilter;
import org.apache.ranger.service.RangerPolicyService;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForOzoneServiceDefUpdate_J10041 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForOzoneServiceDefUpdate_J10041 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            RangerServiceDef svcDef = new RangerServiceDef();
            svcDef.setId(1L);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(svcDef);

            PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
            Mockito.when(xxServiceDefDao.findByName(Mockito.anyString())).thenReturn(null);
            setIfPresent(patch, "daoMgr", daoMgr);

            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "svcDBStore", svcStore);
            setIfPresent(patch, "jsonUtil", new JSONUtil());
            setIfPresent(patch, "policyService", Mockito.mock(RangerPolicyService.class));
            setIfPresent(patch, "stringUtil", new StringUtil());
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testJsonStringToMap_andMapToJsonString() throws Exception {
        PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
        Method jsonToMap = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("jsonStringToMap",
                String.class);
        jsonToMap.setAccessible(true);
        @SuppressWarnings("unchecked")
        HashMap<String, String> res = (HashMap<String, String>) jsonToMap.invoke(patch, "a=1;b=2");
        Assertions.assertEquals("1", res.get("a"));
        Assertions.assertEquals("2", res.get("b"));

        Method mapToJson = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("mapToJsonString", Map.class);
        mapToJson.setAccessible(true);
        Object nullRes = mapToJson.invoke(patch, new Object[] {null});
        Assertions.assertNull(nullRes);

        PatchForOzoneServiceDefUpdate_J10041 patch2 = new PatchForOzoneServiceDefUpdate_J10041();
        JSONUtil jsonUtil = Mockito.mock(JSONUtil.class);
        Mockito.when(jsonUtil.readMapToString(Mockito.anyMap())).thenThrow(new RuntimeException("x"));
        setIfPresent(patch2, "jsonUtil", jsonUtil);
        Object excRes = mapToJson.invoke(patch2, new HashMap<String, String>());
        Assertions.assertNull(excRes);
    }

    @Test
    public void testCheckHelpers_trueAndFalse() throws Exception {
        PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
        Method chkCfg = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("checkNotConfigPresent",
                List.class);
        chkCfg.setAccessible(true);
        List<RangerServiceDef.RangerServiceConfigDef> cfgs = new ArrayList<>();
        RangerServiceConfigDef c = new RangerServiceConfigDef();
        c.setName("foo");
        cfgs.add(c);
        Assertions.assertTrue((boolean) chkCfg.invoke(patch, cfgs));
        c.setName("dfs.datanode.kerberos.principal");
        Assertions.assertTrue((boolean) chkCfg.invoke(patch, cfgs));

        Method chkRes = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("checkVolKeyResUpdate",
                List.class);
        chkRes.setAccessible(true);
        List<RangerResourceDef> rdefs = new ArrayList<>();
        RangerResourceDef r1 = new RangerResourceDef();
        r1.setName("volume");
        r1.setRecursiveSupported(false);
        r1.setExcludesSupported(true);
        rdefs.add(r1);
        Assertions.assertTrue((boolean) chkRes.invoke(patch, rdefs));
        r1.setName("key");
        r1.setRecursiveSupported(true);
        Assertions.assertTrue((boolean) chkRes.invoke(patch, rdefs));

        Method chkAccess = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("checkAccessTypesPresent",
                List.class);
        chkAccess.setAccessible(true);
        List<RangerAccessTypeDef> at = new ArrayList<>();
        RangerAccessTypeDef a = new RangerAccessTypeDef();
        a.setName("read_acl");
        at.add(a);
        Assertions.assertTrue((boolean) chkAccess.invoke(patch, at));
        at.clear();
        RangerAccessTypeDef a2 = new RangerAccessTypeDef();
        a2.setName("none");
        at.add(a2);
        Assertions.assertFalse((boolean) chkAccess.invoke(patch, at));
    }

    @Test
    public void testUpdateOzoneServiceDef_flows_andPolicyUpdate() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            XXServiceDao serviceDao = Mockito.mock(XXServiceDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            Mockito.when(daoMgr.getXXService()).thenReturn(serviceDao);
            setIfPresent(patch, "daoMgr", daoMgr);

            // embedded null -> false
            Method m = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("updateOzoneServiceDef");
            m.setAccessible(true);
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance().getEmbeddedServiceDef(Mockito.anyString()))
                    .thenReturn(null);
            Assertions.assertFalse((boolean) m.invoke(patch));

            // DAO service-def missing -> true
            RangerServiceDef embedded = new RangerServiceDef();
            embedded.setId(5L);
            utilMock.when(() -> EmbeddedServiceDefsUtil.instance().getEmbeddedServiceDef(Mockito.anyString()))
                    .thenReturn(embedded);
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(null);
            Assertions.assertTrue((boolean) m.invoke(patch));

            // DB store missing -> false
            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "svcDBStore", svcStore);
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(new XXServiceDef());
            Mockito.when(svcStore.getServiceDefByName(Mockito.anyString())).thenReturn(null);
            Assertions.assertFalse((boolean) m.invoke(patch));

            // Success flow with option-restore and policy updates
            RangerServiceDef dbDef = new RangerServiceDef();
            dbDef.setResources(new ArrayList<>());
            dbDef.setAccessTypes(new ArrayList<>());
            dbDef.setConfigs(new ArrayList<>());
            Mockito.when(svcStore.getServiceDefByName(Mockito.anyString())).thenReturn(dbDef);
            RangerServiceDefValidator validator = Mockito.mock(RangerServiceDefValidator.class);
            RangerValidatorFactory vf = Mockito.mock(RangerValidatorFactory.class);
            Mockito.when(vf.getServiceDefValidator(Mockito.any())).thenReturn(validator);
            setIfPresent(patch, "validatorFactory", vf);

            // Embedded defs to trigger setResources and setAccessTypes
            RangerResourceDef vol = new RangerResourceDef();
            vol.setName("volume");
            vol.setRecursiveSupported(false);
            vol.setExcludesSupported(true);
            RangerResourceDef key = new RangerResourceDef();
            key.setName("key");
            key.setRecursiveSupported(true);
            List<RangerResourceDef> resDefs = new ArrayList<>();
            resDefs.add(vol);
            resDefs.add(key);
            embedded.setResources(resDefs);
            List<RangerAccessTypeDef> accDefs = new ArrayList<>();
            RangerAccessTypeDef ra = new RangerAccessTypeDef();
            ra.setName("read_acl");
            accDefs.add(ra);
            embedded.setAccessTypes(accDefs);
            List<RangerServiceConfigDef> cfgDefs = new ArrayList<>();
            RangerServiceConfigDef cfg = new RangerServiceConfigDef();
            cfg.setName("someConfig");
            cfgDefs.add(cfg);
            embedded.setConfigs(cfgDefs);

            Mockito.when(svcStore.updateServiceDef(Mockito.any())).thenReturn(dbDef);

            // pre-update option empty, post-update contains option -> restore/remove
            XXServiceDef xx = new XXServiceDef();
            xx.setDefOptions(null);
            XXServiceDef xxAfter = new XXServiceDef();
            HashMap<String, String> postOptions = new HashMap<>();
            postOptions.put(RangerServiceDef.OPTION_ENABLE_DENY_AND_EXCEPTIONS_IN_POLICIES, "true");
            String postStr = new JSONUtil().readMapToString(postOptions);
            xxAfter.setDefOptions(postStr);
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(xx, xxAfter, xxAfter);

            // services under ozone and policies to update
            XXService s = new XXService();
            s.setId(21L);
            s.setName("oz1");
            Mockito.when(serviceDao.findByServiceDefId(Mockito.anyLong()))
                    .thenReturn(new ArrayList<XXService>(Arrays.asList(s)));
            Mockito.when(svcStore.getServicePolicies(Mockito.eq(21L), Mockito.any(SearchFilter.class)))
                    .thenReturn(new ArrayList<RangerPolicy>(Arrays.asList(new RangerPolicy())));

            Assertions.assertTrue((boolean) m.invoke(patch));
            Mockito.verify(svcStore, Mockito.atLeastOnce()).updateServiceDef(Mockito.any());
            Mockito.verify(svcStore, Mockito.atLeastOnce()).updatePolicy(Mockito.any());
        }
    }

    @Test
    public void testUpdateExistingOzonePolicies_updatesResourcesAndCallsUpdate() throws Exception {
        PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
        ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svcStore);

        RangerPolicy p = new RangerPolicy();
        p.setResources(new HashMap<>());
        RangerPolicy.RangerPolicyResource vol = new RangerPolicy.RangerPolicyResource();
        vol.setIsRecursive(true);
        vol.setIsExcludes(false);
        p.setResource("volume", vol);
        RangerPolicy.RangerPolicyResource key = new RangerPolicy.RangerPolicyResource();
        key.setIsRecursive(false);
        p.setResource("key", key);
        Method m = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("updateExisitngOzonePolicies",
                List.class);
        m.setAccessible(true);
        m.invoke(patch, Arrays.asList(p));
        Assertions.assertFalse(p.getResources().get("volume").getIsRecursive());
        Assertions.assertTrue(p.getResources().get("key").getIsRecursive());
        Mockito.verify(svcStore, Mockito.atLeastOnce()).updatePolicy(Mockito.any());
    }

    @Test
    public void testJsonStringToMap_withJsonString() throws Exception {
        PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
        setIfPresent(patch, "jsonUtil", new JSONUtil());
        Method m = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("jsonStringToMap", String.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        Map<String, String> map = (Map<String, String>) m.invoke(patch, "{\"x\":\"1\"}");
        Assertions.assertEquals("1", map.get("x"));
    }

    @Test
    public void testExecLoad_UpdateReturnsFalse_ExitOne() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            // Return null to force updateOzoneServiceDef() to return false
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(null);

            PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();

            SecurityManager originalSm = System.getSecurityManager();
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                patch.execLoad();
                Assertions.fail("Expected System.exit(1)");
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            } finally {
                System.setSecurityManager(originalSm);
            }
        }
    }

    @Test
    public void testExecLoad_Exception_ExitOne() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            // Force an exception inside execLoad by throwing on EmbeddedServiceDefsUtil.instance()
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenThrow(new RuntimeException("boom"));

            PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();

            SecurityManager originalSm = System.getSecurityManager();
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                patch.execLoad();
                Assertions.fail("Expected System.exit(1)");
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            } finally {
                System.setSecurityManager(originalSm);
            }
        }
    }

    @Test
    public void testMapToJsonString_success() throws Exception {
        PatchForOzoneServiceDefUpdate_J10041 patch = new PatchForOzoneServiceDefUpdate_J10041();
        setIfPresent(patch, "jsonUtil", new JSONUtil());
        Method m = PatchForOzoneServiceDefUpdate_J10041.class.getDeclaredMethod("mapToJsonString", Map.class);
        m.setAccessible(true);
        Map<String, String> map = new HashMap<>();
        map.put("k", "v");
        String s = (String) m.invoke(patch, map);
        Assertions.assertTrue(s.contains("\"k\""));
        Assertions.assertTrue(s.contains("\"v\""));
    }
}
