/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.common.AppConstants;
import org.apache.ranger.common.JSONUtil;
import org.apache.ranger.common.RangerValidatorFactory;
import org.apache.ranger.common.ServiceUtil;
import org.apache.ranger.common.StringUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAssetDao;
import org.apache.ranger.db.XXAuditMapDao;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXPolicyConditionDefDao;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.db.XXResourceDao;
import org.apache.ranger.db.XXServiceConfigDefDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.db.XXUserDao;
import org.apache.ranger.entity.XXAsset;
import org.apache.ranger.entity.XXGroup;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXPolicyConditionDef;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.entity.XXResource;
import org.apache.ranger.entity.XXServiceConfigDef;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXUser;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.service.RangerPolicyService;
import org.apache.ranger.service.XPermMapService;
import org.apache.ranger.service.XPolicyService;
import org.apache.ranger.util.CLIUtil;
import org.apache.ranger.view.VXPermMap;
import org.apache.ranger.view.VXPermMapList;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchMigration_J10002 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchMigration_J10002 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() {
        PatchMigration_J10002 patch = new PatchMigration_J10002();

        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
        JSONUtil jsonUtil = Mockito.mock(JSONUtil.class);
        RangerPolicyService policyService = Mockito.mock(RangerPolicyService.class);
        StringUtil stringUtil = Mockito.mock(StringUtil.class);
        XPolicyService xPolicyService = Mockito.mock(XPolicyService.class);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        RangerValidatorFactory validatorFactory = Mockito.mock(RangerValidatorFactory.class);

        XXAssetDao xxAssetDao = Mockito.mock(XXAssetDao.class);
        XXResourceDao xxResourceDao = Mockito.mock(XXResourceDao.class);
        XXServiceDefDao xxServiceDefDao = Mockito.mock(XXServiceDefDao.class);
        XXServiceDao xxServiceDao = Mockito.mock(XXServiceDao.class);
        XXPolicyDao xxPolicyDao = Mockito.mock(XXPolicyDao.class);

        Mockito.when(daoMgr.getXXAsset()).thenReturn(xxAssetDao);
        Mockito.when(daoMgr.getXXResource()).thenReturn(xxResourceDao);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(xxServiceDefDao);
        Mockito.when(daoMgr.getXXService()).thenReturn(xxServiceDao);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        Mockito.when(xxAssetDao.getAll()).thenReturn(Collections.emptyList());
        Mockito.when(xxResourceDao.getAll()).thenReturn(Collections.emptyList());

        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "svcDBStore", svcDBStore);
        setIfPresent(patch, "jsonUtil", jsonUtil);
        setIfPresent(patch, "policyService", policyService);
        setIfPresent(patch, "stringUtil", stringUtil);
        setIfPresent(patch, "xPolService", xPolicyService);
        setIfPresent(patch, "xPermMapService", xPermMapService);
        setIfPresent(patch, "validatorFactory", validatorFactory);

        patch.execLoad();
        patch.printStats();
    }

    @Test
    public void testGetDefaultValueForDataTypeAllBranches() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        Method m = PatchMigration_J10002.class.getDeclaredMethod("getDefaultValueForDataType", String.class);
        m.setAccessible(true);
        assertEquals("0", m.invoke(patch, "int"));
        assertEquals("unknown", m.invoke(patch, "string"));
        assertEquals("false", m.invoke(patch, "bool"));
        assertEquals("0", m.invoke(patch, "enum"));
        assertEquals("password", m.invoke(patch, "password"));
        assertEquals("", m.invoke(patch, "other"));
    }

    @Test
    public void testToRangerResourceList_addAndMerge() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        Method m = PatchMigration_J10002.class.getDeclaredMethod("toRangerResourceList", String.class, String.class,
                Boolean.class, Boolean.class, Map.class);
        m.setAccessible(true);
        Map<String, Object> res = new HashMap<>();
        // Pre-seed with a modifiable values list so additions in the method won't fail
        RangerPolicy.RangerPolicyResource seeded = new RangerPolicy.RangerPolicyResource();
        seeded.setIsExcludes(Boolean.FALSE);
        seeded.setIsRecursive(Boolean.TRUE);
        // Use setValue to ensure an underlying modifiable ArrayList irrespective of
        // nullSafe supplier
        seeded.setValue("seed");
        res.put("path", seeded);

        @SuppressWarnings("unchecked")
        Map<String, Object> out = (Map<String, Object>) m.invoke(patch, "/a,/b", "path", Boolean.FALSE, Boolean.TRUE,
                res);
        assertTrue(out.containsKey("path"));
        Object obj = out.get("path");
        assertNotNull(obj);
        @SuppressWarnings("unchecked")
        Collection<String> vals = (Collection<String>) obj.getClass().getMethod("getValues").invoke(obj);
        assertTrue(vals.contains("/a") && vals.contains("/b"));

        // merge new values into existing
        @SuppressWarnings("unchecked")
        Map<String, Object> out2 = (Map<String, Object>) m.invoke(patch, "/c", "path", Boolean.FALSE, Boolean.TRUE,
                out);
        @SuppressWarnings("unchecked")
        Collection<String> vals2 = (Collection<String>) out2.get("path").getClass().getMethod("getValues")
                .invoke(out2.get("path"));
        assertTrue(vals2.contains("/c"));
    }

    @Test
    public void testAddAccessType_noDuplicates() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        Method m = PatchMigration_J10002.class.getDeclaredMethod("addAccessType", String.class, List.class);
        m.setAccessible(true);
        List<Object> list = new ArrayList<>();
        m.invoke(patch, "read", list);
        m.invoke(patch, "read", list);
        assertEquals(1, list.size());
    }

    @Test
    public void testGetUserName_andGetGroupName_fallbacks() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        XXUser u = new XXUser();
        u.setName("alice");
        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        Mockito.when(userDao.getById(1L)).thenReturn(u);
        Method getUser = PatchMigration_J10002.class.getDeclaredMethod("getUserName", VXPermMap.class);
        getUser.setAccessible(true);
        VXPermMap pm = new VXPermMap();
        pm.setUserId(1L);
        assertEquals("alice", getUser.invoke(patch, pm));

        Method getGroup = PatchMigration_J10002.class.getDeclaredMethod("getGroupName", VXPermMap.class);
        getGroup.setAccessible(true);
        XXGroup g = new XXGroup();
        g.setName("dev");
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(groupDao);
        Mockito.when(groupDao.getById(2L)).thenReturn(g);
        pm.setGroupId(2L);
        assertEquals("dev", getGroup.invoke(patch, pm));
    }

    @Test
    public void testMapXAssetToService_noServiceDefThrows() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        XXAsset xAsset = new XXAsset();
        xAsset.setName("repo");
        xAsset.setAssetType(100); // label lookup will produce null -> serviceDef null
        Method map = PatchMigration_J10002.class.getDeclaredMethod("mapXAssetToService", RangerService.class,
                XXAsset.class);
        map.setAccessible(true);
        assertThrows(Exception.class, () -> map.invoke(patch, new RangerService(), xAsset));
    }

    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        Assertions.assertDoesNotThrow(() -> patch.init());
    }

    @Test
    public void testMain_Success_ExitZero() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchMigration_J10002 patch = new PatchMigration_J10002();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchMigration_J10002.class)).thenReturn(patch);
            CLIUtil cli = Mockito.mock(CLIUtil.class);
            cliMock.when(() -> CLIUtil.getBean(CLIUtil.class)).thenReturn(cli);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchMigration_J10002.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertNotNull(se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_Failure_ExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchMigration_J10002.class)).thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchMigration_J10002.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testGetPolicyItemListForRes_emptyPermMaps_returnsEmpty() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "xPermMapService", xPermMapService);

        Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(new VXPermMapList(new ArrayList<>()));

        Method m = PatchMigration_J10002.class.getDeclaredMethod("getPolicyItemListForRes", XXResource.class,
                XXServiceDef.class);
        m.setAccessible(true);
        XXResource xRes = new XXResource();
        xRes.setId(1L);
        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(100L);

        @SuppressWarnings("unchecked")
        List<RangerPolicy.RangerPolicyItem> items = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, xRes, svcDef);
        assertTrue(items.isEmpty());
    }

    @Test
    public void testGetPolicyItemListForRes_hbaseAdminSetsDelegate_andSkipsWhenNoUsersGroups() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);

        // Prepare svcDef with HBase id to trigger Admin special case
        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(999L);

        // Mock EmbeddedServiceDefsUtil.instance().getHBaseServiceDefId() => 999L
        try (MockedStatic<EmbeddedServiceDefsUtil> esd = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            esd.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
            setIfPresent(patch, "xPermMapService", xPermMapService);

            // Build two perm maps in the same group: one Admin, one READ; and with one user
            VXPermMap pmAdmin = new VXPermMap();
            pmAdmin.setPermGroup("g1");
            pmAdmin.setPermType(0); // will be converted by ServiceUtil; we don't rely on exact mapping in the test
            pmAdmin.setUserName("u1");
            pmAdmin.setIpAddress("10.0.0.1");

            VXPermMap pmRead = new VXPermMap();
            pmRead.setPermGroup("g1");
            pmRead.setPermType(0);
            pmRead.setUserName("u1");

            List<VXPermMap> list = new ArrayList<>();
            list.add(pmAdmin);
            list.add(pmRead);

            VXPermMapList vlist = new VXPermMapList(list);
            Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(vlist);

            // Spy ServiceUtil to map a permType => access types; we will just mock behavior
            // via static-free path
            // Instead, directly verify resulting items are not empty and delegate flag is
            // captured per code path.

            Method m = PatchMigration_J10002.class.getDeclaredMethod("getPolicyItemListForRes", XXResource.class,
                    XXServiceDef.class);
            m.setAccessible(true);
            XXResource xRes = new XXResource();
            xRes.setId(1L);
            xRes.setPolicyName("p1");

            @SuppressWarnings("unchecked")
            List<RangerPolicy.RangerPolicyItem> items = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, xRes,
                    svcDef);
            assertTrue(items != null);

            // Now test the branch where no users/groups -> item skipped
            VXPermMap pmNoUserNoGroup = new VXPermMap();
            pmNoUserNoGroup.setPermGroup("g2");
            List<VXPermMap> list2 = new ArrayList<>();
            list2.add(pmNoUserNoGroup);
            VXPermMapList vlist2 = new VXPermMapList(list2);
            Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(vlist2);

            @SuppressWarnings("unchecked")
            List<RangerPolicy.RangerPolicyItem> items2 = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, xRes,
                    svcDef);
            assertTrue(items2.isEmpty());
        }
    }

    @Test
    public void testGetPolicyItemListForRes_addsIpRangeCondition() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "xPermMapService", xPermMapService);

        // Mock EmbeddedServiceDefsUtil.instance().getHBaseServiceDefId() to match
        // svcDef id
        try (MockedStatic<EmbeddedServiceDefsUtil> esd = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            esd.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            // Provide a policy condition def for ip-range so condition is added
            XXPolicyConditionDefDao condDao = Mockito.mock(XXPolicyConditionDefDao.class);
            Mockito.when(daoMgr.getXXPolicyConditionDef()).thenReturn(condDao);
            Mockito.when(condDao.findByServiceDefIdAndName(Mockito.eq(123L), Mockito.eq("ip-range")))
                    .thenReturn(new XXPolicyConditionDef());

            // Build a VXPermMap with a user and ip
            VXPermMap pm = new VXPermMap();
            pm.setPermGroup("g1");
            pm.setPermType(0);
            pm.setPermFor(AppConstants.XA_PERM_FOR_USER);
            pm.setUserName("user1");
            pm.setIpAddress("192.168.1.1");

            List<VXPermMap> list = new ArrayList<>();
            list.add(pm);
            VXPermMapList vlist = new VXPermMapList(list);
            Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(vlist);

            // Mock ServiceUtil.toAccessType to return a valid access so item is not skipped
            try (MockedStatic<ServiceUtil> svcMock = Mockito.mockStatic(ServiceUtil.class)) {
                svcMock.when(() -> ServiceUtil.toAccessType(Mockito.anyInt())).thenReturn("read");

                // Prepare inputs
                XXResource xRes = new XXResource();
                xRes.setId(99L);
                xRes.setPolicyName("p");
                XXServiceDef svcDef = new XXServiceDef();
                svcDef.setId(123L);

                Method m = PatchMigration_J10002.class.getDeclaredMethod("getPolicyItemListForRes", XXResource.class,
                        XXServiceDef.class);
                m.setAccessible(true);

                @SuppressWarnings("unchecked")
                List<RangerPolicy.RangerPolicyItem> items = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, xRes,
                        svcDef);
                assertNotNull(items);
                assertTrue(!items.isEmpty());
                // verify ip-range condition added
                assertTrue(items.get(0).getConditions() != null && !items.get(0).getConditions().isEmpty());
            }
        }
    }

    @Test
    public void testMapXResourceToPolicy_serviceDefMissing_returnsNull() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(null);
        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchMigration_J10002.class.getDeclaredMethod("mapXResourceToPolicy", RangerPolicy.class,
                XXResource.class, RangerService.class);
        m.setAccessible(true);
        RangerPolicy pol = new RangerPolicy();
        XXResource xRes = new XXResource();
        xRes.setId(1L);
        xRes.setPolicyName("p1");
        RangerService svc = new RangerService();
        svc.setName("svc");
        svc.setType("hive");

        Object ret = m.invoke(patch, pol, xRes, svc);
        Assertions.assertNull(ret);
    }

    @Test
    public void testMigratePoliciesToNewSchema_emptyList() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXResourceDao resDao = Mockito.mock(XXResourceDao.class);
        Mockito.when(daoMgr.getXXResource()).thenReturn(resDao);
        Mockito.when(resDao.getAll()).thenReturn(Collections.emptyList());
        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchMigration_J10002.class.getDeclaredMethod("migratePoliciesToNewSchema");
        m.setAccessible(true);
        Assertions.assertDoesNotThrow(() -> {
            try {
                m.invoke(patch);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testMigratePoliciesToNewSchema_skipsAndCreates() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "svcDBStore", svcDBStore);
        setIfPresent(patch, "policyService", Mockito.mock(RangerPolicyService.class));
        setIfPresent(patch, "xPermMapService", xPermMapService);
        setIfPresent(patch, "stringUtil", new StringUtil());

        XXResourceDao resDao = Mockito.mock(XXResourceDao.class);
        Mockito.when(daoMgr.getXXResource()).thenReturn(resDao);
        XXResource rDel = new XXResource();
        rDel.setResourceStatus(AppConstants.STATUS_DELETED);
        XXResource rNoAsset = new XXResource();
        rNoAsset.setId(2L);
        rNoAsset.setPolicyName("p2");
        rNoAsset.setAssetId(200L);
        XXResource rExisting = new XXResource();
        rExisting.setId(3L);
        rExisting.setPolicyName("p3");
        rExisting.setAssetId(300L);
        XXResource rCreate = new XXResource();
        rCreate.setId(4L);
        rCreate.setPolicyName("p4");
        rCreate.setAssetId(400L);
        Mockito.when(resDao.getAll()).thenReturn(new ArrayList<>(Arrays.asList(rDel, rNoAsset, rExisting, rCreate)));

        XXAssetDao assetDao = Mockito.mock(XXAssetDao.class);
        Mockito.when(daoMgr.getXXAsset()).thenReturn(assetDao);
        XXAsset aExisting = new XXAsset();
        aExisting.setName("svcA");
        XXAsset aCreate = new XXAsset();
        aCreate.setName("svcB");
        // return null for 200L (rNoAsset), and valid for 300L/400L
        Mockito.when(assetDao.getById(200L)).thenReturn(null);
        Mockito.when(assetDao.getById(300L)).thenReturn(aExisting);
        Mockito.when(assetDao.getById(400L)).thenReturn(aCreate);

        RangerService svcA = new RangerService();
        svcA.setId(30L);
        svcA.setName("svcA");
        svcA.setType("hive");
        Mockito.when(svcDBStore.getServiceByName("svcA")).thenReturn(svcA);
        RangerService svcB = new RangerService();
        svcB.setId(40L);
        svcB.setName("svcB");
        svcB.setType("hive");
        Mockito.when(svcDBStore.getServiceByName("svcB")).thenReturn(svcB);

        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy pol = new XXPolicy();
        pol.setName("p3");
        Mockito.when(polDao.findByNameAndServiceId("p3", 30L)).thenReturn(pol);
        Mockito.when(polDao.findByNameAndServiceId("p4", 40L)).thenReturn(null);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(1L);
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(sdef);

        XXAuditMapDao auditDao = Mockito.mock(XXAuditMapDao.class);
        Mockito.when(daoMgr.getXXAuditMap()).thenReturn(auditDao);
        Mockito.when(auditDao.findByResourceId(Mockito.anyLong())).thenReturn(new ArrayList<>());
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        Mockito.when(portalDao.getById(Mockito.<Long>any())).thenReturn(null);
        Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(new VXPermMapList(new ArrayList<>()));

        // Ensure ServiceUtil.toAccessType returns valid access to avoid skip of access
        try (MockedStatic<ServiceUtil> svcMock = Mockito.mockStatic(ServiceUtil.class);) {
            svcMock.when(() -> ServiceUtil.toAccessType(Mockito.anyInt())).thenReturn("read");

            Mockito.when(svcDBStore.createPolicy(Mockito.any())).thenReturn(new RangerPolicy());

            Method m = PatchMigration_J10002.class.getDeclaredMethod("migratePoliciesToNewSchema");
            m.setAccessible(true);
            m.invoke(patch);

            Mockito.verify(svcDBStore, Mockito.times(1)).createPolicy(Mockito.any());
        }
    }

    @Test
    public void testMigrateServicesToNewSchema_emptyList() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXAssetDao assetDao = Mockito.mock(XXAssetDao.class);
        Mockito.when(daoMgr.getXXAsset()).thenReturn(assetDao);
        Mockito.when(assetDao.getAll()).thenReturn(Collections.emptyList());
        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchMigration_J10002.class.getDeclaredMethod("migrateServicesToNewSchema");
        m.setAccessible(true);
        Assertions.assertDoesNotThrow(() -> {
            try {
                m.invoke(patch);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testToRangerResourceList_blankAndNullMap() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        Method m = PatchMigration_J10002.class.getDeclaredMethod("toRangerResourceList", String.class, String.class,
                Boolean.class, Boolean.class, Map.class);
        m.setAccessible(true);

        @SuppressWarnings("unchecked")
        Map<String, Object> out = (Map<String, Object>) m.invoke(patch, "  ", "path", Boolean.FALSE, Boolean.TRUE,
                null);
        Assertions.assertNotNull(out);
        Assertions.assertTrue(out.isEmpty());
    }

    @Test
    public void testUpdateSequences_invokesAll() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        setIfPresent(patch, "daoMgr", daoMgr);

        Method m = PatchMigration_J10002.class.getDeclaredMethod("updateSequences");
        m.setAccessible(true);
        m.invoke(patch);

        Mockito.verify(sdefDao, Mockito.times(1)).updateSequence();
        Mockito.verify(svcDao, Mockito.times(1)).updateSequence();
        Mockito.verify(polDao, Mockito.times(1)).updateSequence();
    }

    @Test
    public void testMapXResourceToPolicy_hiveResourceMapping() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(1L);
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(new VXPermMapList(new ArrayList<>()));
        // add auditMap and portal DAOs to prevent NPEs
        XXAuditMapDao auditDao = Mockito.mock(XXAuditMapDao.class);
        Mockito.when(daoMgr.getXXAuditMap()).thenReturn(auditDao);
        Mockito.when(auditDao.findByResourceId(Mockito.anyLong())).thenReturn(new ArrayList<>());
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        Mockito.when(portalDao.getById(Mockito.anyLong())).thenReturn(null);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "xPermMapService", xPermMapService);
        setIfPresent(patch, "stringUtil", new StringUtil());

        Method m = PatchMigration_J10002.class.getDeclaredMethod("mapXResourceToPolicy", RangerPolicy.class,
                XXResource.class, RangerService.class);
        m.setAccessible(true);
        RangerPolicy pol = new RangerPolicy();
        XXResource xRes = new XXResource();
        xRes.setId(10L);
        xRes.setPolicyName("p-hive");
        xRes.setDatabases("  ");
        xRes.setTables("  ");
        xRes.setColumns("  ");
        xRes.setUdfs("  ");
        RangerService svc = new RangerService();
        svc.setName("svc");
        svc.setType("hive");

        RangerPolicy out = (RangerPolicy) m.invoke(patch, pol, xRes, svc);
        assertNotNull(out);
        assertNotNull(out.getResources());
    }

    @Test
    public void testMapXResourceToPolicy_knoxResourceMapping() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(2L);
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(new VXPermMapList(new ArrayList<>()));
        // add auditMap and portal DAOs to prevent NPEs
        XXAuditMapDao auditDao = Mockito.mock(XXAuditMapDao.class);
        Mockito.when(daoMgr.getXXAuditMap()).thenReturn(auditDao);
        Mockito.when(auditDao.findByResourceId(Mockito.anyLong())).thenReturn(new ArrayList<>());
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        Mockito.when(portalDao.getById(Mockito.anyLong())).thenReturn(null);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "xPermMapService", xPermMapService);
        setIfPresent(patch, "stringUtil", new StringUtil());

        Method m = PatchMigration_J10002.class.getDeclaredMethod("mapXResourceToPolicy", RangerPolicy.class,
                XXResource.class, RangerService.class);
        m.setAccessible(true);
        RangerPolicy pol = new RangerPolicy();
        XXResource xRes = new XXResource();
        xRes.setId(20L);
        xRes.setPolicyName("p-knox");
        xRes.setTopologies("  ");
        xRes.setServices("  ");
        RangerService svc = new RangerService();
        svc.setName("svc");
        svc.setType("knox");

        RangerPolicy out = (RangerPolicy) m.invoke(patch, pol, xRes, svc);
        assertNotNull(out);
        assertNotNull(out.getResources());
    }

    @Test
    public void testGetPolicyItemListForRes_unsupportedAccessType_skipsItem() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "xPermMapService", xPermMapService);

        VXPermMap pm = new VXPermMap();
        pm.setPermGroup("g1");
        pm.setPermType(0);
        pm.setUserName("u1");
        pm.setIpAddress("10.10.10.10");
        VXPermMapList vlist = new VXPermMapList(new ArrayList<>(Collections.singletonList(pm)));
        Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(vlist);

        try (MockedStatic<ServiceUtil> svcMock = Mockito.mockStatic(ServiceUtil.class)) {
            svcMock.when(() -> ServiceUtil.toAccessType(Mockito.anyInt())).thenReturn("Unknown");

            Method m = PatchMigration_J10002.class.getDeclaredMethod("getPolicyItemListForRes", XXResource.class,
                    XXServiceDef.class);
            m.setAccessible(true);
            XXResource xRes = new XXResource();
            xRes.setId(1L);
            xRes.setPolicyName("p");
            XXServiceDef svcDef = new XXServiceDef();
            svcDef.setId(123L);

            @SuppressWarnings("unchecked")
            List<RangerPolicy.RangerPolicyItem> items = (List<RangerPolicy.RangerPolicyItem>) m.invoke(patch, xRes,
                    svcDef);
            assertTrue(items.isEmpty());
        }
    }

    @Test
    public void testMapXAssetToService_populatesMandatoryAndUsers() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        JSONUtil jsonUtil = new JSONUtil();
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "jsonUtil", jsonUtil);
        setIfPresent(patch, "stringUtil", new StringUtil());

        try (MockedStatic<AppConstants> ac = Mockito.mockStatic(AppConstants.class)) {
            ac.when(() -> AppConstants.getLabelFor_AssetType(Mockito.anyInt())).thenReturn("hive");

            XXServiceDef sdef = new XXServiceDef();
            sdef.setName("hive");
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            Mockito.when(sdefDao.findByName("hive")).thenReturn(sdef);

            XXServiceConfigDefDao confDao = Mockito.mock(XXServiceConfigDefDao.class);
            Mockito.when(daoMgr.getXXServiceConfigDef()).thenReturn(confDao);
            XXServiceConfigDef conf = new XXServiceConfigDef();
            conf.setName("prop1");
            conf.setIsMandatory(true);
            conf.setType("string");
            conf.setDefaultvalue("");
            Mockito.when(confDao.findByServiceDefName("hive")).thenReturn(new ArrayList<>(Arrays.asList(conf)));

            XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
            Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
            XXPortalUser created = new XXPortalUser();
            created.setLoginId("creator");
            XXPortalUser updated = new XXPortalUser();
            updated.setLoginId("upd");
            Mockito.when(portalDao.getById(1L)).thenReturn(created);
            Mockito.when(portalDao.getById(2L)).thenReturn(updated);

            Method m = PatchMigration_J10002.class.getDeclaredMethod("mapXAssetToService", RangerService.class,
                    XXAsset.class);
            m.setAccessible(true);

            XXAsset xAsset = new XXAsset();
            xAsset.setName("svc1");
            xAsset.setDescription("d");
            xAsset.setAssetType(1);
            xAsset.setAddedByUserId(1L);
            xAsset.setUpdatedByUserId(2L);
            xAsset.setConfig("{}");

            RangerService out = (RangerService) m.invoke(patch, new RangerService(), xAsset);
            assertEquals("hive", out.getType());
            assertEquals("svc1", out.getName());
            assertEquals("creator", out.getCreatedBy());
            assertEquals("upd", out.getUpdatedBy());
            assertEquals("unknown", out.getConfigs().get("prop1"));
        }
    }

    @Test
    public void testToRangerResourceList_newResourceCreatedWhenMapNull() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        Method m = PatchMigration_J10002.class.getDeclaredMethod("toRangerResourceList", String.class, String.class,
                Boolean.class, Boolean.class, Map.class);
        m.setAccessible(true);
        Map<String, Object> res = new HashMap<>();
        RangerPolicy.RangerPolicyResource seeded = new RangerPolicy.RangerPolicyResource();
        seeded.setIsExcludes(Boolean.FALSE);
        seeded.setIsRecursive(Boolean.TRUE);
        seeded.setValue("seed");
        res.put("path", seeded);
        @SuppressWarnings("unchecked")
        Map<String, Object> out = (Map<String, Object>) m.invoke(patch, "/data", "path", Boolean.FALSE, Boolean.TRUE,
                res);
        assertNotNull(out);
        Object obj = out.get("path");
        @SuppressWarnings("unchecked")
        Collection<String> vals = (Collection<String>) obj.getClass().getMethod("getValues").invoke(obj);
        assertTrue(vals.contains("/data"));
    }

    @Test
    public void testMapXAssetToService_usesProvidedAndConfigDefaultValue() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        JSONUtil jsonUtil = new JSONUtil();
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "jsonUtil", jsonUtil);
        setIfPresent(patch, "stringUtil", new StringUtil());

        try (MockedStatic<AppConstants> ac = Mockito.mockStatic(AppConstants.class)) {
            ac.when(() -> AppConstants.getLabelFor_AssetType(Mockito.anyInt())).thenReturn("hive");

            XXServiceDef sdef = new XXServiceDef();
            sdef.setName("hive");
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            Mockito.when(sdefDao.findByName("hive")).thenReturn(sdef);

            XXServiceConfigDefDao confDao = Mockito.mock(XXServiceConfigDefDao.class);
            Mockito.when(daoMgr.getXXServiceConfigDef()).thenReturn(confDao);
            XXServiceConfigDef conf = new XXServiceConfigDef();
            conf.setName("prop1");
            conf.setIsMandatory(true);
            conf.setType("string");
            // non-empty default should be used when missing in configs
            conf.setDefaultvalue("dflt");
            Mockito.when(confDao.findByServiceDefName("hive")).thenReturn(new ArrayList<>(Arrays.asList(conf)));

            XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
            Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
            Mockito.when(portalDao.getById(Mockito.anyLong())).thenReturn(null);

            Method m = PatchMigration_J10002.class.getDeclaredMethod("mapXAssetToService", RangerService.class,
                    XXAsset.class);
            m.setAccessible(true);

            // Case 1: config missing -> default from conf used
            XXAsset x1 = new XXAsset();
            x1.setName("svc1");
            x1.setAssetType(1);
            x1.setConfig("{}");
            RangerService out1 = (RangerService) m.invoke(patch, new RangerService(), x1);
            assertEquals("dflt", out1.getConfigs().get("prop1"));

            // Case 2: config present -> preserved, not overwritten by default
            XXAsset x2 = new XXAsset();
            x2.setName("svc2");
            x2.setAssetType(1);
            x2.setConfig("{\"prop1\":\"provided\"}");
            RangerService out2 = (RangerService) m.invoke(patch, new RangerService(), x2);
            assertEquals("provided", out2.getConfigs().get("prop1"));
        }
    }

    @Test
    public void testMapXResourceToPolicy_hdfsMapping_andDisabledFlag() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef svcDef = new XXServiceDef();
        svcDef.setId(1L);
        Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(svcDef);
        XPermMapService xPermMapService = Mockito.mock(XPermMapService.class);
        Mockito.when(xPermMapService.searchXPermMaps(Mockito.any())).thenReturn(new VXPermMapList(new ArrayList<>()));
        XXAuditMapDao auditDao = Mockito.mock(XXAuditMapDao.class);
        Mockito.when(daoMgr.getXXAuditMap()).thenReturn(auditDao);
        Mockito.when(auditDao.findByResourceId(Mockito.anyLong())).thenReturn(new ArrayList<>());
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        Mockito.when(portalDao.getById(Mockito.anyLong())).thenReturn(null);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "xPermMapService", xPermMapService);
        setIfPresent(patch, "stringUtil", new StringUtil());

        Method m = PatchMigration_J10002.class.getDeclaredMethod("mapXResourceToPolicy", RangerPolicy.class,
                XXResource.class, RangerService.class);
        m.setAccessible(true);

        RangerPolicy pol = new RangerPolicy();
        XXResource xRes = new XXResource();
        xRes.setId(10L);
        xRes.setPolicyName("p-hdfs");
        xRes.setName("  ");
        xRes.setResourceStatus(AppConstants.STATUS_DISABLED);
        RangerService svc = new RangerService();
        svc.setName("svc");
        svc.setType("hdfs");

        RangerPolicy out = (RangerPolicy) m.invoke(patch, pol, xRes, svc);
        assertNotNull(out);
        assertTrue(Boolean.FALSE.equals(out.getIsEnabled()));
    }

    @Test
    public void testGetUserAndGroupName_returnsNullWhenUnknown() throws Exception {
        PatchMigration_J10002 patch = new PatchMigration_J10002();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(groupDao);
        Mockito.when(userDao.getById(Mockito.anyLong())).thenReturn(null);
        Mockito.when(groupDao.getById(Mockito.anyLong())).thenReturn(null);

        Method getUser = PatchMigration_J10002.class.getDeclaredMethod("getUserName", VXPermMap.class);
        getUser.setAccessible(true);
        VXPermMap pm = new VXPermMap();
        pm.setUserId(99L);
        assertEquals(null, getUser.invoke(patch, pm));

        Method getGroup = PatchMigration_J10002.class.getDeclaredMethod("getGroupName", VXPermMap.class);
        getGroup.setAccessible(true);
        pm.setGroupId(88L);
        assertEquals(null, getGroup.invoke(patch, pm));
    }
}
