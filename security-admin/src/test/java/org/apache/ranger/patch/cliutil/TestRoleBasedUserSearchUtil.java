/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.patch.cliutil;

import org.apache.ranger.biz.UserMgr;
import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.common.RangerConstants;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXModuleDefDao;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.service.XUserService;
import org.apache.ranger.view.VXUser;
import org.apache.ranger.view.VXUserList;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.security.Permission;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.fail;

/**
 * @generated by Cursor
 * @description <Unit Test for RoleBasedUserSearchUtil class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRoleBasedUserSearchUtil {
    @Mock
    XUserService xUserService;

    @Mock
    RangerDaoManager daoMgr;

    @Mock
    UserMgr userMgr;

    @Mock
    XUserMgr xUserMgr;
    @Mock
    XXPortalUserDao xXPortalUserDao;

    @InjectMocks
    RoleBasedUserSearchUtil roleBasedUserSearchUtil = new RoleBasedUserSearchUtil();

    public TestRoleBasedUserSearchUtil() {
    }

    @Test
    public void testGetUsersBasedOnRole() {
        try {
            XXPortalUser xXPortalUser = new XXPortalUser();
            xXPortalUser.setLoginId("testUser");
            xXPortalUser.setId(1L);
            xXPortalUser.setFirstName("testUser");
            xXPortalUser.setPublicScreenName("testUser");
            xXPortalUser.setPassword("testUserPassword");
            List<XXPortalUser> listXXPortalUser = new ArrayList<>();
            listXXPortalUser.add(xXPortalUser);
            List<String> userRoleList = new ArrayList<>();
            userRoleList.add("ROLE_SYS_ADMIN");

            Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
            Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_SYS_ADMIN)).thenReturn(listXXPortalUser);

            roleBasedUserSearchUtil.getUsersBasedOnRole(userRoleList);

            Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_SYS_ADMIN);
        } catch (Exception e) {
            fail("test failed due to: " + e.getMessage());
        }
    }

    @Test
    public void testGetUsersBasedOnRole_emptyMaps_exits() {
        List<String> userRoleList = new ArrayList<>();
        userRoleList.add(RangerConstants.ROLE_USER);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_USER)).thenReturn(new ArrayList<>());

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                roleBasedUserSearchUtil.getUsersBasedOnRole(userRoleList);
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }

        Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_USER);
    }

    @Test
    public void testValidateUserAndFetchUserList() {
        RoleBasedUserSearchUtil.checkRole = true;
        RoleBasedUserSearchUtil.userRole = "";

        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        String currentEncryptedPassword = "testpassword";
        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);
        xxPortalUser.setLoginId("testUser");
        xxPortalUser.setPassword("testpassword");
        xxPortalUser.setFirstName("testUser");
        VXUser vxUser = new VXUser();
        vxUser.setId(1L);
        VXUserList vXUserList = new VXUserList();
        List<VXUser> vXUsers = new ArrayList<>();
        vXUsers.add(vxUser);
        vXUserList.setVXUsers(vXUsers);

        List<String> userRoleList = new ArrayList<>();
        userRoleList.add("ROLE_SYS_ADMIN");
        List<XXPortalUser> listXXPortalUser = new ArrayList<>();
        listXXPortalUser.add(xxPortalUser);
        vxUser.setUserRoleList(userRoleList);
        XXModuleDefDao xXModuleDefDao = Mockito.mock(XXModuleDefDao.class);

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId(Mockito.anyString())).thenReturn(xxPortalUser);
        Mockito.when(xUserService.getXUserByUserName(xxPortalUser.getLoginId())).thenReturn(vxUser);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(xXModuleDefDao);
        Mockito.when(xXModuleDefDao.findAccessibleModulesByUserId(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(permissionList);
        Mockito.when(userMgr.encrypt(Mockito.anyString(), Mockito.anyString())).thenReturn(currentEncryptedPassword);
        Mockito.when(xXPortalUserDao.findByRole(Mockito.anyString())).thenReturn(listXXPortalUser);

        roleBasedUserSearchUtil.validateUserAndFetchUserList();

        Mockito.verify(xXPortalUserDao).findByLoginId(Mockito.anyString());
        Mockito.verify(xUserService).getXUserByUserName(xxPortalUser.getLoginId());

        Mockito.verify(xXModuleDefDao).findAccessibleModulesByUserId(Mockito.anyLong(), Mockito.anyLong());
        Mockito.verify(userMgr).encrypt(Mockito.anyString(), Mockito.anyString());
        Mockito.verify(xXPortalUserDao, Mockito.atLeast(2)).findByRole(Mockito.anyString());
    }

    @Test
    public void testPrintStats() {
        roleBasedUserSearchUtil.printStats();
    }

    @Test
    public void testInit() throws Exception {
        roleBasedUserSearchUtil.init();
    }

    @Test
    public void testExecLoad_callsValidateUserAndFetchUserList() {
        RoleBasedUserSearchUtil spy = Mockito.spy(roleBasedUserSearchUtil);
        Mockito.doNothing().when(spy).validateUserAndFetchUserList();
        spy.execLoad();
        Mockito.verify(spy).validateUserAndFetchUserList();
    }

    @Test
    public void testMain_incorrectArgs_exits() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                RoleBasedUserSearchUtil.main(new String[] {"onlyOne"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_invalidRole_exits() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                RoleBasedUserSearchUtil.main(new String[] {"u", "p", "not_a_role"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_blankLogin_exits() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                RoleBasedUserSearchUtil.main(new String[] {"", "p"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidateUserAndFetchUserList_userNotFound_exits() {
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId(Mockito.anyString())).thenReturn(null);

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                roleBasedUserSearchUtil.validateUserAndFetchUserList();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidateUserAndFetchUserList_invalidPassword_exits() {
        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);
        xxPortalUser.setLoginId("testUser");
        xxPortalUser.setPassword("enc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId(Mockito.anyString())).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt(Mockito.anyString(), Mockito.anyString())).thenReturn("other");

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                roleBasedUserSearchUtil.validateUserAndFetchUserList();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidateUserAndFetchUserList_permissionDenied_exits() {
        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);
        xxPortalUser.setLoginId("testUser");
        xxPortalUser.setPassword("enc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId(Mockito.anyString())).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt(Mockito.anyString(), Mockito.anyString())).thenReturn("enc");
        VXUser vxUser = new VXUser();
        vxUser.setId(10L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_USER);
        vxUser.setUserRoleList(roles);
        XUserService xUserServiceMock = Mockito.mock(XUserService.class);
        roleBasedUserSearchUtil.xUserService = xUserServiceMock;
        Mockito.when(xUserServiceMock.getXUserByUserName(Mockito.anyString())).thenReturn(vxUser);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(Mockito.mock(XXModuleDefDao.class));
        Mockito.when(daoMgr.getXXModuleDef().findAccessibleModulesByUserId(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(new ArrayList<>());

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                roleBasedUserSearchUtil.validateUserAndFetchUserList();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidateUserAndFetchUserList_notAuthorized_exits() {
        // existing role: ROLE_USER, requested role: ROLE_KEY_ADMIN with checkRole=false
        RoleBasedUserSearchUtil.userRole = RangerConstants.ROLE_KEY_ADMIN;
        RoleBasedUserSearchUtil.checkRole = false;

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(1L);
        xxPortalUser.setLoginId("testUser");
        xxPortalUser.setPassword("enc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId(Mockito.anyString())).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt(Mockito.anyString(), Mockito.anyString())).thenReturn("enc");
        VXUser vxUser = new VXUser();
        vxUser.setId(10L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_USER);
        vxUser.setUserRoleList(roles);
        XUserService xUserServiceMock = Mockito.mock(XUserService.class);
        roleBasedUserSearchUtil.xUserService = xUserServiceMock;
        Mockito.when(xUserServiceMock.getXUserByUserName(Mockito.anyString())).thenReturn(vxUser);
        XXModuleDefDao moduleDao = Mockito.mock(XXModuleDefDao.class);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(moduleDao);
        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        Mockito.when(moduleDao.findAccessibleModulesByUserId(Mockito.anyLong(), Mockito.anyLong()))
                .thenReturn(permissionList);

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                roleBasedUserSearchUtil.validateUserAndFetchUserList();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_blankCurrent_exits() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                RoleBasedUserSearchUtil.main(new String[] {"u", ""});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidateUserAndFetchUserList_keyAdmin_checkRoleFalse_authorized() {
        RoleBasedUserSearchUtil.userRole = RangerConstants.ROLE_KEY_ADMIN;
        RoleBasedUserSearchUtil.checkRole = false;
        RoleBasedUserSearchUtil.userLoginId = "ka";
        RoleBasedUserSearchUtil.currentPassword = "p";

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(5L);
        xxPortalUser.setLoginId("ka");
        xxPortalUser.setPassword("enc");

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("ka")).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt("ka", "p")).thenReturn("enc");

        VXUser vxUser = new VXUser();
        vxUser.setId(55L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_KEY_ADMIN);
        vxUser.setUserRoleList(roles);
        Mockito.when(xUserService.getXUserByUserName("ka")).thenReturn(vxUser);

        XXModuleDefDao xXModuleDefDao = Mockito.mock(XXModuleDefDao.class);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(xXModuleDefDao);
        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        Mockito.when(xXModuleDefDao.findAccessibleModulesByUserId(5L, 55L)).thenReturn(permissionList);

        RoleBasedUserSearchUtil spy = Mockito.spy(roleBasedUserSearchUtil);
        Mockito.doNothing().when(spy).getUsersBasedOnRole(Mockito.anyList());

        spy.validateUserAndFetchUserList();

        Mockito.verify(spy).getUsersBasedOnRole(
                Mockito.argThat(list -> list.size() == 1 && RangerConstants.ROLE_KEY_ADMIN.equals(list.get(0))));
    }

    @Test
    public void testMain_validArgs_twoParams_runs() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                RoleBasedUserSearchUtil.main(new String[] {"u", "p"});
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_validArgs_threeParams_validRole_runs() {
        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                RoleBasedUserSearchUtil.main(new String[] {"u", "p", RangerConstants.ROLE_USER });
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testValidateUserAndFetchUserList_roleUser_checkRoleTrue_invokesGetUsersBasedOnRole() {
        RoleBasedUserSearchUtil.checkRole = true;
        RoleBasedUserSearchUtil.userLoginId = "user1";
        RoleBasedUserSearchUtil.currentPassword = "p";

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(11L);
        xxPortalUser.setLoginId("user1");
        xxPortalUser.setPassword("enc");

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("user1")).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt("user1", "p")).thenReturn("enc");

        VXUser vxUser = new VXUser();
        vxUser.setId(21L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_USER);
        vxUser.setUserRoleList(roles);
        Mockito.when(xUserService.getXUserByUserName("user1")).thenReturn(vxUser);

        XXModuleDefDao xXModuleDefDao = Mockito.mock(XXModuleDefDao.class);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(xXModuleDefDao);
        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        Mockito.when(xXModuleDefDao.findAccessibleModulesByUserId(11L, 21L)).thenReturn(permissionList);

        RoleBasedUserSearchUtil spy = Mockito.spy(roleBasedUserSearchUtil);
        Mockito.doNothing().when(spy).getUsersBasedOnRole(Mockito.anyList());

        spy.validateUserAndFetchUserList();

        Mockito.verify(spy).getUsersBasedOnRole(
                Mockito.argThat(list -> list.size() == 1 && RangerConstants.ROLE_USER.equals(list.get(0))));
    }

    @Test
    public void testValidateUserAndFetchUserList_roleSysAdmin_checkRoleTrue_invokesGetUsersBasedOnRoleWithThreeRoles() {
        RoleBasedUserSearchUtil.checkRole = true;
        RoleBasedUserSearchUtil.userLoginId = "admin1";
        RoleBasedUserSearchUtil.currentPassword = "p";

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(31L);
        xxPortalUser.setLoginId("admin1");
        xxPortalUser.setPassword("enc");

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("admin1")).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt("admin1", "p")).thenReturn("enc");

        VXUser vxUser = new VXUser();
        vxUser.setId(41L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_SYS_ADMIN);
        vxUser.setUserRoleList(roles);
        Mockito.when(xUserService.getXUserByUserName("admin1")).thenReturn(vxUser);

        XXModuleDefDao xXModuleDefDao = Mockito.mock(XXModuleDefDao.class);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(xXModuleDefDao);
        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        Mockito.when(xXModuleDefDao.findAccessibleModulesByUserId(31L, 41L)).thenReturn(permissionList);

        RoleBasedUserSearchUtil spy = Mockito.spy(roleBasedUserSearchUtil);
        Mockito.doNothing().when(spy).getUsersBasedOnRole(Mockito.anyList());

        spy.validateUserAndFetchUserList();

        Mockito.verify(spy).getUsersBasedOnRole(Mockito.argThat(list -> list.size() == 3
                && list.contains(RangerConstants.ROLE_SYS_ADMIN) && list.contains(RangerConstants.ROLE_ADMIN_AUDITOR)
                && list.contains(RangerConstants.ROLE_USER)));
    }

    @Test
    public void testValidateUserAndFetchUserList_adminAuditor_checkRoleFalse_requestedSame_invokesGetUsersBasedOnRole() {
        RoleBasedUserSearchUtil.userRole = RangerConstants.ROLE_ADMIN_AUDITOR;
        RoleBasedUserSearchUtil.checkRole = false;
        RoleBasedUserSearchUtil.userLoginId = "aud";
        RoleBasedUserSearchUtil.currentPassword = "p";

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(61L);
        xxPortalUser.setLoginId("aud");
        xxPortalUser.setPassword("enc");

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("aud")).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt("aud", "p")).thenReturn("enc");

        VXUser vxUser = new VXUser();
        vxUser.setId(71L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_ADMIN_AUDITOR);
        vxUser.setUserRoleList(roles);
        Mockito.when(xUserService.getXUserByUserName("aud")).thenReturn(vxUser);

        XXModuleDefDao moduleDao = Mockito.mock(XXModuleDefDao.class);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(moduleDao);
        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        Mockito.when(moduleDao.findAccessibleModulesByUserId(61L, 71L)).thenReturn(permissionList);

        RoleBasedUserSearchUtil spy = Mockito.spy(roleBasedUserSearchUtil);
        Mockito.doNothing().when(spy).getUsersBasedOnRole(Mockito.anyList());

        spy.validateUserAndFetchUserList();

        Mockito.verify(spy).getUsersBasedOnRole(
                Mockito.argThat(list -> list.size() == 1 && RangerConstants.ROLE_ADMIN_AUDITOR.equals(list.get(0))));
    }

    @Test
    public void testValidateUserAndFetchUserList_keyAdmin_checkRoleTrue_invokesGetUsersBasedOnRoleWithThreeRoles() {
        RoleBasedUserSearchUtil.userRole = "";
        RoleBasedUserSearchUtil.checkRole = true;
        RoleBasedUserSearchUtil.userLoginId = "k1";
        RoleBasedUserSearchUtil.currentPassword = "p";

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(81L);
        xxPortalUser.setLoginId("k1");
        xxPortalUser.setPassword("enc");

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("k1")).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt("k1", "p")).thenReturn("enc");

        VXUser vxUser = new VXUser();
        vxUser.setId(91L);
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_KEY_ADMIN);
        vxUser.setUserRoleList(roles);
        Mockito.when(xUserService.getXUserByUserName("k1")).thenReturn(vxUser);

        XXModuleDefDao moduleDao = Mockito.mock(XXModuleDefDao.class);
        Mockito.when(daoMgr.getXXModuleDef()).thenReturn(moduleDao);
        List<String> permissionList = new ArrayList<>();
        permissionList.add(RangerConstants.MODULE_USER_GROUPS);
        Mockito.when(moduleDao.findAccessibleModulesByUserId(81L, 91L)).thenReturn(permissionList);

        RoleBasedUserSearchUtil spy = Mockito.spy(roleBasedUserSearchUtil);
        Mockito.doNothing().when(spy).getUsersBasedOnRole(Mockito.anyList());

        spy.validateUserAndFetchUserList();

        Mockito.verify(spy).getUsersBasedOnRole(Mockito.argThat(list -> list.size() == 3
                && list.contains(RangerConstants.ROLE_KEY_ADMIN)
                && list.contains(RangerConstants.ROLE_KEY_ADMIN_AUDITOR) && list.contains(RangerConstants.ROLE_USER)));
    }

    @Test
    public void testValidateUserAndFetchUserList_encryptThrows_exits() {
        RoleBasedUserSearchUtil.userLoginId = "u1";
        RoleBasedUserSearchUtil.currentPassword = "p";

        XXPortalUser xxPortalUser = new XXPortalUser();
        xxPortalUser.setId(101L);
        xxPortalUser.setLoginId("u1");
        xxPortalUser.setPassword("enc");
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByLoginId("u1")).thenReturn(xxPortalUser);
        Mockito.when(userMgr.encrypt("u1", "p")).thenThrow(new RuntimeException("boom"));

        SecurityManager originalSm = System.getSecurityManager();
        try {
            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkPermission(Permission perm) {
                }

                @Override
                public void checkExit(int status) {
                    throw new SecurityException("Intercepted System.exit(" + status + ")");
                }
            });
            try {
                roleBasedUserSearchUtil.validateUserAndFetchUserList();
            } catch (SecurityException ignored) {
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testGetUsersBasedOnRole_populatesAllRoleMaps_noExit() {
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_SYS_ADMIN);
        roles.add(RangerConstants.ROLE_ADMIN_AUDITOR);
        roles.add(RangerConstants.ROLE_KEY_ADMIN);
        roles.add(RangerConstants.ROLE_KEY_ADMIN_AUDITOR);
        roles.add(RangerConstants.ROLE_USER);

        XXPortalUser u1 = new XXPortalUser();
        u1.setLoginId("u1");
        XXPortalUser u2 = new XXPortalUser();
        u2.setLoginId("u2");
        XXPortalUser u3 = new XXPortalUser();
        u3.setLoginId("u3");
        XXPortalUser u4 = new XXPortalUser();
        u4.setLoginId("u4");
        XXPortalUser u5 = new XXPortalUser();
        u5.setLoginId("u5");

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xXPortalUserDao);
        Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_SYS_ADMIN))
                .thenReturn(new ArrayList<XXPortalUser>() {
                    {
                        add(u1);
                    }
                });
        Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_ADMIN_AUDITOR))
                .thenReturn(new ArrayList<XXPortalUser>() {
                    {
                        add(u2);
                    }
                });
        Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_KEY_ADMIN))
                .thenReturn(new ArrayList<XXPortalUser>() {
                    {
                        add(u3);
                    }
                });
        Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_KEY_ADMIN_AUDITOR))
                .thenReturn(new ArrayList<XXPortalUser>() {
                    {
                        add(u4);
                    }
                });
        Mockito.when(xXPortalUserDao.findByRole(RangerConstants.ROLE_USER)).thenReturn(new ArrayList<XXPortalUser>() {
            {
                add(u5);
            }
        });

        roleBasedUserSearchUtil.getUsersBasedOnRole(roles);

        Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_SYS_ADMIN);
        Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_ADMIN_AUDITOR);
        Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_KEY_ADMIN);
        Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_KEY_ADMIN_AUDITOR);
        Mockito.verify(xXPortalUserDao).findByRole(RangerConstants.ROLE_USER);
    }

    @Test
    public void testGetUsersBasedOnRole_exceptionCaught_noThrow() {
        List<String> roles = new ArrayList<>();
        roles.add(RangerConstants.ROLE_USER);

        Mockito.when(daoMgr.getXXPortalUser()).thenThrow(new RuntimeException("boom"));

        roleBasedUserSearchUtil.getUsersBasedOnRole(roles);
    }
}
