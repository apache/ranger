/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.common.RangerConstants;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.db.XXPortalUserRoleDao;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.service.XPortalUserService;
import org.apache.ranger.util.CLIUtil;
import org.apache.ranger.view.VXPortalUser;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchAssignSecurityZonePersmissionToAdmin_J10026 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchAssignSecurityZonePersmissionToAdmin_J10026 {
    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
        Assertions.assertDoesNotThrow(() -> patch.init());
    }

    @Test
    public void testMain_Success_ExitZero() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchAssignSecurityZonePersmissionToAdmin_J10026.class))
                    .thenReturn(patch);
            CLIUtil cli = Mockito.mock(CLIUtil.class);
            cliMock.when(() -> CLIUtil.getBean(CLIUtil.class)).thenReturn(cli);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchAssignSecurityZonePersmissionToAdmin_J10026.main(new String[] {});
            } catch (SecurityException se) {
                assertNotNull(se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_Failure_ExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchAssignSecurityZonePersmissionToAdmin_J10026.class))
                    .thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchAssignSecurityZonePersmissionToAdmin_J10026.main(new String[] {});
            } catch (SecurityException se) {
                Assertions.assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testAssignPermissions_countsAndExceptionBranch() throws Exception {
        PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);
        XXPortalUserRoleDao roleDao = Mockito.mock(XXPortalUserRoleDao.class);

        Mockito.when(daoMgr.getXXPortalUserRole()).thenReturn(roleDao);
        HashMap<String, Long> moduleMap1 = new HashMap<>();
        moduleMap1.put(RangerConstants.MODULE_SECURITY_ZONE, 1L);
        Mockito.when(xUserMgr.getAllModuleNameAndIdMap()).thenReturn(moduleMap1);
        setIfPresent(patch, "daoManager", daoMgr);
        setIfPresent(patch, "xPortalUserService", xPortalUserService);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        // Prepare users
        XXPortalUser u1 = new XXPortalUser();
        u1.setId(10L);
        VXPortalUser v1 = new VXPortalUser();
        v1.setId(10L);
        Mockito.when(xPortalUserService.populateViewBean(u1)).thenReturn(v1);
        Mockito.when(roleDao.findXPortalUserRolebyXPortalUserId(10L)).thenReturn(new ArrayList<>());

        Method m = PatchAssignSecurityZonePersmissionToAdmin_J10026.class.getDeclaredMethod("assignPermissions",
                List.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        int count = (int) m.invoke(patch, new ArrayList<>(Collections.singletonList(u1)));
        assertEquals(1, count);

        // Exception branch: populateViewBean throws -> System.exit(1)
        SecurityManager originalSm = System.getSecurityManager();
        System.setSecurityManager(new SecurityManager() {
            @Override
            public void checkExit(int status) {
                throw new SecurityException(String.valueOf(status));
            }

            @Override
            public void checkPermission(Permission perm) {
            }
        });

        Mockito.when(xPortalUserService.populateViewBean(u1)).thenThrow(new RuntimeException("boom"));
        try {
            m.invoke(patch, new ArrayList<>(Collections.singletonList(u1)));
            Assertions.fail("Expected System.exit to be intercepted");
        } catch (Exception e) {
            Throwable cause = e.getCause();
            assertEquals(SecurityException.class, cause.getClass());
            assertEquals("1", cause.getMessage());
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testExecLoad_withAndWithoutLoginFileUsers() throws Exception {
        PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPortalUserDao userDao = Mockito.mock(XXPortalUserDao.class);
        XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);
        XXPortalUserRoleDao roleDao = Mockito.mock(XXPortalUserRoleDao.class);

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(userDao);
        Mockito.when(daoMgr.getXXPortalUserRole()).thenReturn(roleDao);
        HashMap<String, Long> moduleMap2 = new HashMap<>();
        moduleMap2.put(RangerConstants.MODULE_SECURITY_ZONE, 2L);
        Mockito.when(xUserMgr.getAllModuleNameAndIdMap()).thenReturn(moduleMap2);
        setIfPresent(patch, "daoManager", daoMgr);
        setIfPresent(patch, "xPortalUserService", xPortalUserService);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        // Case 1: userCount == null -> nothing happens
        Mockito.when(userDao.getAllCount()).thenReturn(null);
        patch.execLoad();

        // Case 2: userCount > 0, empty login file -> falls back to roles ADMIN,
        // ADMIN_AUDITOR, and possibly USER
        Mockito.reset(userDao);
        Mockito.when(userDao.getAllCount()).thenReturn(10L);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        XXPortalUser auditor = new XXPortalUser();
        auditor.setId(2L);
        XXPortalUser user = new XXPortalUser();
        user.setId(3L);
        Mockito.when(userDao.findByRole(RangerConstants.ROLE_SYS_ADMIN))
                .thenReturn(new ArrayList<>(Collections.singletonList(admin)));
        Mockito.when(userDao.findByRole(RangerConstants.ROLE_ADMIN_AUDITOR))
                .thenReturn(new ArrayList<>(Collections.singletonList(auditor)));
        Mockito.when(userDao.findByRole(RangerConstants.ROLE_USER))
                .thenReturn(new ArrayList<>(Collections.singletonList(user)));
        VXPortalUser vAdmin = new VXPortalUser();
        vAdmin.setId(1L);
        VXPortalUser vAud = new VXPortalUser();
        vAud.setId(2L);
        VXPortalUser vUsr = new VXPortalUser();
        vUsr.setId(3L);
        Mockito.when(xPortalUserService.populateViewBean(admin)).thenReturn(vAdmin);
        Mockito.when(xPortalUserService.populateViewBean(auditor)).thenReturn(vAud);
        Mockito.when(xPortalUserService.populateViewBean(user)).thenReturn(vUsr);
        Mockito.when(roleDao.findXPortalUserRolebyXPortalUserId(Mockito.anyLong())).thenReturn(new ArrayList<>());

        patch.execLoad();

        Mockito.verify(xUserMgr, Mockito.times(3)).createOrUpdateUserPermisson(Mockito.any(VXPortalUser.class),
                Mockito.anyLong(), Mockito.eq(false));

        // Case 3: userCount > 0, login file specified with two users
        Path tmp = Files.createTempFile("ranger-users", ".txt");
        Files.write(tmp, ("u1\n" + "u2\n").getBytes());
        setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "usersListFileName",
                tmp.toAbsolutePath().toString());
        XXPortalUser u1 = new XXPortalUser();
        u1.setId(11L);
        XXPortalUser u2 = new XXPortalUser();
        u2.setId(12L);
        Mockito.when(userDao.findByLoginId("u1")).thenReturn(u1);
        Mockito.when(userDao.findByLoginId("u2")).thenReturn(u2);
        VXPortalUser vU1 = new VXPortalUser();
        vU1.setId(11L);
        VXPortalUser vU2 = new VXPortalUser();
        vU2.setId(12L);
        Mockito.when(xPortalUserService.populateViewBean(u1)).thenReturn(vU1);
        Mockito.when(xPortalUserService.populateViewBean(u2)).thenReturn(vU2);

        patch.execLoad();

        Mockito.verify(xUserMgr, Mockito.atLeast(2)).createOrUpdateUserPermisson(Mockito.any(VXPortalUser.class),
                Mockito.anyLong(), Mockito.eq(false));
    }

    @Test
    public void testReadUserNamesFromFile_EdgeCasesAndDedup() throws Exception {
        PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
        Method m = PatchAssignSecurityZonePersmissionToAdmin_J10026.class.getDeclaredMethod("readUserNamesFromFile", String.class);
        m.setAccessible(true);

        @SuppressWarnings("unchecked")
        List<String> resNull = (List<String>) m.invoke(patch, new Object[] {null});
        Assertions.assertTrue(resNull.isEmpty());

        // Non-existent file
        @SuppressWarnings("unchecked")
        List<String> resMissing = (List<String>) m.invoke(patch, "/path/does/not/exist.txt");
        Assertions.assertTrue(resMissing.isEmpty());

        // File with empty lines and duplicates
        Path tmp = Files.createTempFile("ranger-users-edge", ".txt");
        Files.write(tmp, ("a\n\n a \n b \n a\n").getBytes());
        @SuppressWarnings("unchecked")
        List<String> res = (List<String>) m.invoke(patch, tmp.toAbsolutePath().toString());
        Assertions.assertEquals(4, res.size());
        Assertions.assertTrue(res.contains("a"));
        Assertions.assertTrue(res.contains("b"));
    }

    @Test
    public void testExecLoad_UserCountGreaterThanLimit_WithoutGrantAll() throws Exception {
        PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPortalUserDao userDao = Mockito.mock(XXPortalUserDao.class);
        XXPortalUserRoleDao roleDao = Mockito.mock(XXPortalUserRoleDao.class);
        XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);

        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(userDao);
        Mockito.when(daoMgr.getXXPortalUserRole()).thenReturn(roleDao);
        setIfPresent(patch, "daoManager", daoMgr);
        setIfPresent(patch, "xPortalUserService", xPortalUserService);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        HashMap<String, Long> moduleMap3 = new HashMap<>();
        moduleMap3.put(RangerConstants.MODULE_SECURITY_ZONE, 3L);
        Mockito.when(xUserMgr.getAllModuleNameAndIdMap()).thenReturn(moduleMap3);

        // Ensure usersListFileName is null and grantAllUsers is false
        setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "usersListFileName", null);
        setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "grantAllUsers", false);

        Mockito.when(userDao.getAllCount()).thenReturn(600L);

        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        XXPortalUser auditor = new XXPortalUser();
        auditor.setId(2L);
        XXPortalUser user = new XXPortalUser();
        user.setId(3L);
        Mockito.when(userDao.findByRole(RangerConstants.ROLE_SYS_ADMIN)).thenReturn(new ArrayList<>(Collections.singletonList(admin)));
        Mockito.when(userDao.findByRole(RangerConstants.ROLE_ADMIN_AUDITOR)).thenReturn(new ArrayList<>(Collections.singletonList(auditor)));
        // no stubbing for ROLE_USER since branch should skip it when >500 and not grantAll

        VXPortalUser vAdmin = new VXPortalUser();
        vAdmin.setId(1L);
        VXPortalUser vAud = new VXPortalUser();
        vAud.setId(2L);
        Mockito.when(xPortalUserService.populateViewBean(admin)).thenReturn(vAdmin);
        Mockito.when(xPortalUserService.populateViewBean(auditor)).thenReturn(vAud);
        Mockito.when(roleDao.findXPortalUserRolebyXPortalUserId(Mockito.anyLong())).thenReturn(new ArrayList<>());

        patch.execLoad();

        // Only admin and admin_auditor processed; ROLE_USER skipped due to >500 and grantAll=false
        Mockito.verify(xUserMgr, Mockito.times(2)).createOrUpdateUserPermisson(Mockito.any(VXPortalUser.class), Mockito.anyLong(), Mockito.eq(false));
    }

    @Test
    public void testMain_Args_ALL_SetsGrantAllUsers() throws Exception {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            // reset static
            setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "grantAllUsers", false);
            setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "usersListFileName", null);

            PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchAssignSecurityZonePersmissionToAdmin_J10026.class)).thenReturn(patch);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchAssignSecurityZonePersmissionToAdmin_J10026.main(new String[] {"ALL"});
            } catch (SecurityException se) {
                assertNotNull(se.getMessage());
            }

            Object val = getStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "grantAllUsers");
            Assertions.assertEquals(Boolean.TRUE, val);
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    @Test
    public void testMain_Args_FileName_SetsUsersListFileName() throws Exception {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            // reset static
            setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "grantAllUsers", false);
            setStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "usersListFileName", null);

            PatchAssignSecurityZonePersmissionToAdmin_J10026 patch = new PatchAssignSecurityZonePersmissionToAdmin_J10026();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchAssignSecurityZonePersmissionToAdmin_J10026.class)).thenReturn(patch);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            String fname = "/tmp/users-list.txt";
            try {
                PatchAssignSecurityZonePersmissionToAdmin_J10026.main(new String[] {fname});
            } catch (SecurityException se) {
                assertNotNull(se.getMessage());
            }

            Object val = getStaticField(PatchAssignSecurityZonePersmissionToAdmin_J10026.class, "usersListFileName");
            Assertions.assertEquals(fname, val);
        } finally {
            System.setSecurityManager(originalSm);
        }
    }

    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void setStaticField(Class<?> cls, String fieldName, Object value) throws Exception {
        Field f = cls.getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(null, value);
    }

    private static Object getStaticField(Class<?> cls, String fieldName) throws Exception {
        Field f = cls.getDeclaredField(fieldName);
        f.setAccessible(true);
        return f.get(null);
    }
}
