/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.common.GUIDUtil;
import org.apache.ranger.common.JSONUtil;
import org.apache.ranger.common.RangerValidatorFactory;
import org.apache.ranger.common.StringUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXPolicyItemAccessDao;
import org.apache.ranger.db.XXPolicyItemDao;
import org.apache.ranger.db.XXPolicyItemUserPermDao;
import org.apache.ranger.db.XXPolicyResourceDao;
import org.apache.ranger.db.XXPolicyResourceMapDao;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.db.XXResourceDefDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.db.XXUserDao;
import org.apache.ranger.entity.XXAccessTypeDef;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXPolicyItem;
import org.apache.ranger.entity.XXPolicyItemAccess;
import org.apache.ranger.entity.XXPolicyItemUserPerm;
import org.apache.ranger.entity.XXPolicyResource;
import org.apache.ranger.entity.XXPolicyResourceMap;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.entity.XXResourceDef;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXUser;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefValidator;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.service.RangerPolicyService;
import org.apache.ranger.util.CLIUtil;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForKafkaServiceDefUpdate_J10025 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForKafkaServiceDefUpdate_J10025 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
            setIfPresent(patch, "daoMgr", Mockito.mock(RangerDaoManager.class));
            setIfPresent(patch, "svcDBStore", Mockito.mock(ServiceDBStore.class));
            setIfPresent(patch, "jsonUtil", new JSONUtil());
            setIfPresent(patch, "policyService", Mockito.mock(RangerPolicyService.class));
            setIfPresent(patch, "stringUtil", new StringUtil());
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));
            setIfPresent(patch, "svcStore", Mockito.mock(ServiceDBStore.class));

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        patch.init();
    }

    @Test
    public void testJsonStringToMap_fallbackAndEmpty() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        setIfPresent(patch, "jsonUtil", new JSONUtil());
        Method jsonToMap = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("jsonStringToMap",
                String.class);
        jsonToMap.setAccessible(true);
        @SuppressWarnings("unchecked")
        Map<String, String> map = (Map<String, String>) jsonToMap.invoke(patch, "a=b;;c=d;=;e=");
        assertEquals(3, map.size());
        assertEquals("b", map.get("a"));
        assertEquals("d", map.get("c"));
        assertNull(map.get("e"));
        @SuppressWarnings("unchecked")
        Map<String, String> empty = (Map<String, String>) jsonToMap.invoke(patch, "");
        assertNull(empty);
    }

    @Test
    public void testMapToJsonString_successAndException() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        setIfPresent(patch, "jsonUtil", new JSONUtil());
        Method mapToJson = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("mapToJsonString", Map.class);
        mapToJson.setAccessible(true);
        Map<String, String> input = new HashMap<>();
        input.put("a", "b");
        String json = (String) mapToJson.invoke(patch, input);
        assertNotNull(json);

        JSONUtil failing = Mockito.mock(JSONUtil.class);
        Mockito.when(failing.readMapToString(Mockito.anyMap())).thenThrow(new RuntimeException("boom"));
        setIfPresent(patch, "jsonUtil", failing);
        String jsonNull = (String) mapToJson.invoke(patch, input);
        assertNull(jsonNull);
    }

    @Test
    public void testCheckNewKafkaresourcePresent_trueFalse() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        Method chk = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("checkNewKafkaresourcePresent",
                List.class);
        chk.setAccessible(true);
        List<RangerServiceDef.RangerResourceDef> list1 = new ArrayList<>();
        RangerServiceDef.RangerResourceDef r1 = new RangerServiceDef.RangerResourceDef();
        r1.setName(PatchForKafkaServiceDefUpdate_J10025.CLUSTER_RESOURCE_NAME);
        list1.add(r1);
        boolean present = (boolean) chk.invoke(patch, list1);
        assertTrue(present);
        List<RangerServiceDef.RangerResourceDef> list2 = new ArrayList<>();
        RangerServiceDef.RangerResourceDef r2 = new RangerServiceDef.RangerResourceDef();
        r2.setName("topic");
        list2.add(r2);
        boolean absent = (boolean) chk.invoke(patch, list2);
        assertTrue(!absent);
    }

    @Test
    public void testGetRangerPolicy_buildsExpected_andResourceSelection() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        Method getPolicy = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("getRangerPolicy", String.class,
                XXPortalUser.class, XXService.class);
        getPolicy.setAccessible(true);
        XXPortalUser user = new XXPortalUser();
        user.setLoginId("admin");
        XXService svc = new XXService();
        svc.setName("kafka_svc");
        RangerPolicy p1 = (RangerPolicy) getPolicy.invoke(patch, "all - cluster", user, svc);
        assertNotNull(p1.getResources().get(PatchForKafkaServiceDefUpdate_J10025.CLUSTER_RESOURCE_NAME));
        RangerPolicy p2 = (RangerPolicy) getPolicy.invoke(patch, "all - delegationtoken", user, svc);
        assertNotNull(p2.getResources().get("delegationtoken"));
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_happyPath_andExceptions() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);

        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(5L);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(sdef);

        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        XXService xs = new XXService();
        xs.setId(7L);
        xs.setName("k1");
        List<XXService> services = new ArrayList<>();
        services.add(xs);
        Mockito.when(svcDao.findByServiceDefId(5L)).thenReturn(services);

        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy createdPolicy = new XXPolicy();
        createdPolicy.setId(100L);
        createdPolicy.setService(7L);
        Mockito.when(polDao.create(Mockito.any())).thenReturn(createdPolicy);

        XXPolicyItemDao piDao = Mockito.mock(XXPolicyItemDao.class);
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(piDao);
        XXPolicyItem createdItem = new XXPolicyItem();
        createdItem.setId(200L);
        Mockito.when(piDao.create(Mockito.any())).thenReturn(createdItem);

        // Access DAO needed for creating policy item accesses
        XXPolicyItemAccessDao piAccessDao = Mockito.mock(XXPolicyItemAccessDao.class);
        Mockito.when(daoMgr.getXXPolicyItemAccess()).thenReturn(piAccessDao);
        Mockito.when(piAccessDao.create(Mockito.any())).thenReturn(new XXPolicyItemAccess());

        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(300L);
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);

        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        XXUser kafkaUser = new XXUser();
        kafkaUser.setId(10L);
        Mockito.when(userDao.findByUserName("kafka")).thenReturn(kafkaUser);
        XXUser lookupUser = new XXUser();
        lookupUser.setId(11L);
        Mockito.when(userDao.findByUserName("rangerlookup")).thenReturn(lookupUser);

        XXResourceDefDao resDefDao = Mockito.mock(XXResourceDefDao.class);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        XXResourceDef resDef = new XXResourceDef();
        resDef.setId(400L);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.eq("cluster"), Mockito.eq(100L))).thenReturn(resDef);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.eq("delegationtoken"), Mockito.eq(100L)))
                .thenReturn(resDef);

        // Additional DAOs used later in method
        XXPolicyItemUserPermDao piUserPermDao = Mockito.mock(XXPolicyItemUserPermDao.class);
        Mockito.when(daoMgr.getXXPolicyItemUserPerm()).thenReturn(piUserPermDao);
        XXPolicyItemUserPerm createdUserPerm = new XXPolicyItemUserPerm();
        Mockito.when(piUserPermDao.create(Mockito.any())).thenReturn(createdUserPerm);

        XXPolicyResourceDao polResDao = Mockito.mock(XXPolicyResourceDao.class);
        Mockito.when(daoMgr.getXXPolicyResource()).thenReturn(polResDao);
        XXPolicyResource createdRes = new XXPolicyResource();
        createdRes.setId(500L);
        Mockito.when(polResDao.create(Mockito.any())).thenReturn(createdRes);

        XXPolicyResourceMapDao polResMapDao = Mockito.mock(XXPolicyResourceMapDao.class);
        Mockito.when(daoMgr.getXXPolicyResourceMap()).thenReturn(polResMapDao);
        XXPolicyResourceMap createdResMap = new XXPolicyResourceMap();
        Mockito.when(polResMapDao.create(Mockito.any())).thenReturn(createdResMap);

        // run method
        Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        // guidUtil is used to set policy GUID
        setIfPresent(patch, "guidUtil", new GUIDUtil());
        m.invoke(patch);

        // Now test exceptions branches: missing access type def
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(null);
        assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch);
            } catch (InvocationTargetException ite) {
                if (ite.getTargetException() instanceof RuntimeException) {
                    throw (RuntimeException) ite.getTargetException();
                }
                throw new RuntimeException(ite.getTargetException());
            }
        });

        // resource def missing
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.anyString(), Mockito.eq(100L))).thenReturn(null);
        assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch);
            } catch (InvocationTargetException ite) {
                if (ite.getTargetException() instanceof RuntimeException) {
                    throw (RuntimeException) ite.getTargetException();
                }
                throw new RuntimeException(ite.getTargetException());
            }
        });
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_userCreatedViaTransaction() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "guidUtil", new GUIDUtil());

        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(5L);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(sdef);

        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        XXService xs = new XXService();
        xs.setId(7L);
        xs.setName("k1");
        Mockito.when(svcDao.findByServiceDefId(5L)).thenReturn(new ArrayList<>(Collections.singletonList(xs)));

        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy createdPolicy = new XXPolicy();
        createdPolicy.setId(100L);
        createdPolicy.setService(7L);
        Mockito.when(polDao.create(Mockito.any())).thenReturn(createdPolicy);

        XXPolicyItemDao piDao = Mockito.mock(XXPolicyItemDao.class);
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(piDao);
        XXPolicyItem createdItem = new XXPolicyItem();
        createdItem.setId(200L);
        Mockito.when(piDao.create(Mockito.any())).thenReturn(createdItem);

        // Access DAO for creating accesses
        XXPolicyItemAccessDao piAccessDao = Mockito.mock(XXPolicyItemAccessDao.class);
        Mockito.when(daoMgr.getXXPolicyItemAccess()).thenReturn(piAccessDao);
        Mockito.when(piAccessDao.create(Mockito.any())).thenReturn(new XXPolicyItemAccess());

        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(300L);
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);

        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        // kafka user absent first, then created
        Mockito.when(userDao.findByUserName("kafka")).thenReturn(null, new XXUser());
        // rangerlookup exists from start
        XXUser lookupUser = new XXUser();
        lookupUser.setId(11L);
        Mockito.when(userDao.findByUserName("rangerlookup")).thenReturn(lookupUser);

        XXPolicyItemUserPermDao piUserPermDao = Mockito.mock(XXPolicyItemUserPermDao.class);
        Mockito.when(daoMgr.getXXPolicyItemUserPerm()).thenReturn(piUserPermDao);
        Mockito.when(piUserPermDao.create(Mockito.any())).thenReturn(new XXPolicyItemUserPerm());

        XXResourceDefDao resDefDao = Mockito.mock(XXResourceDefDao.class);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        XXResourceDef resDef = new XXResourceDef();
        resDef.setId(400L);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.eq("cluster"), Mockito.eq(100L))).thenReturn(resDef);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.eq("delegationtoken"), Mockito.eq(100L)))
                .thenReturn(resDef);

        XXPolicyResourceDao polResDao = Mockito.mock(XXPolicyResourceDao.class);
        Mockito.when(daoMgr.getXXPolicyResource()).thenReturn(polResDao);
        Mockito.when(polResDao.create(Mockito.any())).thenReturn(new XXPolicyResource());

        XXPolicyResourceMapDao polResMapDao = Mockito.mock(XXPolicyResourceMapDao.class);
        Mockito.when(daoMgr.getXXPolicyResourceMap()).thenReturn(polResMapDao);
        Mockito.when(polResMapDao.create(Mockito.any())).thenReturn(new XXPolicyResourceMap());

        // transaction manager and xUserMgr
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        TransactionStatus status = Mockito.mock(TransactionStatus.class);
        Mockito.when(tx.getTransaction(Mockito.any())).thenReturn(status);
        // commit/rollback no-ops
        setIfPresent(patch, "txManager", tx);
        setIfPresent(patch, "xUserMgr", Mockito.mock(XUserMgr.class));

        Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        m.invoke(patch);

        // verify that user-perm creation attempted twice (kafka and rangerlookup)
        Mockito.verify(piUserPermDao, Mockito.atLeast(2)).create(Mockito.any());
    }

    @Test
    public void testUpdateKafkaServiceDef_preserveOptionValueWhenPresent_invokesDaoUpdate() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(new RangerServiceDef());

            PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            XXServiceDef pre = new XXServiceDef();
            pre.setDefOptions("{}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre);

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerServiceDef db = new RangerServiceDef();
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(db);
            Mockito.when(svcDBStore.updateServiceDef(Mockito.any())).thenReturn(new RangerServiceDef());

            RangerValidatorFactory vf = Mockito.mock(RangerValidatorFactory.class);
            Mockito.when(vf.getServiceDefValidator(Mockito.any()))
                    .thenReturn(Mockito.mock(RangerServiceDefValidator.class));

            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "validatorFactory", vf);
            setIfPresent(patch, "svcStore", svcDBStore);
            setIfPresent(patch, "jsonUtil", new JSONUtil());

            XXServiceDef post = new XXServiceDef();
            post.setDefOptions("{\"enableDenyAndExceptionsInPolicies\":\"false\"}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre, post);

            Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);

            Mockito.verify(sdefDao, Mockito.atLeastOnce()).update(Mockito.any());
        }
    }

    @Test
    public void testUpdateKafkaServiceDef_dbServiceDefNull_noThrow() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(new RangerServiceDef());

            PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            XXServiceDef pre = new XXServiceDef();
            pre.setDefOptions("{}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre);

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(null);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));
            setIfPresent(patch, "svcStore", svcDBStore);

            Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_serviceDefNull_returns() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);

        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(null);

        Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        m.invoke(patch);
    }

    @Test
    public void testUpdateKafkaServiceDef_embeddedNull_noThrow() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(null);

            PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
            Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testUpdateKafkaServiceDef_updateReturnsNull_noThrow() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(new RangerServiceDef());

            PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            XXServiceDef pre = new XXServiceDef();
            pre.setDefOptions("{}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre);

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerServiceDef db = new RangerServiceDef();
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(db);

            RangerValidatorFactory vf = Mockito.mock(RangerValidatorFactory.class);
            Mockito.when(vf.getServiceDefValidator(Mockito.any()))
                    .thenReturn(Mockito.mock(RangerServiceDefValidator.class));

            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "validatorFactory", vf);
            setIfPresent(patch, "svcStore", svcDBStore);

            Mockito.when(svcDBStore.updateServiceDef(Mockito.any())).thenReturn(null);

            Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_missingGroupThrows() throws Exception {
        PatchForKafkaServiceDefUpdate_J10025 patch = new PatchForKafkaServiceDefUpdate_J10025();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "guidUtil", new GUIDUtil());

        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(5L);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(sdef);

        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        XXService xs = new XXService();
        xs.setId(7L);
        xs.setName("k1");
        Mockito.when(svcDao.findByServiceDefId(5L)).thenReturn(new ArrayList<>(Collections.singletonList(xs)));

        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy created = new XXPolicy();
        created.setId(100L);
        created.setService(7L);
        Mockito.when(polDao.create(Mockito.any())).thenReturn(created);

        XXPolicyItemDao piDao = Mockito.mock(XXPolicyItemDao.class);
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(piDao);
        XXPolicyItem createdItem = new XXPolicyItem();
        createdItem.setId(200L);
        Mockito.when(piDao.create(Mockito.any())).thenReturn(createdItem);

        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(300L);
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);

        // Only stub resourceDefs after policy created, we won't stub user/group/perm or
        // resource maps unnecessarily
        XXResourceDefDao resDefDao = Mockito.mock(XXResourceDefDao.class);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        XXResourceDef resDef = new XXResourceDef();
        resDef.setId(400L);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.eq("cluster"), Mockito.eq(100L))).thenReturn(resDef);
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.eq("delegationtoken"), Mockito.eq(100L)))
                .thenReturn(resDef);

        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(groupDao);
        Mockito.when(groupDao.findByGroupName("public")).thenReturn(null);

        Method m = PatchForKafkaServiceDefUpdate_J10025.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch);
            } catch (InvocationTargetException ite) {
                if (ite.getTargetException() instanceof RuntimeException) {
                    throw (RuntimeException) ite.getTargetException();
                }
                throw new RuntimeException(ite.getTargetException());
            }
        });
    }

    @Test
    public void testMain_Success_ExitZero_andFailureExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchForKafkaServiceDefUpdate_J10025 loader = new PatchForKafkaServiceDefUpdate_J10025();
            loader.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchForKafkaServiceDefUpdate_J10025.class)).thenReturn(loader);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForKafkaServiceDefUpdate_J10025.main(new String[] {});
            } catch (SecurityException se) {
                assertTrue("0".equals(se.getMessage()) || "1".equals(se.getMessage()));
            }
        } finally {
            System.setSecurityManager(originalSm);
        }

        SecurityManager originalSm2 = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchForKafkaServiceDefUpdate_J10025.class))
                    .thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForKafkaServiceDefUpdate_J10025.main(new String[] {});
            } catch (SecurityException se) {
                assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm2);
        }
    }
}
