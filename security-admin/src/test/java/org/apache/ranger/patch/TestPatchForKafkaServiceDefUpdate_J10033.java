/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.ServiceDBStore;
import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.common.GUIDUtil;
import org.apache.ranger.common.JSONUtil;
import org.apache.ranger.common.RangerValidatorFactory;
import org.apache.ranger.common.StringUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXAccessTypeDefDao;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXPolicyItemAccessDao;
import org.apache.ranger.db.XXPolicyItemDao;
import org.apache.ranger.db.XXPolicyItemGroupPermDao;
import org.apache.ranger.db.XXPolicyItemUserPermDao;
import org.apache.ranger.db.XXPolicyResourceDao;
import org.apache.ranger.db.XXPolicyResourceMapDao;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.db.XXResourceDefDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.db.XXUserDao;
import org.apache.ranger.entity.XXAccessTypeDef;
import org.apache.ranger.entity.XXGroup;
import org.apache.ranger.entity.XXPolicy;
import org.apache.ranger.entity.XXPolicyItem;
import org.apache.ranger.entity.XXPolicyItemAccess;
import org.apache.ranger.entity.XXPolicyItemGroupPerm;
import org.apache.ranger.entity.XXPolicyItemUserPerm;
import org.apache.ranger.entity.XXPolicyResource;
import org.apache.ranger.entity.XXPolicyResourceMap;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.entity.XXResourceDef;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXUser;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.validation.RangerServiceDefValidator;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.service.RangerPolicyService;
import org.apache.ranger.util.CLIUtil;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchForKafkaServiceDefUpdate_J10033 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchForKafkaServiceDefUpdate_J10033 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testExecLoadAndPrintStats() {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
            setIfPresent(patch, "daoMgr", Mockito.mock(RangerDaoManager.class));
            setIfPresent(patch, "svcDBStore", Mockito.mock(ServiceDBStore.class));
            setIfPresent(patch, "jsonUtil", new JSONUtil());
            setIfPresent(patch, "policyService", Mockito.mock(RangerPolicyService.class));
            setIfPresent(patch, "stringUtil", new StringUtil());
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));
            setIfPresent(patch, "svcStore", Mockito.mock(ServiceDBStore.class));

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testInit_DoesNothing() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        patch.init();
    }

    @Test
    public void testGetAccessTypes_andPolicyItemAccesses() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        Method getTypes = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("getAccessTypes");
        getTypes.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<String> types = (List<String>) getTypes.invoke(patch);
        assertTrue(types.contains("consume"));
        assertTrue(types.contains("delete"));

        Method getAccesses = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("getPolicyItemAccesses");
        getAccesses.setAccessible(true);
        @SuppressWarnings("unchecked")
        ArrayList<RangerPolicy.RangerPolicyItemAccess> accesses = (ArrayList<RangerPolicy.RangerPolicyItemAccess>) getAccesses
                .invoke(patch);
        assertEquals(types.size(), accesses.size());
        assertTrue(accesses.stream().allMatch(a -> a.getIsAllowed() != null && a.getIsAllowed()));
    }

    @Test
    public void testGetRangerPolicy_buildsExpected() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        Method getPolicy = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("getRangerPolicy", String.class,
                XXPortalUser.class, XXService.class);
        getPolicy.setAccessible(true);
        XXPortalUser user = new XXPortalUser();
        user.setLoginId("admin");
        XXService svc = new XXService();
        svc.setName("kafka_svc");
        RangerPolicy policy = (RangerPolicy) getPolicy.invoke(patch, "all - consumergroup", user, svc);
        assertNotNull(policy);
        assertTrue(policy.getResources().containsKey(PatchForKafkaServiceDefUpdate_J10033.CONSUMERGROUP_RESOURCE_NAME));
        assertTrue(policy.getPolicyItems() != null && !policy.getPolicyItems().isEmpty());
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_serviceDefNull_returns() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(null);
        setIfPresent(patch, "daoMgr", daoMgr);
        Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        // no exception when serviceDef is null
        m.invoke(patch);
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_throwsWhenGroupMissing() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "guidUtil", new GUIDUtil());

        // admin
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        // service-def exists
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(5L);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(sdef);

        // one service
        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        XXService xs = new XXService();
        xs.setId(7L);
        xs.setName("k1");
        Mockito.when(svcDao.findByServiceDefId(5L)).thenReturn(new ArrayList<>(Collections.singletonList(xs)));

        // Create policy return
        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy created = new XXPolicy();
        created.setId(100L);
        created.setService(7L);
        Mockito.when(polDao.create(Mockito.any())).thenReturn(created);

        // Create policy item
        XXPolicyItemDao piDao = Mockito.mock(XXPolicyItemDao.class);
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(piDao);
        XXPolicyItem createdItem = new XXPolicyItem();
        createdItem.setId(200L);
        Mockito.when(piDao.create(Mockito.any())).thenReturn(createdItem);

        // Access type def lookup
        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(300L);
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);

        // Users creation and lookup
        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        XXUser kafkaUser = new XXUser();
        kafkaUser.setId(10L);
        Mockito.when(userDao.findByUserName("kafka")).thenReturn(kafkaUser);
        XXUser lookupUser = new XXUser();
        lookupUser.setId(11L);
        Mockito.when(userDao.findByUserName("rangerlookup")).thenReturn(lookupUser);

        // Group missing
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(groupDao);
        Mockito.when(groupDao.findByGroupName("public")).thenReturn(null);

        // Expect RuntimeException for missing group
        Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch);
            } catch (InvocationTargetException ite) {
                if (ite.getTargetException() instanceof RuntimeException) {
                    throw (RuntimeException) ite.getTargetException();
                }
                throw new RuntimeException(ite.getTargetException());
            }
        });
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_happyPath() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "guidUtil", new GUIDUtil());

        // admin
        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        // service-def exists
        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(5L);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(sdef);

        // one service
        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        XXService xs = new XXService();
        xs.setId(7L);
        xs.setName("k1");
        Mockito.when(svcDao.findByServiceDefId(5L)).thenReturn(new ArrayList<>(Collections.singletonList(xs)));

        // Create policy return
        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy created = new XXPolicy();
        created.setId(100L);
        created.setService(7L);
        Mockito.when(polDao.create(Mockito.any())).thenReturn(created);

        // Create policy item
        XXPolicyItemDao piDao = Mockito.mock(XXPolicyItemDao.class);
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(piDao);
        XXPolicyItem createdItem = new XXPolicyItem();
        createdItem.setId(200L);
        Mockito.when(piDao.create(Mockito.any())).thenReturn(createdItem);

        // Access type def lookup for all accesses
        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(300L);
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);

        // Users exist
        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        XXUser kafkaUser = new XXUser();
        kafkaUser.setId(10L);
        Mockito.when(userDao.findByUserName("kafka")).thenReturn(kafkaUser);
        XXUser lookupUser = new XXUser();
        lookupUser.setId(11L);
        Mockito.when(userDao.findByUserName("rangerlookup")).thenReturn(lookupUser);

        // Group exists
        XXGroupDao groupDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(groupDao);
        XXGroup grp = new XXGroup();
        grp.setId(55L);
        grp.setName("public");
        Mockito.when(groupDao.findByGroupName("public")).thenReturn(grp);

        // DAOs for user/group perms and resources
        XXPolicyItemUserPermDao piUserPermDao = Mockito.mock(XXPolicyItemUserPermDao.class);
        Mockito.when(daoMgr.getXXPolicyItemUserPerm()).thenReturn(piUserPermDao);
        Mockito.when(piUserPermDao.create(Mockito.any())).thenReturn(new XXPolicyItemUserPerm());

        XXPolicyItemGroupPermDao piGroupPermDao = Mockito.mock(XXPolicyItemGroupPermDao.class);
        Mockito.when(daoMgr.getXXPolicyItemGroupPerm()).thenReturn(piGroupPermDao);
        Mockito.when(piGroupPermDao.create(Mockito.any())).thenReturn(new XXPolicyItemGroupPerm());

        XXPolicyItemAccessDao piAccessDao = Mockito.mock(XXPolicyItemAccessDao.class);
        Mockito.when(daoMgr.getXXPolicyItemAccess()).thenReturn(piAccessDao);
        Mockito.when(piAccessDao.create(Mockito.any())).thenReturn(new XXPolicyItemAccess());

        XXResourceDefDao resDefDao = Mockito.mock(XXResourceDefDao.class);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        XXResourceDef resDef = new XXResourceDef();
        resDef.setId(400L);
        Mockito.when(resDefDao.findByNameAndPolicyId(
                Mockito.eq(PatchForKafkaServiceDefUpdate_J10033.CONSUMERGROUP_RESOURCE_NAME), Mockito.eq(100L)))
                .thenReturn(resDef);

        XXPolicyResourceDao polResDao = Mockito.mock(XXPolicyResourceDao.class);
        Mockito.when(daoMgr.getXXPolicyResource()).thenReturn(polResDao);
        XXPolicyResource createdRes = new XXPolicyResource();
        createdRes.setId(500L);
        Mockito.when(polResDao.create(Mockito.any())).thenReturn(createdRes);

        XXPolicyResourceMapDao polResMapDao = Mockito.mock(XXPolicyResourceMapDao.class);
        Mockito.when(daoMgr.getXXPolicyResourceMap()).thenReturn(polResMapDao);
        Mockito.when(polResMapDao.create(Mockito.any())).thenReturn(new XXPolicyResourceMap());

        Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        m.invoke(patch);
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_policyAlreadyExists_skipsCreate() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "svcDBStore", svcDBStore);
        setIfPresent(patch, "guidUtil", new GUIDUtil());

        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        // Return null service-def to exercise early return and avoid unnecessary stubs
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(null);

        Method create = PatchForKafkaServiceDefUpdate_J10033.class
                .getDeclaredMethod("createDefaultPolicyForNewResources");
        create.setAccessible(true);
        create.invoke(patch);
    }

    @Test
    public void testUpdateKafkaServiceDef_dbServiceDefNull_noThrow() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(new RangerServiceDef());

            PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            XXServiceDef pre = new XXServiceDef();
            pre.setDefOptions("{}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre);

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(null);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));
            setIfPresent(patch, "svcStore", svcDBStore);

            Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testUpdateKafkaServiceDef_embeddedNull_noThrow() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(null);

            PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
            Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testJsonStringToMap_fallbackAndEmpty() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        setIfPresent(patch, "jsonUtil", new JSONUtil());

        Method jsonToMap = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("jsonStringToMap",
                String.class);
        jsonToMap.setAccessible(true);

        // fallback parsing path
        String cfg = "a=b;;c=d;=;e=";
        @SuppressWarnings("unchecked")
        Map<String, String> map = (Map<String, String>) jsonToMap.invoke(patch, cfg);
        assertEquals(3, map.size());
        assertEquals("b", map.get("a"));
        assertEquals("d", map.get("c"));
        assertNull(map.get("e"));

        // empty string => null
        @SuppressWarnings("unchecked")
        Map<String, String> empty = (Map<String, String>) jsonToMap.invoke(patch, "");
        assertNull(empty);
    }

    @Test
    public void testJsonStringToMap_jsonSuccess() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        setIfPresent(patch, "jsonUtil", new JSONUtil());
        Method jsonToMap = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("jsonStringToMap",
                String.class);
        jsonToMap.setAccessible(true);
        String json = "{\"a\":\"b\", \"c\":\"d\"}";
        @SuppressWarnings("unchecked")
        Map<String, String> map = (Map<String, String>) jsonToMap.invoke(patch, json);
        assertEquals("b", map.get("a"));
        assertEquals("d", map.get("c"));
    }

    @Test
    public void testMapToJsonString_successAndException() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        setIfPresent(patch, "jsonUtil", new JSONUtil());
        Method mapToJson = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("mapToJsonString", Map.class);
        mapToJson.setAccessible(true);
        Map<String, String> input = new HashMap<>();
        input.put("a", "b");
        String json = (String) mapToJson.invoke(patch, input);
        assertNotNull(json);

        JSONUtil failing = Mockito.mock(JSONUtil.class);
        Mockito.when(failing.readMapToString(Mockito.anyMap())).thenThrow(new RuntimeException("boom"));
        setIfPresent(patch, "jsonUtil", failing);
        String jsonNull = (String) mapToJson.invoke(patch, input);
        assertNull(jsonNull);
    }

    @Test
    public void testCheckNewKafkaresourcePresent_trueFalse() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        Method chk = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("checkNewKafkaresourcePresent",
                List.class);
        chk.setAccessible(true);

        List<RangerServiceDef.RangerResourceDef> resources = new ArrayList<>();
        RangerServiceDef.RangerResourceDef def1 = new RangerServiceDef.RangerResourceDef();
        def1.setName(PatchForKafkaServiceDefUpdate_J10033.CONSUMERGROUP_RESOURCE_NAME);
        resources.add(def1);
        boolean present = (boolean) chk.invoke(patch, resources);
        assertTrue(present);

        List<RangerServiceDef.RangerResourceDef> resources2 = new ArrayList<>();
        RangerServiceDef.RangerResourceDef def2 = new RangerServiceDef.RangerResourceDef();
        def2.setName("topic");
        resources2.add(def2);
        boolean absent = (boolean) chk.invoke(patch, resources2);
        assertTrue(!absent);
    }

    @Test
    public void testUpdateKafkaServiceDef_preserveOptionValueWhenPresent() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            // Embedded def present
            RangerServiceDef embedded = new RangerServiceDef();
            embedded.setResources(new ArrayList<>());
            embedded.setAccessTypes(new ArrayList<>());
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(embedded);

            PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "jsonUtil", new JSONUtil());
            setIfPresent(patch, "validatorFactory", Mockito.mock(RangerValidatorFactory.class));
            setIfPresent(patch, "svcStore", Mockito.mock(ServiceDBStore.class));

            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);

            // Pre-update without the option triggers update path
            XXServiceDef pre = new XXServiceDef();
            pre.setDefOptions("{}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre);

            // DB service-def returned and updated
            RangerServiceDef db = new RangerServiceDef();
            db.setResources(new ArrayList<>());
            db.setAccessTypes(new ArrayList<>());
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(db);

            RangerValidatorFactory vf = Mockito.mock(RangerValidatorFactory.class);
            setIfPresent(patch, "validatorFactory", vf);
            Mockito.when(vf.getServiceDefValidator(Mockito.any()))
                    .thenReturn(Mockito.mock(RangerServiceDefValidator.class));

            ServiceDBStore svcStore = Mockito.mock(ServiceDBStore.class);
            setIfPresent(patch, "svcStore", svcStore);
            Mockito.when(svcStore.updateServiceDef(Mockito.any())).thenReturn(new RangerServiceDef());

            // Post-update serviceDef with option
            XXServiceDef post = new XXServiceDef();
            post.setDefOptions("{\"enableDenyAndExceptionsInPolicies\":\"false\"}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre, post);

            Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testCreateDefaultPolicyForNewResources_userCreatedAndResourceDefMissingThrows() throws Exception {
        PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        setIfPresent(patch, "daoMgr", daoMgr);
        setIfPresent(patch, "guidUtil", new GUIDUtil());

        XXPortalUserDao portalDao = Mockito.mock(XXPortalUserDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(portalDao);
        XXPortalUser admin = new XXPortalUser();
        admin.setId(1L);
        admin.setLoginId("admin");
        Mockito.when(portalDao.findByLoginId("admin")).thenReturn(admin);

        XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
        Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
        XXServiceDef sdef = new XXServiceDef();
        sdef.setId(5L);
        Mockito.when(sdefDao.findByName(EmbeddedServiceDefsUtil.EMBEDDED_SERVICEDEF_KAFKA_NAME)).thenReturn(sdef);

        XXServiceDao svcDao = Mockito.mock(XXServiceDao.class);
        Mockito.when(daoMgr.getXXService()).thenReturn(svcDao);
        XXService xs = new XXService();
        xs.setId(7L);
        xs.setName("k1");
        Mockito.when(svcDao.findByServiceDefId(5L)).thenReturn(new ArrayList<>(Collections.singletonList(xs)));

        XXPolicyDao polDao = Mockito.mock(XXPolicyDao.class);
        Mockito.when(daoMgr.getXXPolicy()).thenReturn(polDao);
        XXPolicy created = new XXPolicy();
        created.setId(100L);
        created.setService(7L);
        Mockito.when(polDao.create(Mockito.any())).thenReturn(created);

        XXPolicyItemDao piDao = Mockito.mock(XXPolicyItemDao.class);
        Mockito.when(daoMgr.getXXPolicyItem()).thenReturn(piDao);
        XXPolicyItem createdItem = new XXPolicyItem();
        createdItem.setId(200L);
        Mockito.when(piDao.create(Mockito.any())).thenReturn(createdItem);

        XXAccessTypeDefDao atDao = Mockito.mock(XXAccessTypeDefDao.class);
        Mockito.when(daoMgr.getXXAccessTypeDef()).thenReturn(atDao);
        XXAccessTypeDef at = new XXAccessTypeDef();
        at.setId(300L);
        Mockito.when(atDao.findByNameAndServiceId(Mockito.anyString(), Mockito.eq(7L))).thenReturn(at);

        XXUserDao userDao = Mockito.mock(XXUserDao.class);
        Mockito.when(daoMgr.getXXUser()).thenReturn(userDao);
        // Simulate first user missing then created by xUserMgr
        Mockito.when(userDao.findByUserName("kafka")).thenReturn(null, new XXUser());
        Mockito.when(userDao.findByUserName("rangerlookup")).thenReturn(new XXUser());

        XXPolicyItemUserPermDao piUserPermDao = Mockito.mock(XXPolicyItemUserPermDao.class);
        Mockito.when(daoMgr.getXXPolicyItemUserPerm()).thenReturn(piUserPermDao);
        Mockito.when(piUserPermDao.create(Mockito.any())).thenReturn(new XXPolicyItemUserPerm());

        // Access and Group perm DAOs used before resource-def lookup
        XXPolicyItemAccessDao piAccessDao = Mockito.mock(XXPolicyItemAccessDao.class);
        Mockito.when(daoMgr.getXXPolicyItemAccess()).thenReturn(piAccessDao);
        Mockito.when(piAccessDao.create(Mockito.any())).thenReturn(new XXPolicyItemAccess());

        XXPolicyItemGroupPermDao piGroupPermDao = Mockito.mock(XXPolicyItemGroupPermDao.class);
        Mockito.when(daoMgr.getXXPolicyItemGroupPerm()).thenReturn(piGroupPermDao);
        Mockito.when(piGroupPermDao.create(Mockito.any())).thenReturn(new XXPolicyItemGroupPerm());

        // Group must exist to pass group check and reach resource-def lookup
        XXGroupDao grpDao = Mockito.mock(XXGroupDao.class);
        Mockito.when(daoMgr.getXXGroup()).thenReturn(grpDao);
        XXGroup grp = new XXGroup();
        grp.setId(77L);
        grp.setName("public");
        Mockito.when(grpDao.findByGroupName("public")).thenReturn(grp);

        // Policies-by-signature should be empty to proceed with creation
        ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
        setIfPresent(patch, "svcDBStore", svcDBStore);
        Mockito.when(svcDBStore.getPoliciesByResourceSignature(Mockito.anyString(), Mockito.anyString(),
                Mockito.anyBoolean())).thenReturn(new ArrayList<>());

        XXResourceDefDao resDefDao = Mockito.mock(XXResourceDefDao.class);
        Mockito.when(daoMgr.getXXResourceDef()).thenReturn(resDefDao);
        // Simulate missing resource-def to throw
        Mockito.when(resDefDao.findByNameAndPolicyId(Mockito.anyString(), Mockito.eq(100L))).thenReturn(null);

        // Tx manager + xUserMgr
        PlatformTransactionManager tx = Mockito.mock(PlatformTransactionManager.class);
        TransactionStatus status = Mockito.mock(TransactionStatus.class);
        Mockito.when(tx.getTransaction(Mockito.any())).thenReturn(status);
        setIfPresent(patch, "txManager", tx);
        setIfPresent(patch, "xUserMgr", Mockito.mock(XUserMgr.class));

        Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("createDefaultPolicyForNewResources");
        m.setAccessible(true);
        assertThrows(RuntimeException.class, () -> {
            try {
                m.invoke(patch);
            } catch (InvocationTargetException ite) {
                if (ite.getTargetException() instanceof RuntimeException) {
                    throw (RuntimeException) ite.getTargetException();
                }
                throw new RuntimeException(ite.getTargetException());
            }
        });
    }

    @Test
    public void testUpdateKafkaServiceDef_updateReturnsNull_noThrow() throws Exception {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);
            RangerServiceDef embedded = new RangerServiceDef();
            embedded.setResources(new ArrayList<>());
            embedded.setAccessTypes(new ArrayList<>());
            Mockito.when(util.getEmbeddedServiceDef(Mockito.anyString())).thenReturn(embedded);

            PatchForKafkaServiceDefUpdate_J10033 patch = new PatchForKafkaServiceDefUpdate_J10033();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXServiceDefDao sdefDao = Mockito.mock(XXServiceDefDao.class);
            Mockito.when(daoMgr.getXXServiceDef()).thenReturn(sdefDao);
            XXServiceDef pre = new XXServiceDef();
            pre.setDefOptions("{}");
            Mockito.when(sdefDao.findByName(Mockito.anyString())).thenReturn(pre);

            ServiceDBStore svcDBStore = Mockito.mock(ServiceDBStore.class);
            RangerServiceDef db = new RangerServiceDef();
            db.setResources(new ArrayList<>());
            db.setAccessTypes(new ArrayList<>());
            Mockito.when(svcDBStore.getServiceDefByName(Mockito.anyString())).thenReturn(db);

            RangerValidatorFactory vf = Mockito.mock(RangerValidatorFactory.class);
            Mockito.when(vf.getServiceDefValidator(Mockito.any()))
                    .thenReturn(Mockito.mock(RangerServiceDefValidator.class));

            setIfPresent(patch, "daoMgr", daoMgr);
            setIfPresent(patch, "svcDBStore", svcDBStore);
            setIfPresent(patch, "validatorFactory", vf);
            setIfPresent(patch, "svcStore", svcDBStore);

            Mockito.when(svcDBStore.updateServiceDef(Mockito.any())).thenReturn(null);

            Method m = PatchForKafkaServiceDefUpdate_J10033.class.getDeclaredMethod("updateKafkaServiceDef");
            m.setAccessible(true);
            m.invoke(patch);
        }
    }

    @Test
    public void testMain_Success_ExitZero_andFailureExitOne() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchForKafkaServiceDefUpdate_J10033 loader = new PatchForKafkaServiceDefUpdate_J10033();
            loader.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchForKafkaServiceDefUpdate_J10033.class)).thenReturn(loader);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForKafkaServiceDefUpdate_J10033.main(new String[] {});
            } catch (SecurityException se) {
                assertTrue("0".equals(se.getMessage()) || "1".equals(se.getMessage()));
            }
        } finally {
            System.setSecurityManager(originalSm);
        }

        // failure path
        SecurityManager originalSm2 = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            cliMock.when(() -> CLIUtil.getBean(PatchForKafkaServiceDefUpdate_J10033.class))
                    .thenThrow(new RuntimeException("boom"));

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchForKafkaServiceDefUpdate_J10033.main(new String[] {});
            } catch (SecurityException se) {
                assertEquals("1", se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm2);
        }
    }
}
