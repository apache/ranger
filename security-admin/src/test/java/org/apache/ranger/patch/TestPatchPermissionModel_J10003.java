/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.ranger.patch;

import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.common.RangerConstants;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXPortalUserDao;
import org.apache.ranger.db.XXPortalUserRoleDao;
import org.apache.ranger.entity.XXPortalUser;
import org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil;
import org.apache.ranger.service.XPortalUserService;
import org.apache.ranger.util.CLIUtil;
import org.apache.ranger.view.VXPortalUser;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.io.FileWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @generated by Cursor
 * @description <Unit Test for PatchPermissionModel_J10003 class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPatchPermissionModel_J10003 {
    private static void setIfPresent(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (NoSuchFieldException ignored) {
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void setStaticField(Class<?> clazz, String name, Object value) throws Exception {
        Field f = clazz.getDeclaredField(name);
        f.setAccessible(true);
        f.set(null, value);
    }

    @Test
    public void testExecLoadAndPrintStats() {
        try (MockedStatic<EmbeddedServiceDefsUtil> utilMock = Mockito.mockStatic(EmbeddedServiceDefsUtil.class)) {
            EmbeddedServiceDefsUtil util = Mockito.mock(EmbeddedServiceDefsUtil.class);
            utilMock.when(EmbeddedServiceDefsUtil::instance).thenReturn(util);

            PatchPermissionModel_J10003 patch = new PatchPermissionModel_J10003();
            RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
            XXPortalUserDao xxPortalUserDao = Mockito.mock(XXPortalUserDao.class);
            Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xxPortalUserDao);
            Mockito.when(xxPortalUserDao.getAllCount()).thenReturn(0L);

            XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
            XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);

            setIfPresent(patch, "daoManager", daoMgr);
            setIfPresent(patch, "xPortalUserService", xPortalUserService);
            setIfPresent(patch, "xUserMgr", xUserMgr);

            patch.execLoad();
            patch.printStats();
        }
    }

    @Test
    public void testAssignPermission_fileListBranch_andUnderLimitBranch() throws Exception {
        PatchPermissionModel_J10003 patch = new PatchPermissionModel_J10003();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPortalUserDao xxPortalUserDao = Mockito.mock(XXPortalUserDao.class);
        XXPortalUserRoleDao roleDao = Mockito.mock(XXPortalUserRoleDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xxPortalUserDao);
        Mockito.when(daoMgr.getXXPortalUserRole()).thenReturn(roleDao);
        Mockito.when(xxPortalUserDao.getAllCount()).thenReturn(10L); // under 500 branch

        // create a temp file with login IDs
        File f = File.createTempFile("users", ".txt");
        try (FileWriter fw = new FileWriter(f)) {
            fw.write("alice\n");
            fw.write("bob\n");
        }
        setStaticField(PatchPermissionModel_J10003.class, "usersListFileName", f.getAbsolutePath());

        // prepare users found by loginId
        XXPortalUser u1 = new XXPortalUser();
        u1.setId(1L);
        XXPortalUser u2 = new XXPortalUser();
        u2.setId(2L);
        Mockito.when(xxPortalUserDao.findByLoginId("alice")).thenReturn(u1);
        Mockito.when(xxPortalUserDao.findByLoginId("bob")).thenReturn(u2);

        List<String> roles = new ArrayList<>();
        roles.add("ROLE_USER");
        Mockito.when(roleDao.findXPortalUserRolebyXPortalUserId(Mockito.anyLong())).thenReturn(roles);

        XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
        VXPortalUser v1 = new VXPortalUser();
        v1.setId(1L);
        VXPortalUser v2 = new VXPortalUser();
        v2.setId(2L);
        Mockito.when(xPortalUserService.populateViewBean(u1)).thenReturn(v1);
        Mockito.when(xPortalUserService.populateViewBean(u2)).thenReturn(v2);

        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);

        setIfPresent(patch, "daoManager", daoMgr);
        setIfPresent(patch, "xPortalUserService", xPortalUserService);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        patch.assignPermissionToExistingUsers();
        f.delete();

        // Now remove file to drive to under-limit-all-users branch
        setStaticField(PatchPermissionModel_J10003.class, "usersListFileName", null);
        List<XXPortalUser> allUsers = new ArrayList<>();
        allUsers.add(u1);
        allUsers.add(u2);
        Mockito.when(xxPortalUserDao.findAllXPortalUser()).thenReturn(allUsers);
        patch.assignPermissionToExistingUsers();
    }

    @Test
    public void testAssignPermission_overLimitBranch_withRolesOnly() throws Exception {
        PatchPermissionModel_J10003 patch = new PatchPermissionModel_J10003();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPortalUserDao xxPortalUserDao = Mockito.mock(XXPortalUserDao.class);
        XXPortalUserRoleDao roleDao = Mockito.mock(XXPortalUserRoleDao.class);
        Mockito.when(daoMgr.getXXPortalUser()).thenReturn(xxPortalUserDao);
        Mockito.when(daoMgr.getXXPortalUserRole()).thenReturn(roleDao);
        Mockito.when(xxPortalUserDao.getAllCount()).thenReturn(1000L); // > 500 branch

        List<XXPortalUser> admins = new ArrayList<>();
        XXPortalUser a1 = new XXPortalUser();
        a1.setId(10L);
        admins.add(a1);
        Mockito.when(xxPortalUserDao.findByRole(RangerConstants.ROLE_SYS_ADMIN)).thenReturn(admins);
        Mockito.when(xxPortalUserDao.findByRole(RangerConstants.ROLE_KEY_ADMIN)).thenReturn(Collections.emptyList());

        VXPortalUser vAdmin = new VXPortalUser();
        vAdmin.setId(10L);
        XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
        Mockito.when(xPortalUserService.populateViewBean(a1)).thenReturn(vAdmin);
        Mockito.when(roleDao.findXPortalUserRolebyXPortalUserId(10L)).thenReturn(Collections.singletonList("ROLE_SYS_ADMIN"));

        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);

        setIfPresent(patch, "daoManager", daoMgr);
        setIfPresent(patch, "xPortalUserService", xPortalUserService);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        patch.assignPermissionToExistingUsers();
    }

    @Test
    public void testAssignPermissions_NullAndEmpty_NoUpdates() throws Exception {
        PatchPermissionModel_J10003 patch = new PatchPermissionModel_J10003();
        RangerDaoManager daoMgr = Mockito.mock(RangerDaoManager.class);
        XXPortalUserRoleDao roleDao = Mockito.mock(XXPortalUserRoleDao.class);
        setIfPresent(patch, "daoManager", daoMgr);
        XPortalUserService xPortalUserService = Mockito.mock(XPortalUserService.class);
        setIfPresent(patch, "xPortalUserService", xPortalUserService);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);
        setIfPresent(patch, "xUserMgr", xUserMgr);

        // empty list
        Method m = PatchPermissionModel_J10003.class.getDeclaredMethod("assignPermissions", List.class);
        m.setAccessible(true);
        Object count = m.invoke(patch, new ArrayList<XXPortalUser>());
        Assertions.assertEquals(0, count);

        // list with null and with user but xPortalUserService returns null
        List<XXPortalUser> input = new ArrayList<>();
        input.add(null);
        XXPortalUser u = new XXPortalUser();
        u.setId(100L);
        input.add(u);
        Mockito.when(xPortalUserService.populateViewBean(u)).thenReturn(null);
        count = m.invoke(patch, input);
        Assertions.assertEquals(0, count);
    }

    @Test
    public void testReadUserNamesFromFile_Variants() throws Exception {
        PatchPermissionModel_J10003 patch = new PatchPermissionModel_J10003();
        Method m = PatchPermissionModel_J10003.class.getDeclaredMethod("readUserNamesFromFile", String.class);
        m.setAccessible(true);
        // null filename
        List<?> ret = (List<?>) m.invoke(patch, new Object[] {null});
        Assertions.assertTrue(ret.isEmpty());
        // non-existent file
        ret = (List<?>) m.invoke(patch, "/tmp/does-not-exist-xyz.txt");
        Assertions.assertTrue(ret.isEmpty());
    }

    @Test
    public void testMain_AllAndFileArgs_DoNotThrow() {
        SecurityManager originalSm = System.getSecurityManager();
        try (MockedStatic<CLIUtil> cliMock = Mockito.mockStatic(CLIUtil.class)) {
            PatchPermissionModel_J10003 patch = new PatchPermissionModel_J10003();
            patch.setMoreToProcess(false);
            cliMock.when(() -> CLIUtil.getBean(PatchPermissionModel_J10003.class)).thenReturn(patch);

            System.setSecurityManager(new SecurityManager() {
                @Override
                public void checkExit(int status) {
                    throw new SecurityException(String.valueOf(status));
                }

                @Override
                public void checkPermission(Permission perm) {
                }
            });

            try {
                PatchPermissionModel_J10003.main(new String[] {"ALL"});
            } catch (SecurityException se) {
                Assertions.assertNotNull(se.getMessage());
            }

            try {
                PatchPermissionModel_J10003.main(new String[] {"/tmp/some-file.txt"});
            } catch (SecurityException se) {
                Assertions.assertNotNull(se.getMessage());
            }
        } finally {
            System.setSecurityManager(originalSm);
        }
    }
}
