/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.service;

import org.apache.ranger.common.JSONUtil;
import org.apache.ranger.common.RangerSearchUtil;
import org.apache.ranger.common.SearchField;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXPluginInfoDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.db.XXServiceDefDao;
import org.apache.ranger.db.XXServiceVersionInfoDao;
import org.apache.ranger.entity.XXPluginInfo;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.entity.XXServiceDef;
import org.apache.ranger.entity.XXServiceVersionInfo;
import org.apache.ranger.plugin.model.RangerPluginInfo;
import org.apache.ranger.plugin.store.PList;
import org.apache.ranger.plugin.util.SearchFilter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import javax.persistence.EntityManager;
import javax.persistence.Query;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RangerPluginInfoService
 */

public class TestRangerPluginInfoService {
    @InjectMocks
    private RangerPluginInfoService svc = new RangerPluginInfoService();

    @Mock private RangerDaoManager        daoManager;
    @Mock private RangerSearchUtil        searchUtil;
    @Mock private JSONUtil                jsonUtil;
    @Mock private XXPluginInfoDao         xxPluginInfoDao;
    @Mock private XXServiceDao            xxServiceDao;
    @Mock private XXServiceDefDao         xxServiceDefDao;
    @Mock private XXServiceVersionInfoDao xxServiceVersionInfoDao;
    @Mock private EntityManager           entityManager;
    @Mock private Query                   query;

    @BeforeEach
    void setup() {
        MockitoAnnotations.initMocks(this);
        when(daoManager.getXXPluginInfo()).thenReturn(xxPluginInfoDao);
        when(daoManager.getXXService()).thenReturn(xxServiceDao);
        when(daoManager.getXXServiceDef()).thenReturn(xxServiceDefDao);
        when(daoManager.getXXServiceVersionInfo()).thenReturn(xxServiceVersionInfoDao);
        when(daoManager.getEntityManager()).thenReturn(entityManager);
    }

    @Test
    void testPopulateDBObject_roundTripFields() {
        RangerPluginInfo model = new RangerPluginInfo();
        model.setId(5L);
        model.setServiceName("svc");
        model.setHostName("host");
        model.setAppType("app");
        model.setIpAddress("1.2.3.4");
        model.setInfo(Collections.singletonMap("k", "v"));
        XXPluginInfo xx = svc.populateDBObject(model);
        assertEquals(5L, xx.getId());
        assertEquals("svc", xx.getServiceName());
        assertEquals("host", xx.getHostName());
        assertEquals("app", xx.getAppType());
        assertEquals("1.2.3.4", xx.getIpAddress());
    }

    @Test
    void testPopulateViewObject_setsServiceTypeAndInfo() {
        XXPluginInfo x = new XXPluginInfo();
        x.setId(1L);
        x.setServiceName("s1");
        x.setHostName("h");
        x.setAppType("app");
        x.setIpAddress("ip");
        x.setInfo("{}");
        when(xxServiceDefDao.findServiceDefTypeByServiceName("s1")).thenReturn("hive");
        when(jsonUtil.jsonToMap("{}")).thenReturn(new HashMap<>());
        RangerPluginInfo out = svc.populateViewObject(x);
        assertEquals("hive", out.getServiceType());
        assertEquals("s1", out.getServiceName());
    }

    @Test
    void testSearchRangerPluginInfo_filtersByServiceTypeAndClusterName_andPopulatesServiceVersion() {
        SearchFilter f = new SearchFilter();
        f.setGetCount(true);
        f.setParam(SearchFilter.SERVICE_TYPE, "hive");
        f.setParam(SearchFilter.CLUSTER_NAME, "clusterA");

        // createQuery path
        // when(searchUtil.constructSortClause(any(SearchFilter.class), anyList())).thenReturn("ORDER BY obj.serviceName asc");
        when(searchUtil.createSearchQuery(any(EntityManager.class), anyString(), anyString(), any(SearchFilter.class), anyList(), eq(false), eq(false))).thenReturn(query);
        when(searchUtil.createSearchQuery(any(EntityManager.class), anyString(), isNull(), any(SearchFilter.class), anyList(), eq(false), eq(true))).thenReturn(query);
        when(query.getFirstResult()).thenReturn(0);
        when(query.getMaxResults()).thenReturn(1000);

        // Count 2
        when(xxPluginInfoDao.executeCountQueryInSecurityContext(eq(XXPluginInfo.class), any(Query.class))).thenReturn(2L);

        // Result list with two plugins
        XXPluginInfo px1 = new XXPluginInfo();
        px1.setId(10L);
        px1.setServiceName("svcA");
        px1.setHostName("h1");
        px1.setAppType("app");
        px1.setIpAddress("ip");
        px1.setInfo("{\"cluster.name\":\"clusterA\"}");
        XXPluginInfo px2 = new XXPluginInfo();
        px2.setId(11L);
        px2.setServiceName("svcB");
        px2.setHostName("h2");
        px2.setAppType("app");
        px2.setIpAddress("ip");
        px2.setInfo("{\"cluster.name\":\"clusterB\"}");
        when(xxPluginInfoDao.executeQueryInSecurityContext(eq(XXPluginInfo.class), any(Query.class))).thenReturn(Arrays.asList(px1, px2));

        // servicesWithTagService and service/version info lookups
        XXService sA = new XXService();
        sA.setName("svcA");
        sA.setDisplayName("Service A");
        when(xxServiceDao.getAllServicesWithTagService()).thenReturn(Collections.singletonList(sA));
        XXServiceVersionInfo sviA = new XXServiceVersionInfo();
        sviA.setPolicyVersion(5L);
        sviA.setPolicyUpdateTime(new Date(1000));
        sviA.setTagVersion(2L);
        sviA.setTagUpdateTime(new Date(2000));
        sviA.setGdsVersion(7L);
        sviA.setGdsUpdateTime(new Date(3000));
        when(xxServiceVersionInfoDao.getAllWithServiceNames()).thenReturn(Collections.singletonList(new Object[] {sviA, "svcA"}));
        when(xxServiceDao.findByName("svcA")).thenReturn(sA);
        XXServiceDef def = new XXServiceDef();
        def.setDisplayName("Hive");
        when(xxServiceDefDao.findServiceDefTypeByServiceName(anyString())).thenReturn("hive");
        when(xxServiceDefDao.findByName("hive")).thenReturn(def);

        // json maps
        Map<String, String> mapA = new HashMap<>();
        mapA.put(SearchFilter.CLUSTER_NAME, "clusterA");
        Map<String, String> mapB = new HashMap<>();
        mapB.put(SearchFilter.CLUSTER_NAME, "clusterB");
        when(jsonUtil.jsonToMap(px1.getInfo())).thenReturn(mapA);
        when(jsonUtil.jsonToMap(px2.getInfo())).thenReturn(mapB);

        PList<RangerPluginInfo> out = svc.searchRangerPluginInfo(f);
        assertNotNull(out);
        assertEquals(1, out.getList().size());
        RangerPluginInfo only = out.getList().get(0);
        assertEquals("svcA", only.getServiceName());
        assertEquals("Service A", only.getServiceDisplayName());
        assertEquals("Hive", only.getServiceTypeDisplayName());
        assertEquals("5", only.getInfo().get(RangerPluginInfo.RANGER_ADMIN_LATEST_POLICY_VERSION));
        assertEquals("1000", only.getInfo().get(RangerPluginInfo.RANGER_ADMIN_LAST_POLICY_UPDATE_TIME));
        assertEquals("2", only.getInfo().get(RangerPluginInfo.RANGER_ADMIN_LATEST_TAG_VERSION));
        assertEquals("2000", only.getInfo().get(RangerPluginInfo.RANGER_ADMIN_LAST_TAG_UPDATE_TIME));
        assertEquals("7", only.getInfo().get(RangerPluginInfo.RANGER_ADMIN_LATEST_GDS_VERSION));
        assertEquals("3000", only.getInfo().get(RangerPluginInfo.RANGER_ADMIN_LAST_GDS_UPDATE_TIME));
    }

    @Test
    public void testA_getFields_notEmpty() {
        RangerPluginInfoService                  svc = createSvc();
        List<SearchField>                        s   = svc.getSearchFields();
        List<org.apache.ranger.common.SortField> o   = svc.getSortFields();
        assertNotNull(s);
        assertNotNull(o);
    }

    @Test
    public void testD_searchRangerObjects_viaReflection_setsPListMeta() throws Exception {
        RangerPluginInfoService svc = createSvc();
        SearchFilter            f   = new SearchFilter();
        f.setGetCount(true);
        when(searchUtil.createSearchQuery(eq(entityManager), anyString(), anyString(), eq(f), any(), eq(false), eq(false))).thenReturn(query);
        when(searchUtil.createSearchQuery(eq(entityManager), anyString(), isNull(), eq(f), any(), eq(false), eq(true))).thenReturn(query);
        when(searchUtil.constructSortClause(eq(f), any())).thenReturn(" ORDER BY obj.serviceName asc");
        when(query.getFirstResult()).thenReturn(0);
        when(query.getMaxResults()).thenReturn(1000);
        when(xxPluginInfoDao.executeCountQueryInSecurityContext(eq(XXPluginInfo.class), eq(query))).thenReturn(1L);
        XXPluginInfo x = new XXPluginInfo();
        x.setServiceName("svc");
        x.setInfo("{}");
        when(xxPluginInfoDao.executeQueryInSecurityContext(eq(XXPluginInfo.class), eq(query))).thenReturn(Collections.singletonList(x));
        // also stub internal count query creation used by getCountForSearchQuery
        Mockito.when(searchUtil.createSearchQuery(eq(entityManager), anyString(), isNull(), eq(f), any(), eq(true)))
                .thenReturn(query);
        PList<RangerPluginInfo> pList = new PList<>();
        Method                  m     = RangerPluginInfoService.class.getDeclaredMethod("searchRangerObjects", SearchFilter.class, List.class, List.class, PList.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<XXPluginInfo> out = (List<XXPluginInfo>) m.invoke(svc, f, svc.getSearchFields(), svc.getSortFields(), pList);
        assertNotNull(out);
        assertEquals(1, out.size());
    }

    @Test
    public void testF_jsonStringToMap_reflection_variants() throws Exception {
        RangerPluginInfoService svc = createSvc();
        Method                  m   = RangerPluginInfoService.class.getDeclaredMethod("jsonStringToMap", String.class, XXServiceVersionInfo.class, boolean.class);
        m.setAccessible(true);
        Map<String, String> base = new HashMap<>();
        when(jsonUtil.jsonToMap("{}")).thenReturn(base);
        @SuppressWarnings("unchecked")
        Map<String, String> out = (Map<String, String>) m.invoke(svc, "{}", null, false);
        assertNotNull(out);
    }

    private List<SearchField> anyList() {
        return null;
    }

    private RangerPluginInfoService createSvc() {
        RangerPluginInfoService svc = new RangerPluginInfoService();
        svc.searchUtil = searchUtil;
        svc.jsonUtil   = jsonUtil;
        svc.daoManager = daoManager;
        when(daoManager.getEntityManager()).thenReturn(entityManager);
        when(daoManager.getXXPluginInfo()).thenReturn(xxPluginInfoDao);
        when(daoManager.getXXService()).thenReturn(xxServiceDao);
        when(daoManager.getXXServiceDef()).thenReturn(xxServiceDefDao);
        when(daoManager.getXXServiceVersionInfo()).thenReturn(xxServiceVersionInfoDao);
        return svc;
    }
}
