/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.ranger.service;

import org.apache.ranger.common.MessageEnums;
import org.apache.ranger.common.RESTErrorUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXGroupDao;
import org.apache.ranger.db.XXGroupPermissionDao;
import org.apache.ranger.entity.XXGroup;
import org.apache.ranger.entity.XXGroupPermission;
import org.apache.ranger.view.VXGroupPermission;
import org.apache.ranger.view.VXModuleDef;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description : Unit Test cases for XGroupPermissionService
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestXGroupPermissionService {
    @InjectMocks
    XGroupPermissionService svc;
    @Mock
    RangerDaoManager        daoMgr;
    @Mock
    XXGroupDao              groupDao;
    @Mock
    XXGroupPermissionDao    groupPermDao;
    @Mock
    RESTErrorUtil           restErrorUtil;

    @Test
    public void populateViewBean_setsGroupName() {
        XXGroupPermission x = new XXGroupPermission();
        x.setGroupId(7L);

        when(daoMgr.getXXGroup()).thenReturn(groupDao);
        XXGroup g = new XXGroup();
        g.setName("dev-group");
        when(groupDao.getById(7L)).thenReturn(g);

        VXGroupPermission v = svc.populateViewBean(x);
        assertEquals("dev-group", v.getGroupName());
    }

    @Test
    public void convertVListToVMap_keysByGroupId() {
        VXGroupPermission v1 = new VXGroupPermission();
        v1.setGroupId(1L);
        VXGroupPermission v2 = new VXGroupPermission();
        v2.setGroupId(2L);

        Map<Long, VXGroupPermission> map = svc.convertVListToVMap(Arrays.asList(v1, v2));
        assertEquals(2, map.size());
        assertEquals(v1, map.get(1L));
        assertEquals(v2, map.get(2L));
    }

    @Test
    public void getPopulatedVXGroupPermissionList_filtersAndMaps() {
        XXGroupPermission x1 = new XXGroupPermission();
        x1.setId(1L);
        x1.setGroupId(100L);
        x1.setModuleId(200L);
        x1.setIsAllowed(1);
        XXGroupPermission x2 = new XXGroupPermission();
        x2.setId(2L);
        x2.setGroupId(101L);
        x2.setModuleId(201L);
        x2.setIsAllowed(0);
        List<XXGroupPermission> in       = Arrays.asList(x1, x2);
        Map<Long, String>       groupMap = new HashMap<>();
        groupMap.put(100L, "team-a"); // only x1 present
        VXModuleDef mod = new VXModuleDef();
        mod.setModule("ops");

        List<VXGroupPermission> out = svc.getPopulatedVXGroupPermissionList(in, groupMap, mod);
        assertEquals(1, out.size());
        assertEquals(1L, out.get(0).getId());
        assertEquals(100L, out.get(0).getGroupId());
        assertEquals(200L, out.get(0).getModuleId());
        assertEquals("team-a", out.get(0).getGroupName());
        assertEquals("ops", out.get(0).getModuleName());
    }

    @Test
    public void validateForCreate_duplicate_throws() {
        VXGroupPermission v = new VXGroupPermission();
        v.setGroupId(5L);
        v.setModuleId(9L);
        when(daoMgr.getXXGroupPermission()).thenReturn(groupPermDao);
        when(groupPermDao.findByModuleIdAndGroupId(5L, 9L)).thenReturn(new XXGroupPermission());
        org.mockito.Mockito.when(restErrorUtil.createRESTException(anyString(), eq(MessageEnums.ERROR_DUPLICATE_OBJECT)))
                .thenThrow(new RuntimeException("duplicate"));
        assertThrows(RuntimeException.class, () -> svc.validateForCreate(v));
    }

    @Test
    public void validateForCreate_noDuplicate_ok() {
        VXGroupPermission v = new VXGroupPermission();
        v.setGroupId(5L);
        v.setModuleId(9L);
        when(daoMgr.getXXGroupPermission()).thenReturn(groupPermDao);
        when(groupPermDao.findByModuleIdAndGroupId(5L, 9L)).thenReturn(null);
        svc.validateForCreate(v);
    }

    @Test
    public void validateForUpdate_duplicateDifferentId_throws() {
        VXGroupPermission v = new VXGroupPermission();
        v.setId(10L);
        v.setGroupId(5L);
        v.setModuleId(9L);
        XXGroupPermission existing = new XXGroupPermission();
        existing.setId(11L);
        when(daoMgr.getXXGroupPermission()).thenReturn(groupPermDao);
        when(groupPermDao.findByModuleIdAndGroupId(5L, 9L)).thenReturn(existing);
        org.mockito.Mockito.when(restErrorUtil.createRESTException(anyString(), eq(MessageEnums.ERROR_DUPLICATE_OBJECT)))
                .thenThrow(new RuntimeException("duplicate"));
        assertThrows(RuntimeException.class, () -> svc.validateForUpdate(v, new XXGroupPermission()));
    }

    @Test
    public void validateForUpdate_duplicateSameId_ok() {
        VXGroupPermission v = new VXGroupPermission();
        v.setId(10L);
        v.setGroupId(5L);
        v.setModuleId(9L);
        XXGroupPermission existing = new XXGroupPermission();
        existing.setId(10L);
        when(daoMgr.getXXGroupPermission()).thenReturn(groupPermDao);
        when(groupPermDao.findByModuleIdAndGroupId(5L, 9L)).thenReturn(existing);
        svc.validateForUpdate(v, new XXGroupPermission());
    }
}
