/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.service;

import org.apache.ranger.common.db.RangerTransactionSynchronizationAdapter;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.XXPolicyDao;
import org.apache.ranger.db.XXRoleRefRoleDao;
import org.apache.ranger.db.XXServiceDao;
import org.apache.ranger.entity.XXRole;
import org.apache.ranger.entity.XXService;
import org.apache.ranger.plugin.model.RangerRole;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RangerRoleService
 */

public class TestRangerRoleService {
    @InjectMocks private RangerRoleService svc = spy(new RangerRoleService());

    @Mock private RangerDaoManager                        daoMgr;
    @Mock private XXRoleRefRoleDao                        xxRoleRefRoleDao;
    @Mock private XXPolicyDao                             xxPolicyDao;
    @Mock private XXServiceDao                            xxServiceDao;
    @Mock private RangerTransactionSynchronizationAdapter adapter;

    @BeforeEach
    void init() {
        MockitoAnnotations.initMocks(this);
        when(daoMgr.getXXRoleRefRole()).thenReturn(xxRoleRefRoleDao);
        when(daoMgr.getXXPolicy()).thenReturn(xxPolicyDao);
        when(daoMgr.getXXService()).thenReturn(xxServiceDao);
        when(daoMgr.getRangerTransactionSynchronizationAdapter()).thenReturn(adapter);
    }

    @Test
    void testUpdatePolicyVersions_invokesUpdaterForEachAffectedService() {
        Long roleId = 5L;
        when(xxRoleRefRoleDao.getContainingRoles(roleId)).thenReturn(Collections.emptySet());
        when(xxPolicyDao.findServiceIdsByRoleId(roleId)).thenReturn(Arrays.asList(1L, 2L));

        svc.updatePolicyVersions(roleId);

        verify(adapter, times(2)).executeOnTransactionCommit(any(Runnable.class));
    }

    @Test
    void testUpdateRoleVersions_nonTagServices() {
        Long roleId = 7L;
        when(xxRoleRefRoleDao.getContainingRoles(roleId)).thenReturn(Collections.emptySet());
        when(xxPolicyDao.findServiceIdsByRoleId(roleId)).thenReturn(Arrays.asList(10L, 20L));

        XXService s10 = new XXService();
        s10.setId(10L);
        s10.setType(0L);
        XXService s20 = new XXService();
        s20.setId(20L);
        s20.setType(0L);
        when(xxServiceDao.getById(10L)).thenReturn(s10);
        when(xxServiceDao.getById(20L)).thenReturn(s20);

        svc.updateRoleVersions(roleId);

        verify(adapter, times(2)).executeOnTransactionCommit(any(Runnable.class));
    }

    @Test
    void testUpdateRoleVersions_tagServiceAlsoUpdatesReferringServices() {
        Long roleId = 9L;
        when(xxRoleRefRoleDao.getContainingRoles(roleId)).thenReturn(Collections.emptySet());
        when(xxPolicyDao.findServiceIdsByRoleId(roleId)).thenReturn(Collections.singletonList(100L));

        XXService tagSvc = new XXService();
        tagSvc.setId(100L);
        tagSvc.setType(org.apache.ranger.plugin.store.EmbeddedServiceDefsUtil.instance().getTagServiceDefId());
        when(xxServiceDao.getById(100L)).thenReturn(tagSvc);

        XXService refSvc = new XXService();
        refSvc.setId(200L);
        when(xxServiceDao.findByTagServiceId(100L)).thenReturn(Collections.singletonList(refSvc));

        svc.updateRoleVersions(roleId);

        verify(adapter, times(2)).executeOnTransactionCommit(any(Runnable.class));
        verify(xxServiceDao).findByTagServiceId(100L);
    }

    @Test
    void testMapViewToEntityBean_setsRoleTextFromView() {
        RangerRole in = new RangerRole();
        in.setName("r");
        XXRole x      = new XXRole();
        XXRole mapped = svc.mapViewToEntityBean(in, x, 0);
        assertNotNull(mapped.getRoleText());
        assertTrue(mapped.getRoleText().contains("\"name\":\"r\""));
    }

    @Test
    void testMapEntityToViewBean_readsRoleTextIntoView() {
        RangerRole base = new RangerRole();
        RangerRole full = new RangerRole();
        full.setUsers(Collections.emptyList());
        full.setGroups(Collections.emptyList());
        full.setRoles(Collections.emptyList());
        full.setCreatedByUser("c");
        Map<String, Object> opts = new HashMap<>();
        opts.put("a", 1);
        full.setOptions(opts);

        XXRole x = new XXRole();
        x.setRoleText(org.apache.ranger.authorization.utils.JsonUtils.objectToJson(full));

        RangerRole out = svc.mapEntityToViewBean(base, x);
        assertEquals("c", out.getCreatedByUser());
        assertEquals(opts, out.getOptions());
        assertNotNull(out.getUsers());
        assertNotNull(out.getGroups());
        assertNotNull(out.getRoles());
    }
}
