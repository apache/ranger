/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.ranger.common;

import org.junit.Before;
import org.junit.Test;

import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertInstanceOf;

/**
 * @generated by Cursor
 * @description : Unit Test cases for GUIDUtil
 */

public class TestGUIDUtil {
    private GUIDUtil guidUtil;

    @Before
    public void setUp() {
        guidUtil = new GUIDUtil();
    }

    @Test
    public void testGenGUID() {
        String guid = guidUtil.genGUID();

        assertNotNull(guid);
        assertFalse(guid.isEmpty());

        // Verify it's a valid UUID format
        assertDoesNotThrow(() -> UUID.fromString(guid));
    }

    @Test
    public void testGenGUIDFormat() {
        String guid = guidUtil.genGUID();

        // UUID format is: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36 characters with 4 hyphens)
        assertEquals(36, guid.length());
        assertEquals(4, guid.split("-").length - 1); // Count hyphens

        // Verify the format pattern
        assertTrue(guid.matches("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"));
    }

    @Test
    public void testGenGUIDUniqueness() {
        Set<String> guids         = new HashSet<>();
        int         numberOfGuids = 1000;

        // Generate multiple GUIDs and verify uniqueness
        for (int i = 0; i < numberOfGuids; i++) {
            String guid = guidUtil.genGUID();
            guids.add(guid);
        }

        assertEquals(numberOfGuids, guids.size());
    }

    @Test
    public void testGenGUIDConsecutiveCalls() {
        String guid1 = guidUtil.genGUID();
        String guid2 = guidUtil.genGUID();

        assertNotNull(guid1);
        assertNotNull(guid2);
        assertNotEquals(guid1, guid2, "Consecutive calls should generate different GUIDs");
    }

    @Test
    public void testGenLong() {
        long value = guidUtil.genLong();

        // The value should be the most significant bits of a UUID
        assertNotNull(value);
    }

    @Test
    public void testGenLongUniqueness() {
        Set<Long> longValues     = new HashSet<>();
        int       numberOfValues = 1000;

        // Generate multiple long values and verify uniqueness
        for (int i = 0; i < numberOfValues; i++) {
            long value = guidUtil.genLong();
            longValues.add(value);
        }
    }

    @Test
    public void testGenLongConsecutiveCalls() {
        long value1 = guidUtil.genLong();
        long value2 = guidUtil.genLong();
    }

    @Test
    public void testGenLongRange() {
        long value = guidUtil.genLong();

        // The value should be within the range of long values
        assertTrue(value >= Long.MIN_VALUE);
        assertTrue(value <= Long.MAX_VALUE);
    }

    @Test
    public void testSerializableImplementation() {
        assertInstanceOf(Serializable.class, guidUtil);
    }

    @Test
    public void testGUIDAndLongRelationship() {
        // Since genLong() uses UUID.randomUUID().getMostSignificantBits(),
        // we can verify the relationship
        String guid         = guidUtil.genGUID();
        UUID   uuid         = UUID.fromString(guid);
        long   expectedLong = uuid.getMostSignificantBits();

        // We can't directly test this since genLong() creates a new UUID,
        // but we can verify that the concept works
        assertNotNull(expectedLong);
    }

    @Test
    public void testMultipleInstancesBehavior() {
        GUIDUtil util1 = new GUIDUtil();
        GUIDUtil util2 = new GUIDUtil();

        String guid1 = util1.genGUID();
        String guid2 = util2.genGUID();

        assertNotEquals(guid1, guid2, "Different instances should generate different GUIDs");

        long long1 = util1.genLong();
        long long2 = util2.genLong();

        assertNotEquals(String.valueOf(long1), long2, "Different instances should generate different long values");
    }

    @Test
    public void testPerformance() {
        int  iterations = 10000;
        long startTime  = System.currentTimeMillis();

        for (int i = 0; i < iterations; i++) {
            guidUtil.genGUID();
        }

        long endTime  = System.currentTimeMillis();
        long duration = endTime - startTime;
    }

    @Test
    public void testLongPerformance() {
        int  iterations = 10000;
        long startTime  = System.currentTimeMillis();

        for (int i = 0; i < iterations; i++) {
            guidUtil.genLong();
        }

        long endTime  = System.currentTimeMillis();
        long duration = endTime - startTime;
    }
}
