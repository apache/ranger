/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.common.db;

import org.apache.ranger.biz.RangerBizUtil;
import org.apache.ranger.common.PropertiesUtil;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.db.RangerDaoManagerBase;
import org.apache.ranger.entity.XXDBBase;
import org.apache.ranger.security.context.RangerContextHolder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.Table;
import javax.persistence.TypedQuery;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description : Unit Test cases for BaseDao
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestBaseDao {
    @Mock
    public RangerDaoManager daoManager;
    @Mock
    public EntityManager    em;

    // ensure bulk mode is disabled and context is clean before each test
    @BeforeEach
    public void resetBulkModeContext() {
        RangerContextHolder.resetOpContext();
        RangerBizUtil.setBulkMode(false);
    }

    @Test
    public void test1_constructor_usesDefaultEntityManager() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao dao = new TestDao(daoManager);
        assertNotNull(dao.getEntityManager());
        assertEquals(em, dao.getEntityManager());
    }

    @Test
    public void test2_constructor_withUnit_usesNamedEntityManager() {
        when(daoManager.getEntityManager("pu")).thenReturn(em);
        TestDao dao = new TestDao(daoManager, "pu");
        assertEquals(em, dao.getEntityManager());
    }

    @Test
    public void test4_create_withFlushFlagHonored() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao    dao = new TestDao(daoManager);
        TestEntity te  = new TestEntity();
        dao.create(te, false);
        verify(em).persist(te);
        verify(em, times(0)).flush();
        dao.create(te, true);
        verify(em, times(1)).flush();
    }

    @Test
    public void test5_update_mergesAndFlushesWhenNotBulk() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao    dao = new TestDao(daoManager);
        TestEntity te  = new TestEntity();
        dao.update(te);
        verify(em).merge(te);
        verify(em).flush();
    }

    @Test
    public void test6_update_withFlushFlagHonored() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao    dao = new TestDao(daoManager);
        TestEntity te  = new TestEntity();
        dao.update(te, false);
        verify(em).merge(te);
        verify(em, times(0)).flush();
    }

    @Test
    public void test7_remove_byObject_handlesMergeWhenDetached() {
        when(daoManager.getEntityManager()).thenReturn(em);
        when(em.contains(any())).thenReturn(false);
        TestEntity merged = new TestEntity();
        when(em.merge(any())).thenReturn(merged);
        TestDao dao = new TestDao(daoManager);
        assertTrue(dao.remove(new TestEntity()));
        verify(em).remove(merged);
    }

    @Test
    public void test8_remove_byId_invokesFindAndRemove() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestEntity e = new TestEntity();
        when(em.find(TestEntity.class, 5L)).thenReturn(e);
        TestDao dao = new TestDao(daoManager);
        assertTrue(dao.remove(5L));
    }

    @Test
    public void test9_findByNamedQuery_and_findByParentId() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TypedQuery<TestEntity> tq = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(TestEntity.class))).thenReturn(tq);
        List<TestEntity> list = new ArrayList<>();
        list.add(new TestEntity());
        when(tq.setParameter(anyString(), any())).thenReturn(tq);
        when(tq.getResultList()).thenReturn(list);
        TestDao          dao = new TestDao(daoManager);
        List<TestEntity> out = dao.findByNamedQuery("Q", "p", 1L);
        assertEquals(1, out.size());
        List<TestEntity> out2 = dao.findByParentId(2L);
        assertNotNull(out2);
    }

    @Test
    public void test10_getAll_and_getAllCount() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TypedQuery<TestEntity> tq = mock(TypedQuery.class);
        when(em.createQuery(anyString(), eq(TestEntity.class))).thenReturn(tq);
        when(tq.getResultList()).thenReturn(Collections.singletonList(new TestEntity()));
        TestDao dao = new TestDao(daoManager);
        assertEquals(1, dao.getAll().size());

        TypedQuery<Long> tqc = mock(TypedQuery.class);
        when(em.createQuery(anyString(), eq(Long.class))).thenReturn(tqc);
        when(tqc.getSingleResult()).thenReturn(5L);
        assertEquals(5L, dao.getAllCount());
    }

    @Test
    public void test11_executeQueryAndCount_helpers() {
        when(daoManager.getEntityManager()).thenReturn(em);
        Query q = mock(Query.class);
        when(q.getResultList()).thenReturn(Collections.emptyList());
        when(q.getSingleResult()).thenReturn(2L);
        TestDao dao = new TestDao(daoManager);
        assertNotNull(dao.executeQueryInSecurityContext(TestEntity.class, q));
        assertEquals(2L, (long) dao.executeCountQueryInSecurityContext(TestEntity.class, q));
    }

    @Test
    public void test12_flush_and_clear_delegateToEntityManager() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao dao = new TestDao(daoManager);
        dao.flush();
        verify(em).flush();
        dao.clear();
        verify(em).clear();
    }

    @Test
    public void test13_batchCreate_persistsAll_and_flushes() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao          dao  = new TestDao(daoManager);
        List<TestEntity> list = Arrays.asList(new TestEntity(), new TestEntity());
        dao.batchCreate(list);
        verify(em, times(2)).persist(any());
    }

    @Test
    public void test14_batchDeleteByIds_executesNamedQuery() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TypedQuery<TestEntity> nq = mock(TypedQuery.class);
        when(em.createNamedQuery(anyString(), eq(TestEntity.class))).thenReturn(nq);
        when(nq.setParameter(anyString(), any())).thenReturn(nq);
        when(nq.executeUpdate()).thenReturn(3);
        TestDao dao = new TestDao(daoManager);
        dao.batchDeleteByIds("Named", Arrays.asList(1L, 2L, 3L), "ids");
        verify(em).createNamedQuery(anyString(), eq(TestEntity.class));
    }

    @Test
    public void test15_updateUserIDReference_updatesWhenAnnotated() {
        when(daoManager.getEntityManager()).thenReturn(em);
        javax.persistence.Query nq = mock(javax.persistence.Query.class);
        when(em.createNativeQuery(anyString())).thenReturn(nq);
        when(nq.executeUpdate()).thenReturn(2);
        TestDao dao = new TestDao(daoManager);
        dao.updateUserIDReference("ADDED_BY_ID", 99L);
        verify(em).createNativeQuery(anyString());
    }

    @Test
    public void test16_setIdentityInsert_nonSqlServer_returnsEarly_or_preparesStatement() throws Exception {
        when(daoManager.getEntityManager()).thenReturn(em);
        // Most environments won't be SQL Server -> method should return early; still invoke for coverage
        TestDao dao = new TestDao(daoManager);
        dao.setIdentityInsert(true);
    }

    @Test
    public void test17_getById_handlesNoResult() {
        when(daoManager.getEntityManager()).thenReturn(em);
        when(em.find(TestEntity.class, 1L)).thenReturn(new TestEntity());
        TestDao dao = new TestDao(daoManager);
        assertNotNull(dao.getById(1L));
    }

    @Test
    public void test18_create_returnsSameObject_andPersists() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao    dao = new TestDao(daoManager);
        TestEntity te  = new TestEntity();
        TestEntity out = dao.create(te);
        assertEquals(te, out);
        verify(em).persist(te);
    }

    @Test
    public void test19_remove_withFlushFlag_and_nullInput() {
        when(daoManager.getEntityManager()).thenReturn(em);
        TestDao dao = new TestDao(daoManager);
        // null should return true and do nothing
        assertTrue(dao.remove(null, true));
        // non-null should remove and flush when flag true
        TestEntity te = new TestEntity();
        assertTrue(dao.remove(te, true));
        verify(em).remove(te);
        verify(em).flush();
    }

    @Test
    public void test20_getIds_returnsListFromQuery() {
        when(daoManager.getEntityManager()).thenReturn(em);
        Query q = mock(Query.class);
        when(q.getResultList()).thenReturn(Arrays.asList(1L, 2L, 3L));
        TestDao dao = new TestDao(daoManager);
        assertEquals(Arrays.asList(1L, 2L, 3L), dao.getIds(q));
    }

    @Test
    public void test21_updateSequence_oracle_executesUpdates() {
        when(daoManager.getEntityManager()).thenReturn(em);
        String old = PropertiesUtil.getPropertiesMap().get("xa.db.flavor");
        try {
            PropertiesUtil.getPropertiesMap().put("xa.db.flavor", "oracle");
            Query nq = mock(Query.class);
            when(em.createNativeQuery(anyString())).thenReturn(nq);
            when(nq.executeUpdate()).thenReturn(1);
            TestDao dao = new TestDao(daoManager);
            dao.updateSequence("seq_test", 10L);
        } finally {
            if (old == null) {
                PropertiesUtil.getPropertiesMap().remove("xa.db.flavor");
            } else {
                PropertiesUtil.getPropertiesMap().put("xa.db.flavor", old);
            }
        }
    }

    @Test
    public void test22_updateSequence_postgres_callsSetval() {
        when(daoManager.getEntityManager()).thenReturn(em);
        String old = PropertiesUtil.getPropertiesMap().get("xa.db.flavor");
        try {
            PropertiesUtil.getPropertiesMap().put("xa.db.flavor", "postgresql");
            Query nq = mock(Query.class);
            when(em.createNativeQuery(anyString())).thenReturn(nq);
            when(nq.getSingleResult()).thenReturn(1L);
            TestDao dao = new TestDao(daoManager);
            dao.updateSequence("seq_test", 25L);
        } finally {
            if (old == null) {
                PropertiesUtil.getPropertiesMap().remove("xa.db.flavor");
            } else {
                PropertiesUtil.getPropertiesMap().put("xa.db.flavor", old);
            }
        }
    }

    @Test
    public void test23_getDBVersion_returnsFromQuery_whenFlavorHasQuery() {
        when(daoManager.getEntityManager()).thenReturn(em);
        String old = PropertiesUtil.getPropertiesMap().get("xa.db.flavor");
        try {
            PropertiesUtil.getPropertiesMap().put("xa.db.flavor", "mysql");
            Query nq = mock(Query.class);
            when(em.createNativeQuery(anyString())).thenReturn(nq);
            when(nq.getSingleResult()).thenReturn("ver-1");
            TestDao dao = new TestDao(daoManager);
            assertEquals("ver-1", dao.getDBVersion());
        } finally {
            if (old == null) {
                PropertiesUtil.getPropertiesMap().remove("xa.db.flavor");
            } else {
                PropertiesUtil.getPropertiesMap().put("xa.db.flavor", old);
            }
        }
    }

    @Test
    public void test24_getDBVersion_returnsNotAvailable_whenNoQuery() {
        when(daoManager.getEntityManager()).thenReturn(em);
        String old = PropertiesUtil.getPropertiesMap().get("xa.db.flavor");
        try {
            PropertiesUtil.getPropertiesMap().put("xa.db.flavor", "unknown-db");
            TestDao dao = new TestDao(daoManager);
            assertEquals("Not Available", dao.getDBVersion());
        } finally {
            if (old == null) {
                PropertiesUtil.getPropertiesMap().remove("xa.db.flavor");
            } else {
                PropertiesUtil.getPropertiesMap().put("xa.db.flavor", old);
            }
        }
    }

    @Table(name = "x_gds_test_tbl")
    public static class TestEntity extends XXDBBase {
        private Long id = 1L;

        @Override
        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }
    }

    public static class TestDao extends BaseDao<TestEntity> {
        public TestDao(RangerDaoManagerBase daoManager) {
            super(daoManager);
        }

        public TestDao(RangerDaoManagerBase daoManager, String pu) {
            super(daoManager, pu);
        }
    }
}
