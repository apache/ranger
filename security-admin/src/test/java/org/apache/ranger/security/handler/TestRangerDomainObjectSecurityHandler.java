/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.ranger.security.handler;

import org.apache.ranger.common.UserSessionBase;
import org.apache.ranger.db.RangerDaoManager;
import org.apache.ranger.entity.XXDBBase;
import org.apache.ranger.security.context.RangerContextHolder;
import org.apache.ranger.security.context.RangerSecurityContext;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.persistence.EntityManager;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
* @generated by Cursor
* @description <Unit Test for TestRangerDomainObjectSecurityHandler class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerDomainObjectSecurityHandler {
    private RangerDomainObjectSecurityHandler handler;
    private RangerDaoManager                  daoManager;
    private EntityManager                     entityManager;

    @BeforeEach
    public void setUp() {
        handler            = new RangerDomainObjectSecurityHandler();
        daoManager         = mock(RangerDaoManager.class);
        entityManager      = mock(EntityManager.class);
        handler.daoManager = daoManager;
    }

    @AfterEach
    public void tearDownContext() {
        RangerContextHolder.setSecurityContext(new RangerSecurityContext());
    }

    @Test
    public void hasAccess_withDomainObject_returnsTrue() {
        TestEntity e = new TestEntity();
        assertTrue(handler.hasAccess(e, Permission.PermissionType.READ));
    }

    @Test
    public void hasAccess_withClassAndId_delegatesToFindAndReturnsTrue() {
        when(daoManager.getEntityManager()).thenReturn(entityManager);
        TestEntity found = new TestEntity();
        when(entityManager.find(TestEntity.class, 1L)).thenReturn(found);
        assertTrue(handler.hasAccess(TestEntity.class, 1L, Permission.PermissionType.UPDATE));
        verify(entityManager).find(TestEntity.class, 1L);
    }

    @Test
    public void hasAccess_withInvalidClassName_returnsFalse() {
        assertFalse(handler.hasAccess("com.example.DoesNotExist", 1L, Permission.PermissionType.DELETE));
    }

    @Test
    public void hasAccess_withClassName_successPath() {
        when(daoManager.getEntityManager()).thenReturn(entityManager);
        when(entityManager.find(TestEntity.class, 2L)).thenReturn(new TestEntity());
        boolean result = handler.hasAccess(TestEntity.class.getName(), 2L, Permission.PermissionType.CREATE);
        assertTrue(result);
    }

    @Test
    public void hasModeratorPermission_trueWhenUserAdmin() {
        RangerSecurityContext context = new RangerSecurityContext();
        UserSessionBase       session = new UserSessionBase();
        session.setUserAdmin(true);
        context.setUserSession(session);
        RangerContextHolder.setSecurityContext(context);

        assertTrue(handler.hasModeratorPermission());
    }

    @Test
    public void hasModeratorPermission_falseWhenNoSessionOrNotAdmin() {
        RangerContextHolder.setSecurityContext(new RangerSecurityContext());
        assertFalse(handler.hasModeratorPermission());

        RangerSecurityContext context = new RangerSecurityContext();
        UserSessionBase       session = new UserSessionBase();
        session.setUserAdmin(false);
        context.setUserSession(session);
        RangerContextHolder.setSecurityContext(context);
        assertFalse(handler.hasModeratorPermission());
    }

    @Test
    public void hasAccess_withClassAndId_exceptionReturnsFalse() {
        when(daoManager.getEntityManager()).thenReturn(entityManager);
        doThrow(new RuntimeException("boom")).when(entityManager).find(TestEntity.class, 3L);
        assertFalse(handler.hasAccess(TestEntity.class, 3L, Permission.PermissionType.READ));
    }

    static class TestEntity extends XXDBBase {
        private Long id;

        @Override
        public Long getId() {
            return id;
        }

        @Override
        public void setId(Long id) {
            this.id = id;
        }
    }
}
