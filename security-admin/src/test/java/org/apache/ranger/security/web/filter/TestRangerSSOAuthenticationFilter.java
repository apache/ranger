/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.security.web.filter;

import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSObject;
import com.nimbusds.jose.util.Base64URL;
import com.nimbusds.jwt.SignedJWT;
import org.apache.ranger.biz.UserMgr;
import org.apache.ranger.common.PropertiesUtil;
import org.apache.ranger.common.UserSessionBase;
import org.apache.ranger.security.context.RangerContextHolder;
import org.apache.ranger.security.context.RangerSecurityContext;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;

import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Vector;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description <Unit Test for TestRangerSSOAuthenticationFilter class>
 */
@TestMethodOrder(MethodOrderer.MethodName.class)
@ExtendWith(MockitoExtension.class)
public class TestRangerSSOAuthenticationFilter {
    private SSOAuthenticationProperties makeProps() {
        SSOAuthenticationProperties p = new SSOAuthenticationProperties();
        p.setAuthenticationProviderUrl("https://knox/gateway/knoxsso/api/v1/websso");
        p.setCookieName("hadoop-jwt");
        p.setOriginalUrlQueryParam("originalUrl");
        p.setUserAgentList(new String[] {"Mozilla", "Chrome" });
        p.setAudiences(Arrays.asList("ranger-admin"));
        p.setExpectedSigAlg("RS256");
        return p;
    }

    @Test
    public void testConstructorsAndInitDestroy() throws Exception {
        RangerSSOAuthenticationFilter filter1 = new RangerSSOAuthenticationFilter();
        RangerSSOAuthenticationFilter filter2 = new RangerSSOAuthenticationFilter(makeProps());
        assertNotNull(filter1);
        assertNotNull(filter2);

        FilterConfig cfg = Mockito.mock(FilterConfig.class);
        assertDoesNotThrow(() -> filter1.init(cfg));
        assertDoesNotThrow(filter1::destroy);
    }

    @Test
    public void testParseRSAPublicKey_throwsOnInvalid() {
        assertThrows(ServletException.class, () -> RangerSSOAuthenticationFilter.parseRSAPublicKey("invalidpem"));
    }

    @Test
    public void testGetJwtProperties_nullWhenDisabledOrMissing() {
        PropertiesUtil.getPropertiesMap().clear();
        PropertiesUtil.getPropertiesMap().put("ranger.sso.providerurl", "https://knox/sso");
        PropertiesUtil.getPropertiesMap().put("ranger.sso.enabled", "false");
        RangerSSOAuthenticationFilter filter = new RangerSSOAuthenticationFilter();
        assertNull(filter.getJwtProperties());
    }

    @Test
    public void testGetJwtProperties_presentWhenEnabled() {
        PropertiesUtil.getPropertiesMap().clear();
        PropertiesUtil.getPropertiesMap().put("ranger.sso.providerurl", "https://knox/sso");
        PropertiesUtil.getPropertiesMap().put("ranger.sso.enabled", "true");
        PropertiesUtil.getPropertiesMap().put("ranger.sso.publicKey", "invalid"); // will log error, still returns props
        PropertiesUtil.getPropertiesMap().put("ranger.sso.cookiename", "hadoop-jwt");
        PropertiesUtil.getPropertiesMap().put("ranger.sso.query.param.originalurl", "originalUrl");
        SSOAuthenticationProperties props = new RangerSSOAuthenticationFilter().getJwtProperties();
        assertNotNull(props);
        assertEquals("hadoop-jwt", props.getCookieName());
        assertEquals("originalUrl", props.getOriginalUrlQueryParam());
    }

    @Test
    public void testGetJWTFromCookie_findsCookie() {
        RangerSSOAuthenticationFilter filter = new RangerSSOAuthenticationFilter(makeProps());
        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        Cookie jwt = new Cookie("hadoop-jwt", "token123");
        when(req.getCookies()).thenReturn(new Cookie[] {jwt});
        assertEquals("token123", filter.getJWTFromCookie(req));
    }

    @Test
    public void testValidateToken_chaining() throws Exception {
        RangerSSOAuthenticationFilter filter = new RangerSSOAuthenticationFilter(makeProps()) {
            boolean isSignatureValid;
            boolean isExpirationValid;
            boolean isAudienceValid;

            @Override
            protected boolean validateSignature(SignedJWT t) {
                return isSignatureValid;
            }

            @Override
            protected boolean validateExpiration(SignedJWT t) {
                return isExpirationValid;
            }

            @Override
            protected boolean validateAudiences(SignedJWT t) {
                return isAudienceValid;
            }
        };
        SignedJWT token = Mockito.mock(SignedJWT.class);

        // signature false -> false
        setBooleanFields(filter, false, false, false);
        assertFalse(filter.validateToken(token));
        // signature true but expiration false -> false
        setBooleanFields(filter, true, false, false);
        assertFalse(filter.validateToken(token));
        // sig+exp true but audience false -> false
        setBooleanFields(filter, true, true, false);
        assertFalse(filter.validateToken(token));
        // all true -> true
        setBooleanFields(filter, true, true, true);
        assertTrue(filter.validateToken(token));
    }

    private void setBooleanFields(RangerSSOAuthenticationFilter f, boolean s, boolean e, boolean a) throws Exception {
        // using reflection to set the fields in the anonymous subclass
        Field sf = f.getClass().getDeclaredField("isSignatureValid");
        sf.setAccessible(true);
        sf.setBoolean(f, s);
        Field ef = f.getClass().getDeclaredField("isExpirationValid");
        ef.setAccessible(true);
        ef.setBoolean(f, e);
        Field af = f.getClass().getDeclaredField("isAudienceValid");
        af.setAccessible(true);
        af.setBoolean(f, a);
    }

    @Test
    public void testValidateSignature_handlesExceptionsAndAlgMismatch() throws Exception {
        SSOAuthenticationProperties props = makeProps();
        props.setExpectedSigAlg("ES256");
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(props);
        // Case 1: publicKey null, verify path throws inside -> false
        SignedJWT parsed = SignedJWT.parse("eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhIn0.signature");
        assertFalse(f.validateSignature(parsed));

        // Case 2: provide dummy public key and force verify true then alg mismatch -> false
        RSAPublicKey dummyKey = Mockito.mock(RSAPublicKey.class);
        Field pk = RangerSSOAuthenticationFilter.class.getDeclaredField("publicKey");
        pk.setAccessible(true);
        pk.set(f, dummyKey);

        SignedJWT mockJwt = Mockito.mock(SignedJWT.class);
        when(mockJwt.getState()).thenReturn(JWSObject.State.SIGNED);
        when(mockJwt.getSignature()).thenReturn(new Base64URL("AA"));
        when(mockJwt.verify(any())).thenReturn(true);
        JWSHeader header = Mockito.mock(JWSHeader.class);
        when(header.getAlgorithm()).thenReturn(JWSAlgorithm.RS256);
        when(mockJwt.getHeader()).thenReturn(header);
        assertFalse(f.validateSignature(mockJwt));
    }

    @Test
    public void testValidateExpiration() throws Exception {
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());
        SignedJWT jwt = Mockito.mock(SignedJWT.class);
        com.nimbusds.jwt.JWTClaimsSet claims = Mockito.mock(com.nimbusds.jwt.JWTClaimsSet.class);
        when(jwt.getJWTClaimsSet()).thenReturn(claims);

        // null expiration -> true
        when(claims.getExpirationTime()).thenReturn(null);
        assertTrue(f.validateExpiration(jwt));

        // future expiration -> true
        when(claims.getExpirationTime()).thenReturn(new Date(System.currentTimeMillis() + 60000));
        assertTrue(f.validateExpiration(jwt));

        // past expiration -> false
        when(claims.getExpirationTime()).thenReturn(new Date(System.currentTimeMillis() - 60000));
        assertFalse(f.validateExpiration(jwt));
    }

    @Test
    public void testValidateAudiences() throws Exception {
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());
        SignedJWT jwt = Mockito.mock(SignedJWT.class);
        com.nimbusds.jwt.JWTClaimsSet claims = Mockito.mock(com.nimbusds.jwt.JWTClaimsSet.class);
        when(jwt.getJWTClaimsSet()).thenReturn(claims);

        // token with matching audience -> true
        when(claims.getAudience()).thenReturn(Collections.singletonList("ranger-admin"));
        assertTrue(f.validateAudiences(jwt));

        // token with non-matching audience -> false
        when(claims.getAudience()).thenReturn(Collections.singletonList("other"));
        assertFalse(f.validateAudiences(jwt));
    }

    @Test
    public void testConstructLoginURLForApi() throws Exception {
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());
        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/app"));
        when(req.getRequestURI()).thenReturn("/app");
        String url = f.constructLoginURLForApi(req, "");
        assertTrue(url.startsWith("https://knox/gateway/knoxsso/api/v1/websso"));
    }

    @Test
    public void testIsBrowserAgent() {
        PropertiesUtil.getPropertiesMap().put("ranger.krb.browser-useragents-regex", "Mozilla,Chrome");
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());
        assertTrue(f.isBrowserAgent("Mozilla/5.0"));
        assertFalse(f.isBrowserAgent("curl/8.0"));
    }

    @Test
    public void testPrivate_isWebUserAgent_and_isAuthenticated_viaReflection() throws Exception {
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());
        Method isWeb = RangerSSOAuthenticationFilter.class.getDeclaredMethod("isWebUserAgent", String.class);
        isWeb.setAccessible(true);
        assertTrue((Boolean) isWeb.invoke(f, "Mozilla/5.0"));
        assertFalse((Boolean) isWeb.invoke(f, "curl/8.0"));

        // isAuthenticated: with no auth
        Method isAuth = RangerSSOAuthenticationFilter.class.getDeclaredMethod("isAuthenticated");
        isAuth.setAccessible(true);
        SecurityContextHolder.clearContext();
        assertFalse((Boolean) isAuth.invoke(f));

        // with authenticated UsernamePasswordAuthenticationToken via 3-arg constructor
        SecurityContextHolder.clearContext();
        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken("u", "p", Collections.emptyList()));
        assertTrue((Boolean) isAuth.invoke(f));

        // with SSOAuthentication instance should return false
        SecurityContextHolder.getContext()
                .setAuthentication(new SSOAuthentication(SignedJWT.parse("eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhIn0.sig")));
        assertFalse((Boolean) isAuth.invoke(f));
    }

    @Test
    public void testDoFilter_localloginAttributeSkips() throws Exception {
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());
        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);
        ServletContext sc = Mockito.mock(ServletContext.class);
        HttpSession sess = Mockito.mock(HttpSession.class);

        when(req.getRequestedSessionId()).thenReturn("sid");
        when(req.isRequestedSessionIdValid()).thenReturn(false);
        when(req.getServletContext()).thenReturn(sc);
        when(sc.getAttribute("sid")).thenReturn("locallogin");
        when(req.getSession()).thenReturn(sess);
        doNothing().when(sess).setAttribute("locallogin", "true");
        doNothing().when(sc).removeAttribute("sid");

        when(req.getSession()).thenReturn(sess);
        when(sess.getAttribute("locallogin")).thenReturn("true");
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());

        f.doFilter(req, res, chain);

        verify(chain, times(1)).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }

    @Test
    public void testDoFilter_withValidJwtSetsAuthentication() throws Exception {
        RangerSSOAuthenticationFilter filter = new RangerSSOAuthenticationFilter(makeProps());
        assertNotNull(filter);
    }

    @Test
    public void testDoFilter_localloginUrlRedirectsWhenAuthenticated() throws Exception {
        SecurityContextHolder.clearContext();
        RangerSecurityContext ctx = new RangerSecurityContext();
        UserSessionBase session = new UserSessionBase();
        session.setSSOEnabled(Boolean.TRUE);
        ctx.setUserSession(session);
        RangerContextHolder.setSecurityContext(ctx);

        // Set an already authenticated user
        SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken("bob", "", Collections.emptyList()));

        RangerSSOAuthenticationFilter filter = new RangerSSOAuthenticationFilter(makeProps());

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(req.getHeader("User-Agent")).thenReturn("Mozilla/5.0");
        when(req.getRequestURI()).thenReturn("/locallogin/home");
        Vector<String> headerNames = new Vector<>();
        when(req.getHeaderNames()).thenReturn(headerNames.elements());

        filter.doFilter(req, res, chain);

        verify(res, times(1)).sendRedirect("/home");
    }

    @Test
    public void testDoFilter_redirectsWhenSsoEnabledNoToken() throws Exception {
        SecurityContextHolder.clearContext();
        RangerSecurityContext ctx = new RangerSecurityContext();
        UserSessionBase session = new UserSessionBase();
        session.setSSOEnabled(Boolean.TRUE);
        ctx.setUserSession(session);
        RangerContextHolder.setSecurityContext(ctx);

        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(req.getHeader("User-Agent")).thenReturn("Mozilla/5.0");
        when(req.getRequestURI()).thenReturn("/index.html");
        when(req.getSession()).thenReturn(Mockito.mock(HttpSession.class));
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/index.html"));

        f.doFilter(req, res, chain);

        verify(res, times(1)).sendRedirect(Mockito.anyString());
    }

    @Test
    public void testDoFilter_ajaxSetsHeadersWhenNoToken() throws Exception {
        RangerSecurityContext ctx = new RangerSecurityContext();
        UserSessionBase session = new UserSessionBase();
        session.setSSOEnabled(Boolean.TRUE);
        ctx.setUserSession(session);
        RangerContextHolder.setSecurityContext(ctx);

        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(req.getHeader("User-Agent")).thenReturn("Mozilla/5.0");
        when(req.getHeader("X-Requested-With")).thenReturn("XMLHttpRequest");
        when(req.getRequestURI()).thenReturn("/index.html");
        when(req.getSession()).thenReturn(Mockito.mock(HttpSession.class));
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/index.html"));

        f.doFilter(req, res, chain);

        verify(res, times(1)).setHeader("X-Frame-Options", "DENY");
        verify(res, times(1)).setStatus(Mockito.anyInt());
        verify(res, times(1)).setHeader(Mockito.eq("X-Rngr-Redirect-Url"), Mockito.anyString());
    }

    @Test
    public void testPrivateGetAuthoritiesAndGetGrantedAuthority_viaReflection() throws Exception {
        RangerSSOAuthenticationFilter filter = new RangerSSOAuthenticationFilter(makeProps());
        // inject userMgr
        UserMgr userMgr = mock(UserMgr.class);
        when(userMgr.getRolesByLoginId("bob")).thenReturn(Arrays.asList("ROLE_USER", "ROLE_ADMIN"));
        Field uf = RangerSSOAuthenticationFilter.class.getDeclaredField("userMgr");
        uf.setAccessible(true);
        uf.set(filter, userMgr);

        Method mAuths = RangerSSOAuthenticationFilter.class.getDeclaredMethod("getAuthorities", String.class);
        mAuths.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<GrantedAuthority> roles = (List<GrantedAuthority>) mAuths.invoke(filter, "bob");
        assertNotNull(roles);
        assertEquals(2, roles.size());

        Method mGranted = RangerSSOAuthenticationFilter.class.getDeclaredMethod("getGrantedAuthority", Authentication.class);
        mGranted.setAccessible(true);
        Authentication input = new UsernamePasswordAuthenticationToken("bob", "", Collections.emptyList());
        Authentication out = (Authentication) mGranted.invoke(filter, input);
        assertNotNull(out);
        Object principal = out.getPrincipal();
        assertTrue(principal instanceof User);
        assertEquals("bob", ((User) principal).getUsername());
    }

    @Test
    public void testDoFilter_ssoEnabled_invalidToken_browserRedirects() throws Exception {
        // Enable SSO via session
        SecurityContextHolder.clearContext();
        RangerSecurityContext ctx = new RangerSecurityContext();
        UserSessionBase session = new UserSessionBase();
        session.setSSOEnabled(Boolean.TRUE);
        ctx.setUserSession(session);
        RangerContextHolder.setSecurityContext(ctx);

        // Filter with properties
        SSOAuthenticationProperties p = makeProps();
        // Provide a public key but we'll mock token to fail validation chain
        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(p) {
            @Override
            protected boolean validateToken(SignedJWT jwtToken) {
                return false; // force invalid
            }
        };

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(req.getHeader("User-Agent")).thenReturn("Mozilla/5.0");
        when(req.getHeader("X-Requested-With")).thenReturn(null);
        when(req.getRequestURI()).thenReturn("/index.html");
        when(req.getSession()).thenReturn(Mockito.mock(HttpSession.class));
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/index.html"));
        // Provide JWT cookie so branch goes into validateToken, then invalid path
        Cookie jwt = new Cookie(p.getCookieName(), "eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhIn0.sign");
        when(req.getCookies()).thenReturn(new Cookie[] {jwt});

        f.doFilter(req, res, chain);

        verify(res, times(1)).sendRedirect(Mockito.anyString());
        verify(chain, times(0)).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }

    @Test
    public void testDoFilter_ssoDisabled_locallogin_redirectsToLoginJsp() throws Exception {
        SecurityContextHolder.clearContext();
        RangerContextHolder.setSecurityContext(new RangerSecurityContext());

        RangerSSOAuthenticationFilter f = new RangerSSOAuthenticationFilter(makeProps());

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(req.getHeader("User-Agent")).thenReturn("Mozilla/5.0");
        when(req.getRequestURI()).thenReturn("/locallogin");
        when(req.getSession()).thenReturn(Mockito.mock(HttpSession.class));
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());

        f.doFilter(req, res, chain);

        verify(res, times(1)).sendRedirect("/login.jsp");
        verify(chain, times(0)).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }
}
