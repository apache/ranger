/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.security.web.filter;

import org.apache.hadoop.security.authentication.client.AuthenticatedURL;
import org.apache.hadoop.security.authentication.client.KerberosAuthenticator;
import org.apache.hadoop.security.authentication.server.AuthenticationHandler;
import org.apache.hadoop.security.authentication.server.AuthenticationToken;
import org.apache.hadoop.security.authentication.util.RandomSignerSecretProvider;
import org.apache.hadoop.security.authentication.util.Signer;
import org.apache.hadoop.security.authentication.util.SignerSecretProvider;
import org.apache.ranger.common.PropertiesUtil;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.servlet.FilterChain;
import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.io.EOFException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
* @generated by Cursor
* @description <Unit Test for TestRangerKrbFilter class>
*/
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerKrbFilter {
    @Test
    public void testCreateAuthCookieFormatsHeader() {
        HttpServletResponse res = mock(HttpServletResponse.class);

        long expires = 0L; // epoch
        RangerKrbFilter.createAuthCookie(res, "token123", "example.com", "/", expires, true);

        ArgumentCaptor<String> headerValue = ArgumentCaptor.forClass(String.class);
        verify(res).addHeader(eq("Set-Cookie"), headerValue.capture());

        String v = headerValue.getValue();
        assertTrue(v.startsWith(AuthenticatedURL.AUTH_COOKIE + "=\"token123\""));
        assertTrue(v.contains("; Path=/"));
        assertTrue(v.contains("; Domain=example.com"));
        assertTrue(v.contains("; Expires="));
        assertTrue(v.contains("; Secure"));
        assertTrue(v.endsWith("; HttpOnly"));
    }

    @Test
    public void testConstructSecretProvider_randomFallbackOnFileFailure() throws Exception {
        Properties config = new Properties();
        config.setProperty(RangerKrbFilter.SIGNER_SECRET_PROVIDER, "file");
        ServletContext ctx = mock(ServletContext.class);
        // disallowFallback=false, so file failure should fallback to random
        assertNotNull(RangerKrbFilter.constructSecretProvider(ctx, config, false));
    }

    @Test
    public void testConstructSecretProvider_randomProvider() throws Exception {
        Properties config = new Properties();
        config.setProperty(RangerKrbFilter.SIGNER_SECRET_PROVIDER, "random");
        ServletContext ctx = mock(ServletContext.class);
        assertNotNull(RangerKrbFilter.constructSecretProvider(ctx, config, true));
    }

    @Test
    public void testGettersAndRandomSecretFlags() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        // set fields via reflection
        setField(filter, "cookieDomain", "example.com");
        setField(filter, "cookiePath", "/");
        setField(filter, "validity", 30_000L);
        SignerSecretProvider provider = new RandomSignerSecretProvider();
        setField(filter, "secretProvider", provider);
        AuthenticationHandler handler = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", handler);
        Properties config = new Properties();
        config.setProperty("a", "b");
        setField(filter, "config", config);

        assertEquals("example.com", (String) invoke(filter, "getCookieDomain"));
        assertEquals("/", (String) invoke(filter, "getCookiePath"));
        assertEquals(30L, (Long) invoke(filter, "getValidity"));
        assertEquals(handler, (AuthenticationHandler) invoke(filter, "getAuthenticationHandler"));
        assertEquals(config, (Properties) invoke(filter, "getConfiguration"));
        assertTrue((Boolean) invoke(filter, "isRandomSecret"));
    }

    @Test
    public void testParseBrowserUserAgentsAndIsBrowser() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        filter.parseBrowserUserAgents("Mozilla,Chrome");
        assertTrue((Boolean) invoke(filter, "isBrowser", "Mozilla/5.0"));
        assertTrue(!(Boolean) invoke(filter, "isBrowser", "curl/8.0"));
    }

    @Test
    public void testDestroyInvokesAuthHandlerDestroy() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        AuthenticationHandler handler = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", handler);

        filter.destroy();

        verify(handler, times(1)).destroy();
    }

    @Test
    public void testGetRequestURLAppendsQuery() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        HttpServletRequest req = mock(HttpServletRequest.class);
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/a"));
        when(req.getQueryString()).thenReturn("q=1");
        Method m = RangerKrbFilter.class.getDeclaredMethod("getRequestURL", HttpServletRequest.class);
        m.setAccessible(true);
        assertEquals("http://localhost/a?q=1", (String) m.invoke(filter, req));
    }

    @Test
    public void testGetTokenReturnsNullWhenNoCookie() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        HttpServletRequest req = mock(HttpServletRequest.class);
        when(req.getCookies()).thenReturn(new Cookie[0]);
        Method m = RangerKrbFilter.class.getDeclaredMethod("getToken", HttpServletRequest.class);
        m.setAccessible(true);
        assertNull(m.invoke(filter, req));
    }

    @Test
    public void testProtectedDoFilterDelegates() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        FilterChain chain = mock(FilterChain.class);
        HttpServletRequest req = mock(HttpServletRequest.class);
        HttpServletResponse res = mock(HttpServletResponse.class);

        filter.doFilter(chain, req, res);

        verify(chain, times(1)).doFilter(eq(req), eq(res));
    }

    @Test
    public void testIsCustomSignerSecretProvider() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        // Custom provider (anonymous) should be detected as custom
        SignerSecretProvider custom = new SignerSecretProvider() {
            @Override
            public void init(Properties config, ServletContext servletContext, long tokenValidity) {
            }

            @Override
            public byte[] getCurrentSecret() {
                return new byte[0];
            }

            @Override
            public byte[][] getAllSecrets() {
                return new byte[0][];
            }
        };
        setField(filter, "secretProvider", custom);
        assertTrue((Boolean) invoke(filter, "isCustomSignerSecretProvider"));
    }

    @Test
    public void testDoFilterServletRequestDelegates() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        HttpServletRequest req = mock(HttpServletRequest.class);
        HttpServletResponse res = mock(HttpServletResponse.class);
        FilterChain chain = mock(FilterChain.class);

        // initialize minimal authHandler to avoid NPE and drive browser branch
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", ah);
        when(ah.managementOperation(isNull(), any(), any())).thenReturn(true);
        when(ah.authenticate(any(), any())).thenReturn(null);

        // set properties typically set in init
        setField(filter, "supportKerberosAuthForBrowserLogin", false);
        setField(filter, "isKerberosEnabled", false);

        when(req.getHeader(RangerCSRFPreventionFilter.HEADER_USER_AGENT)).thenReturn("Mozilla/5.0");
        when(res.isCommitted()).thenReturn(false);
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/a"));

        filter.doFilter(req, res, chain);

        verify(chain, times(1)).doFilter(any(HttpServletRequest.class), eq(res));
    }

    @Test
    public void testGetTokenWithInvalidSignedCookieThrowsOrNull() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        // signer needs to be initialized for getToken to attempt verify
        RandomSignerSecretProvider secretProvider = new RandomSignerSecretProvider() {
            {
                init(new Properties(), null, 1000);
            }
        };
        Signer signer = new Signer(secretProvider);
        setField(filter, "signer", signer);
        HttpServletRequest req = mock(HttpServletRequest.class);
        Cookie bad = new Cookie(AuthenticatedURL.AUTH_COOKIE, "invalid");
        when(req.getCookies()).thenReturn(new Cookie[] {bad});
        Method m = RangerKrbFilter.class.getDeclaredMethod("getToken", HttpServletRequest.class);
        m.setAccessible(true);
        try {
            Object r = m.invoke(filter, req);
            assertNull(r); // if do not throw, it should be null
        } catch (InvocationTargetException ite) {
            // acceptable: wrapped AuthenticationException due to invalid signer
            assertTrue(ite.getCause() != null);
        }
    }

    @Test
    public void testConstructSecretProvider_fileDisallowFallbackThrows() {
        Properties config = new Properties();
        config.setProperty(RangerKrbFilter.SIGNER_SECRET_PROVIDER, "file");
        // provide a non-existent secret file so FileSignerSecretProvider.init fails
        config.setProperty(RangerKrbFilter.SIGNATURE_SECRET_FILE, "/path/does/not/exist/secret");
        ServletContext ctx = mock(ServletContext.class);
        assertThrows(Exception.class, () -> RangerKrbFilter.constructSecretProvider(ctx, config, true));
    }

    @Test
    public void testGetTokenWithValidCookie() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        // Prepare signer and authHandler
        RandomSignerSecretProvider provider = new RandomSignerSecretProvider();
        provider.init(new Properties(), null, 60000);
        Signer signer = new Signer(provider);
        setField(filter, "signer", signer);
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        when(ah.getType()).thenReturn("t");
        setField(filter, "authHandler", ah);

        // Create a valid token and sign it as cookie
        AuthenticationToken token = new AuthenticationToken("alice", "p", "t");
        token.setExpires(System.currentTimeMillis() + 60000);
        String signed = signer.sign(token.toString());
        HttpServletRequest req = mock(HttpServletRequest.class);
        when(req.getCookies()).thenReturn(new Cookie[] {new Cookie(AuthenticatedURL.AUTH_COOKIE, signed)});

        Method m = RangerKrbFilter.class.getDeclaredMethod("getToken", HttpServletRequest.class);
        m.setAccessible(true);
        AuthenticationToken parsed = (AuthenticationToken) m.invoke(filter, req);
        assertNotNull(parsed);
        assertEquals("alice", parsed.getUserName());
    }

    @Test
    public void testGetTokenTypeMismatchThrows() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        RandomSignerSecretProvider provider = new RandomSignerSecretProvider();
        provider.init(new Properties(), null, 60000);
        Signer signer = new Signer(provider);
        setField(filter, "signer", signer);
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        when(ah.getType()).thenReturn("different");
        setField(filter, "authHandler", ah);

        AuthenticationToken token = new AuthenticationToken("alice", "p", "t");
        token.setExpires(System.currentTimeMillis() + 60000);
        String signed = signer.sign(token.toString());
        HttpServletRequest req = mock(HttpServletRequest.class);
        when(req.getCookies()).thenReturn(new Cookie[] {new Cookie(AuthenticatedURL.AUTH_COOKIE, signed)});

        Method m = RangerKrbFilter.class.getDeclaredMethod("getToken", HttpServletRequest.class);
        m.setAccessible(true);
        assertThrows(Exception.class, () -> m.invoke(filter, req));
    }

    @Test
    public void testGetTokenExpiredThrows() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        RandomSignerSecretProvider provider = new RandomSignerSecretProvider();
        provider.init(new Properties(), null, 60000);
        Signer signer = new Signer(provider);
        setField(filter, "signer", signer);
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        when(ah.getType()).thenReturn("t");
        setField(filter, "authHandler", ah);

        AuthenticationToken token = new AuthenticationToken("alice", "p", "t");
        token.setExpires(System.currentTimeMillis() - 1000);
        String signed = signer.sign(token.toString());
        HttpServletRequest req = mock(HttpServletRequest.class);
        when(req.getCookies()).thenReturn(new Cookie[] {new Cookie(AuthenticatedURL.AUTH_COOKIE, signed)});

        Method m = RangerKrbFilter.class.getDeclaredMethod("getToken", HttpServletRequest.class);
        m.setAccessible(true);
        assertThrows(Exception.class, () -> m.invoke(filter, req));
    }

    @Test
    public void testConstructSecretProvider_customClassName() throws Exception {
        Properties config = new Properties();
        config.setProperty(RangerKrbFilter.SIGNER_SECRET_PROVIDER, MyTestSignerSecretProvider.class.getName());
        ServletContext ctx = mock(ServletContext.class);
        SignerSecretProvider provider = RangerKrbFilter.constructSecretProvider(ctx, config, false);
        assertNotNull(provider);
    }

    @Test
    public void testConstructSecretProvider_zookeeperThrows() {
        Properties config = new Properties();
        config.setProperty(RangerKrbFilter.SIGNER_SECRET_PROVIDER, "zookeeper");
        ServletContext ctx = mock(ServletContext.class);
        assertThrows(Exception.class, () -> RangerKrbFilter.constructSecretProvider(ctx, config, false));
    }

    @Test
    public void testDoFilter_authenticatesAndSetsCookie() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        // signer
        RandomSignerSecretProvider provider = new RandomSignerSecretProvider();
        provider.init(new Properties(), null, 60000);
        setField(filter, "secretProvider", provider);
        setField(filter, "signer", new Signer(provider));
        setField(filter, "cookieDomain", "example.com");
        setField(filter, "cookiePath", "/");
        setField(filter, "validity", 60000L);

        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", ah);
        when(ah.managementOperation(isNull(), any(), any())).thenReturn(true);
        when(ah.authenticate(any(), any()))
                .thenReturn(new AuthenticationToken("alice", "p", "t"));

        HttpServletRequest req = mock(HttpServletRequest.class);
        HttpServletResponse res = mock(HttpServletResponse.class);
        FilterChain chain = mock(FilterChain.class);

        when(req.getScheme()).thenReturn("https");
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/a"));

        filter.doFilter(req, res, chain);

        ArgumentCaptor<String> headerValue = ArgumentCaptor.forClass(String.class);
        verify(res).addHeader(eq("Set-Cookie"), headerValue.capture());
        String cookie = headerValue.getValue();
        assertTrue(cookie.contains("Path=/"));
        assertTrue(cookie.contains("Domain=example.com"));
        assertTrue(cookie.contains("Secure"));
        verify(chain, times(1)).doFilter(any(HttpServletRequest.class), eq(res));
    }

    @Test
    public void testDoFilter_managementOperationFalseSkipsUnauthorizedHandling() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", ah);
        when(ah.managementOperation(isNull(), any(), any())).thenReturn(false);

        HttpServletRequest req = mock(HttpServletRequest.class);
        HttpServletResponse res = mock(HttpServletResponse.class);
        FilterChain chain = mock(FilterChain.class);

        filter.doFilter(req, res, chain);

        verify(chain, times(0)).doFilter(any(HttpServletRequest.class), eq(res));
    }

    @Test
    public void testDoFilter_setsNegotiateHeaderWhenKerberosAndBrowserEnabled() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", ah);
        when(ah.managementOperation(isNull(), any(), any())).thenReturn(true);
        when(ah.authenticate(any(), any())).thenReturn(null);

        setField(filter, "isKerberosEnabled", true);
        setField(filter, "supportKerberosAuthForBrowserLogin", true);

        HttpServletRequest req = mock(HttpServletRequest.class);
        HttpServletResponse res = mock(HttpServletResponse.class);
        FilterChain chain = mock(FilterChain.class);

        when(req.getHeader(RangerCSRFPreventionFilter.HEADER_USER_AGENT)).thenReturn("Mozilla/5.0");
        when(res.isCommitted()).thenReturn(false);
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/a"));

        filter.doFilter(req, res, chain);

        verify(res).setHeader(eq(KerberosAuthenticator.WWW_AUTHENTICATE), eq(KerberosAuthenticator.NEGOTIATE));
        verify(chain, times(1)).doFilter(req, res);
    }

    @Test
    public void testDoFilter_trustedProxyExpectHeaderSkips100Continue() throws Exception {
        RangerKrbFilter filter = new RangerKrbFilter();
        AuthenticationHandler ah = mock(AuthenticationHandler.class);
        setField(filter, "authHandler", ah);
        when(ah.managementOperation(isNull(), any(), any())).thenReturn(true);
        when(ah.authenticate(any(), any())).thenReturn(null);

        // Force unauthorizedResponse path and allowTrustedProxy branch
        setField(filter, "isKerberosEnabled", false);
        setField(filter, "supportKerberosAuthForBrowserLogin", false);

        HttpServletRequest req = mock(HttpServletRequest.class);
        HttpServletResponse res = mock(HttpServletResponse.class);
        FilterChain chain = mock(FilterChain.class);

        when(req.getHeader(RangerCSRFPreventionFilter.HEADER_USER_AGENT)).thenReturn("curl/8.0"); // not browser
        when(res.isCommitted()).thenReturn(false);
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/a"));
        when(req.getHeader("Expect")).thenReturn("100-continue");
        when(req.getInputStream()).thenThrow(new EOFException("eof"));
        // Simulate response having no Set-Cookie and no Authorization header so chain will be called
        when(res.getHeaderNames()).thenReturn(Collections.emptyList());
        when(req.getHeader("Authorization")).thenReturn(null);

        // Enable trusted proxy via system properties used by PropertiesUtil in RangerKrbFilter
        PropertiesUtil.getPropertiesMap().put("ranger.authentication.allow.trustedproxy", "true");

        filter.doFilter(req, res, chain);

        verify(chain, times(1)).doFilter(req, res);
    }

    // Test-only custom SignerSecretProvider class for constructSecretProvider default branch
    public static class MyTestSignerSecretProvider extends SignerSecretProvider {
        @Override
        public void init(Properties config, ServletContext servletContext, long tokenValidity) {
        }

        @Override
        public byte[] getCurrentSecret() {
            return new byte[] {1, 2, 3};
        }

        @Override
        public byte[][] getAllSecrets() {
            return new byte[][] {getCurrentSecret()};
        }
    }

    // helper methods
    private void setField(Object target, String field, Object value) throws Exception {
        Field f = target.getClass().getDeclaredField(field);
        f.setAccessible(true);
        f.set(target, value);
    }

    @SuppressWarnings("unchecked")
    private <T> T invoke(Object target, String method, Object... args) throws Exception {
        Class<?>[] types = new Class<?>[args.length];
        for (int i = 0; i < args.length; i++) {
            types[i] = args[i].getClass();
        }
        Method m = target.getClass().getDeclaredMethod(method, types);
        m.setAccessible(true);
        return (T) m.invoke(target, args);
    }
}
