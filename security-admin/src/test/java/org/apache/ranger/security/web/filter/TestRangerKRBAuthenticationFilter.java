/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.security.web.filter;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.security.authentication.client.AuthenticatedURL;
import org.apache.hadoop.security.authentication.server.AuthenticationHandler;
import org.apache.hadoop.security.authentication.server.AuthenticationToken;
import org.apache.hadoop.security.authentication.util.RandomSignerSecretProvider;
import org.apache.hadoop.security.authentication.util.Signer;
import org.apache.ranger.biz.UserMgr;
import org.apache.ranger.common.PropertiesUtil;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import javax.servlet.FilterChain;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description <Unit Test for TestRangerKRBAuthenticationFilter class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerKRBAuthenticationFilter {
    @AfterEach
    public void cleanup() {
        SecurityContextHolder.clearContext();
        Map<String, String> props = PropertiesUtil.getPropertiesMap();
        props.remove("ranger.authentication.allow.trustedproxy");
        props.remove("hadoop.security.authentication");
        props.remove("ranger.spnego.kerberos.principal");
        props.remove("ranger.spnego.kerberos.keytab");
    }

    @Test
    public void testDoFilter_handlesTimeoutWithTrustedProxy() throws Exception {
        PropertiesUtil.getPropertiesMap().put("ranger.authentication.allow.trustedproxy", "true");

        // Prepare security context with authenticated user
        Authentication auth = Mockito.mock(Authentication.class);
        when(auth.isAuthenticated()).thenReturn(true);
        SecurityContext context = Mockito.mock(SecurityContext.class);
        when(context.getAuthentication()).thenReturn(auth);
        SecurityContextHolder.setContext(context);

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);
        HttpSession session = Mockito.mock(HttpSession.class);

        when(req.getParameter("action")).thenReturn("timeout");
        when(req.getParameter("doAs")).thenReturn("bob");
        when(req.getRequestedSessionId()).thenReturn("sid");
        when(req.getRequestURI()).thenReturn("/any");
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/any"));
        when(req.getSession(false)).thenReturn(session);
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        doNothing().when(res).sendRedirect(Mockito.anyString());
        doNothing().when(session).invalidate();

        filter.doFilter(req, res, chain);

        verify(res, times(1)).sendRedirect(Mockito.anyString());
        verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }

    @Test
    public void testDoFilter_nonSpnego_delegatesToChain() throws Exception {
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "simple");

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        filter.doFilter(req, res, chain);

        verify(chain, times(1)).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }

    @Test
    public void testDoFilter_spnegoEnabled_timeoutInSpnegoBranch() throws Exception {
        // Enable spnego
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);
        HttpSession session = Mockito.mock(HttpSession.class);

        when(req.getParameter("action")).thenReturn("timeout");
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/any"));
        when(req.getRequestURI()).thenReturn("/any");
        when(req.getRequestedSessionId()).thenReturn("sid");
        when(req.getSession(false)).thenReturn(session);
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        doNothing().when(res).sendRedirect(Mockito.anyString());

        filter.doFilter(req, res, chain);

        verify(res, times(1)).sendRedirect(Mockito.anyString());
        verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }

    @Test
    public void testDoFilter_spnegoEnabled_callsParentAndDelegates() throws Exception {
        // Enable spnego
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());

        RangerKRBAuthenticationFilter filter = Mockito.spy(new RangerKRBAuthenticationFilter());
        // Prepare parent fields for successful auth in super.doFilter
        RandomSignerSecretProvider provider = new RandomSignerSecretProvider();
        provider.init(new Properties(), null, 60000);
        Signer signer = new Signer(provider);
        // reduce unnecessary stubbing: do not stub authHandler.authenticate here; let parent path run naturally
        Field sf = RangerKrbFilter.class.getDeclaredField("signer");
        sf.setAccessible(true);
        sf.set(filter, signer);
        Field spf = RangerKrbFilter.class.getDeclaredField("secretProvider");
        spf.setAccessible(true);
        spf.set(filter, provider);
        Field cf = RangerKrbFilter.class.getDeclaredField("cookieDomain");
        cf.setAccessible(true);
        cf.set(filter, "example.com");
        Field cpf = RangerKrbFilter.class.getDeclaredField("cookiePath");
        cpf.setAccessible(true);
        cpf.set(filter, "/");
        Field vf = RangerKrbFilter.class.getDeclaredField("validity");
        vf.setAccessible(true);
        vf.set(filter, 60000L);
        Field ahf = RangerKrbFilter.class.getDeclaredField("authHandler");
        ahf.setAccessible(true);
        AuthenticationHandler ah = Mockito.mock(AuthenticationHandler.class);
        Mockito.when(ah.managementOperation(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(true);
        Mockito.when(ah.getType()).thenReturn("t");
        ahf.set(filter, ah);

        // Let subclass protected doFilter simply delegate to chain
        Mockito.doAnswer(invocation -> {
            FilterChain ch = invocation.getArgument(0);
            HttpServletRequest rq = invocation.getArgument(1);
            HttpServletResponse rs = invocation.getArgument(2);
            ch.doFilter(rq, rs);
            return null;
        }).when(filter).doFilter(Mockito.any(FilterChain.class), Mockito.any(HttpServletRequest.class), Mockito.any(HttpServletResponse.class));

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(req.getScheme()).thenReturn("https");
        when(req.getRequestURL()).thenReturn(new StringBuffer("http://localhost/a"));
        // Supply a valid signed auth cookie so parent doFilter sees a token and calls protected doFilter
        AuthenticationToken tok = new AuthenticationToken("alice", "p", "t");
        tok.setExpires(System.currentTimeMillis() + 60000);
        String signed = signer.sign(tok.toString());
        when(req.getCookies()).thenReturn(new Cookie[] {new Cookie(AuthenticatedURL.AUTH_COOKIE, signed)});

        filter.doFilter((ServletRequest) req, (ServletResponse) res, chain);

        verify(chain, times(1)).doFilter(any(ServletRequest.class), any(ServletResponse.class));
    }

    @Test
    public void testProtectedDoFilter_extractsUserNameWhenCookiePresent() throws Exception {
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        RangerKRBAuthenticationFilter filter = Mockito.spy(new RangerKRBAuthenticationFilter());
        // Force isSpnegoEnable to false to enter else branch where protected doFilter
        // is called
        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        // Simulate Set-Cookie headers containing hadoop.auth with u=username
        when(res.containsHeader("Set-Cookie")).thenReturn(true);
        ArrayList<String> headers = new ArrayList<>();
        headers.add("hadoop.auth=u=alice&x=y; Path=/");
        when(res.getHeaders("Set-Cookie")).thenReturn(headers);

        // Run protected doFilter
        filter.doFilter(chain, req, res);

        verify(chain, times(1)).doFilter(req, res);
    }

    @Test
    public void testGetAuthorities_reflection() throws Exception {
        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        // Inject a mock userMgr to return roles
        UserMgr userMgr = Mockito.mock(UserMgr.class);
        when(userMgr.getRolesByLoginId("alice")).thenReturn(Arrays.asList("ROLE_USER", "ROLE_ADMIN"));
        Field f = RangerKRBAuthenticationFilter.class.getDeclaredField("userMgr");
        f.setAccessible(true);
        f.set(filter, userMgr);

        Method m = RangerKRBAuthenticationFilter.class.getDeclaredMethod("getAuthorities", String.class);
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        List<GrantedAuthority> auths = (List<GrantedAuthority>) m.invoke(filter, "alice");
        assertNotNull(auths);
        assertEquals(2, auths.size());
    }

    @Test
    public void testGetGrantedAuthority_reflection() throws Exception {
        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        // Inject a mock userMgr to avoid NPE
        UserMgr userMgr = Mockito.mock(UserMgr.class);
        when(userMgr.getRolesByLoginId("bob")).thenReturn(Arrays.asList("ROLE_USER"));
        Field f = RangerKRBAuthenticationFilter.class.getDeclaredField("userMgr");
        f.setAccessible(true);
        f.set(filter, userMgr);

        Authentication auth = new UsernamePasswordAuthenticationToken("bob", "pwd", Collections.emptyList());
        Method m = RangerKRBAuthenticationFilter.class.getDeclaredMethod("getGrantedAuthority", Authentication.class);
        m.setAccessible(true);
        Authentication res = (Authentication) m.invoke(filter, auth);
        assertNotNull(res);
        Collection<? extends GrantedAuthority> roles = res.getAuthorities();
        assertEquals(1, roles.size());
    }

    @Test
    public void testProtectedDoFilter_delegates() throws Exception {
        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        filter.doFilter(chain, req, res);

        verify(chain, times(1)).doFilter(req, res);
    }

    @Test
    public void testGetProxyuserConfiguration_includesProxyKeys() {
        PropertiesUtil.getPropertiesMap().put("ranger.proxyuser.testuser.groups", "*");
        PropertiesUtil.getPropertiesMap().put("ranger.proxyuser.testuser.hosts", "127.0.0.1");

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        Configuration conf = filter.getProxyuserConfiguration();

        assertEquals("*", conf.get("ranger.proxyuser.testuser.groups"));
        assertEquals("127.0.0.1", conf.get("ranger.proxyuser.testuser.hosts"));
    }

    @Test
    public void testProtectedDoFilter_forbiddenWhenDoAsPresent() throws Exception {
        // Force spnego enablement
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        // Inject userMgr to avoid NPE in getAuthorities
        UserMgr userMgr = Mockito.mock(UserMgr.class);
        Field uf = RangerKRBAuthenticationFilter.class.getDeclaredField("userMgr");
        uf.setAccessible(true);
        uf.set(filter, userMgr);
        Mockito.when(userMgr.getRolesByLoginId("alice")).thenReturn(Collections.singletonList("ROLE_USER"));

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        // Simulate Set-Cookie with username
        when(res.containsHeader("Set-Cookie")).thenReturn(true);
        ArrayList<String> headers = new ArrayList<>();
        headers.add("hadoop.auth=u=alice&x=y; Path=/");
        when(res.getHeaders("Set-Cookie")).thenReturn(headers);

        // Request contains doAs parameter which should be forbidden
        Map<String, String[]> params = new HashMap<>();
        params.put("doAs", new String[] {"bob" });
        when(req.getParameterMap()).thenReturn(params);
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        when(res.isCommitted()).thenReturn(false);

        filter.doFilter(chain, req, res);

        verify(chain, times(1)).doFilter(req, res);
    }

    @Test
    public void testProtectedDoFilter_forbiddenWhenUserNamePresent() throws Exception {
        // Force spnego enablement
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        // Inject userMgr to avoid NPE in getAuthorities
        UserMgr userMgr = Mockito.mock(UserMgr.class);
        Field uf = RangerKRBAuthenticationFilter.class.getDeclaredField("userMgr");
        uf.setAccessible(true);
        uf.set(filter, userMgr);
        Mockito.when(userMgr.getRolesByLoginId("alice")).thenReturn(Collections.singletonList("ROLE_USER"));

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        // Simulate Set-Cookie with username
        when(res.containsHeader("Set-Cookie")).thenReturn(true);
        ArrayList<String> headers = new ArrayList<>();
        headers.add("hadoop.auth=u=alice&x=y; Path=/");
        when(res.getHeaders("Set-Cookie")).thenReturn(headers);

        // Request contains user.name parameter which should be forbidden
        Map<String, String[]> params = new HashMap<>();
        params.put("user.name", new String[] {"carol" });
        when(req.getParameterMap()).thenReturn(params);
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());
        when(res.isCommitted()).thenReturn(false);

        filter.doFilter(chain, req, res);

        verify(chain, times(1)).doFilter(req, res);
    }

    @Test
    public void testProtectedDoFilter_usesSessionUserNameKeyadminPath() throws Exception {
        // Enable spnego
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        // Inject userMgr to avoid NPE and to provide roles
        UserMgr userMgr = Mockito.mock(UserMgr.class);
        Field uf = RangerKRBAuthenticationFilter.class.getDeclaredField("userMgr");
        uf.setAccessible(true);
        uf.set(filter, userMgr);
        Mockito.when(userMgr.getRolesByLoginId("keyadmin")).thenReturn(Collections.singletonList("ROLE_USER"));

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        when(res.containsHeader("Set-Cookie")).thenReturn(false);
        when(req.getParameter("suser")).thenReturn("keyadmin");
        when(req.getPathInfo()).thenReturn("/public/v2/api/service/list");
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());

        filter.doFilter(chain, req, res);

        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        assertNotNull(a);
        verify(chain, times(1)).doFilter(req, res);
    }

    @Test
    public void testProtectedDoFilter_trustedProxy_authorizationFails() throws Exception {
        // Enable spnego and trusted proxy
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());
        PropertiesUtil.getPropertiesMap().put("ranger.authentication.allow.trustedproxy", "true");

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        // Provide cookie so userName is extracted
        when(res.containsHeader("Set-Cookie")).thenReturn(true);
        ArrayList<String> headers = new ArrayList<>();
        headers.add("hadoop.auth=u=alice&x=y; Path=/");
        when(res.getHeaders("Set-Cookie")).thenReturn(headers);

        // doAs present -> trusted proxy branch
        when(req.getParameter("doAs")).thenReturn("bob");
        // user principal present
        when(req.getUserPrincipal()).thenReturn(new AuthenticationToken("alice", "p", "t"));
        when(req.getRemoteAddr()).thenReturn("192.0.2.10"); // not allowed; will cause ProxyUsers.authorize to fail
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());

        // Execute
        filter.doFilter(chain, req, res);

        // On authorization failure, the method returns early without delegating
        verify(chain, times(0)).doFilter(req, res);
    }

    @Test
    public void testProtectedDoFilter_trustedProxy_successSetsAuthAndDelegates() throws Exception {
        // Set proxy user host allowance BEFORE constructing filter (so init refreshes configuration)
        PropertiesUtil.getPropertiesMap().put("ranger.proxyuser.alice.hosts", "127.0.0.1");
        File kt = File.createTempFile("krb", ".keytab");
        kt.deleteOnExit();
        PropertiesUtil.getPropertiesMap().put("hadoop.security.authentication", "kerberos");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.principal", "HTTP/localhost@EXAMPLE.COM");
        PropertiesUtil.getPropertiesMap().put("ranger.spnego.kerberos.keytab", kt.getAbsolutePath());
        PropertiesUtil.getPropertiesMap().put("ranger.authentication.allow.trustedproxy", "true");

        RangerKRBAuthenticationFilter filter = new RangerKRBAuthenticationFilter();
        // Inject userMgr to avoid NPE inside getAuthorities
        UserMgr userMgr = Mockito.mock(UserMgr.class);
        Field uf = RangerKRBAuthenticationFilter.class.getDeclaredField("userMgr");
        uf.setAccessible(true);
        uf.set(filter, userMgr);
        Mockito.when(userMgr.getRolesByLoginId("bob")).thenReturn(Collections.singletonList("ROLE_USER"));

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        // Provide cookie so userName is extracted
        when(res.containsHeader("Set-Cookie")).thenReturn(true);
        ArrayList<String> headers = new ArrayList<>();
        headers.add("hadoop.auth=u=alice&x=y; Path=/");
        when(res.getHeaders("Set-Cookie")).thenReturn(headers);

        when(req.getParameter("doAs")).thenReturn("bob");
        when(req.getUserPrincipal()).thenReturn(new AuthenticationToken("alice", "p", "t"));
        when(req.getRemoteAddr()).thenReturn("127.0.0.1");
        when(req.getHeaderNames()).thenReturn(Collections.emptyEnumeration());

        filter.doFilter(chain, req, res);

        assertNotNull(SecurityContextHolder.getContext().getAuthentication());
        verify(chain, times(1)).doFilter(req, res);
    }
}
