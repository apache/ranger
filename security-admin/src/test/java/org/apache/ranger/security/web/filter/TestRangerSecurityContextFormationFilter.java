/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.security.web.filter;

import org.apache.ranger.biz.SessionMgr;
import org.apache.ranger.biz.XUserMgr;
import org.apache.ranger.common.GUIDUtil;
import org.apache.ranger.common.HTTPUtil;
import org.apache.ranger.common.RangerCommonEnums;
import org.apache.ranger.common.UserSessionBase;
import org.apache.ranger.entity.XXAuthSession;
import org.apache.ranger.security.context.RangerContextHolder;
import org.apache.ranger.security.context.RangerSecurityContext;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description <Unit Test for TestRangerSecurityContextFormationFilter class>
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerSecurityContextFormationFilter {
    @AfterEach
    public void tearDown() {
        SecurityContextHolder.clearContext();
        RangerContextHolder.resetSecurityContext();
        RangerContextHolder.resetOpContext();
    }

    @Test
    public void testDoFilter_setsSecurityHeadersAndCleansContext() throws IOException, ServletException {
        RangerSecurityContextFormationFilter filter = new RangerSecurityContextFormationFilter();

        // mock authenticated user to drive context creation path
        GrantedAuthority auth = new SimpleGrantedAuthority("ROLE_USER");
        Authentication authentication = new AnonymousAuthenticationToken("key", "principal", Collections.singletonList(auth));
        SecurityContextHolder.getContext().setAuthentication(authentication);

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        FilterChain chain = Mockito.mock(FilterChain.class);

        filter.doFilter(req, res, chain);

        // Verify headers
        verify(res).setHeader("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
        verify(res).setHeader("X-Frame-Options", "DENY");
        verify(res).setHeader("X-XSS-Protection", "1; mode=block");
        verify(res).setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
        verify(res).setHeader("Content-Security-Policy",
                "default-src 'none'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline';font-src 'self'");
        verify(res).setHeader("X-Permitted-Cross-Domain-Policies", "none");

        verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));

        // filter should clean up thread locals
        assertNull(RangerContextHolder.getSecurityContext());
        assertNull(RangerContextHolder.getOpContext());
    }

    @Test
    public void testDoFilter_setsCreatePrincipalsIfAbsentFlag() throws Exception {
        RangerSecurityContextFormationFilter filter = new RangerSecurityContextFormationFilter();

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);

        // Set anonymous auth to skip dependency calls but still execute
        // setupAdminOpContext
        GrantedAuthority ga = new SimpleGrantedAuthority("ROLE_ANON");
        Authentication anon = new AnonymousAuthenticationToken("k", "p", Collections.singletonList(ga));
        SecurityContextHolder.getContext().setAuthentication(anon);

        when(req.getParameter("createPrincipalsIfAbsent")).thenReturn("true");

        FilterChain chain = new FilterChain() {
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse) {
                Boolean flag = RangerContextHolder.getOpContext() != null
                        ? RangerContextHolder.getOpContext().getCreatePrincipalsIfAbsent()
                        : null;
                assertEquals(Boolean.TRUE, flag);
            }
        };

        filter.doFilter(req, res, chain);

        verify(res, times(1)).setHeader("X-Frame-Options", "DENY");
    }

    @Test
    public void testGetAuthType_reflectionVariants() throws Exception {
        RangerSecurityContextFormationFilter filter = new RangerSecurityContextFormationFilter();
        Method m = RangerSecurityContextFormationFilter.class.getDeclaredMethod("getAuthType", HttpServletRequest.class);
        m.setAccessible(true);

        // SSO enabled
        HttpServletRequest reqSso = Mockito.mock(HttpServletRequest.class);
        when(reqSso.getAttribute("ssoEnabled")).thenReturn(true);
        int sso = (int) m.invoke(filter, reqSso);
        assertEquals(XXAuthSession.AUTH_TYPE_SSO, sso);

        // Kerberos
        HttpServletRequest reqKrb = Mockito.mock(HttpServletRequest.class);
        when(reqKrb.getAttribute("ssoEnabled")).thenReturn(false);
        when(reqKrb.getAttribute("spnegoEnabled")).thenReturn(true);
        when(reqKrb.getAttribute("trustedProxyEnabled")).thenReturn(false);
        int krb = (int) m.invoke(filter, reqKrb);
        assertEquals(XXAuthSession.AUTH_TYPE_KERBEROS, krb);

        // Trusted proxy
        HttpServletRequest reqTp = Mockito.mock(HttpServletRequest.class);
        when(reqTp.getAttribute("ssoEnabled")).thenReturn(false);
        when(reqTp.getAttribute("spnegoEnabled")).thenReturn(true);
        when(reqTp.getAttribute("trustedProxyEnabled")).thenReturn(true);
        int tp = (int) m.invoke(filter, reqTp);
        assertEquals(XXAuthSession.AUTH_TYPE_TRUSTED_PROXY, tp);

        // Password default
        HttpServletRequest reqPwd = Mockito.mock(HttpServletRequest.class);
        when(reqPwd.getAttribute("ssoEnabled")).thenReturn(false);
        when(reqPwd.getAttribute("spnegoEnabled")).thenReturn(false);
        int pwd = (int) m.invoke(filter, reqPwd);
        assertEquals(XXAuthSession.AUTH_TYPE_PASSWORD, pwd);
    }

    @Test
    public void testDoFilter_authenticated_createsSecurityContextAndUserSession() throws Exception {
        RangerSecurityContextFormationFilter filter = new RangerSecurityContextFormationFilter();

        // Inject dependencies
        SessionMgr sessionMgr = Mockito.mock(SessionMgr.class);
        HTTPUtil httpUtil = Mockito.mock(HTTPUtil.class);
        GUIDUtil guidUtil = Mockito.mock(GUIDUtil.class);
        XUserMgr xUserMgr = Mockito.mock(XUserMgr.class);
        filter.sessionMgr = sessionMgr;
        filter.httpUtil = httpUtil;
        filter.guidUtil = guidUtil;
        filter.xUserMgr = xUserMgr;

        // Authenticated user (non-anonymous)
        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken("user", "pwd",
                        Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));
        SecurityContextHolder.getContext().setAuthentication(authentication);

        HttpServletRequest req = Mockito.mock(HttpServletRequest.class);
        HttpServletResponse res = Mockito.mock(HttpServletResponse.class);
        HttpSession session = Mockito.mock(HttpSession.class);

        Mockito.when(req.getSession(false)).thenReturn(session);
        Mockito.when(session.getAttribute(RangerSecurityContextFormationFilter.AKA_SC_SESSION_KEY)).thenReturn(null);
        Mockito.when(req.getHeader(RangerSecurityContextFormationFilter.USER_AGENT)).thenReturn("Mozilla/5.0");
        Mockito.when(req.getRequestURI()).thenReturn("/secure");
        Mockito.when(httpUtil.getDeviceType(req)).thenReturn(RangerCommonEnums.DEVICE_BROWSER);
        Mockito.when(guidUtil.genGUID()).thenReturn("guid-1");

        UserSessionBase userSession = Mockito.mock(UserSessionBase.class);
        Mockito.when(userSession.getClientTimeOffsetInMinute()).thenReturn(0);
        Mockito.when(sessionMgr.processSuccessLogin(Mockito.anyInt(), Mockito.anyString(), Mockito.any(HttpServletRequest.class)))
                .thenReturn(userSession);

        FilterChain chain = new FilterChain() {
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse) {
                RangerSecurityContext ctx = RangerContextHolder.getSecurityContext();
                assertNotNull(ctx);
                assertNotNull(ctx.getRequestContext());
                assertSame(userSession, ctx.getUserSession());
            }
        };

        filter.doFilter(req, res, chain);

        Mockito.verify(session, Mockito.times(1)).setAttribute(Mockito.eq(RangerSecurityContextFormationFilter.AKA_SC_SESSION_KEY), Mockito.any());
        Mockito.verify(res).setHeader("X-Frame-Options", "DENY");
        Mockito.verify(sessionMgr, Mockito.times(1)).processSuccessLogin(Mockito.anyInt(), Mockito.anyString(), Mockito.any(HttpServletRequest.class));
        Mockito.verify(userSession, Mockito.times(1)).setClientTimeOffsetInMinute(Mockito.anyInt());

        // cleaned up after the call
        assertNull(RangerContextHolder.getSecurityContext());
        assertNull(RangerContextHolder.getOpContext());
    }
}
