/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.authorization.hadoop;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.permission.FsAction;
import org.apache.hadoop.hdfs.server.namenode.INode;
import org.apache.hadoop.hdfs.server.namenode.INodeAttributeProvider.AccessControlEnforcer;
import org.apache.hadoop.hdfs.server.namenode.INodeAttributes;
import org.apache.hadoop.hdfs.server.namenode.INodeDirectory;
import org.apache.hadoop.hdfs.server.namenode.INodeDirectoryAttributes;
import org.apache.hadoop.hdfs.util.ReadOnlyList;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.ranger.plugin.policyengine.RangerAccessRequest;
import org.apache.ranger.plugin.policyengine.RangerAccessResult;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RangerAccessControlEnforcer
 */

@TestMethodOrder(MethodOrderer.MethodName.class)
@ExtendWith(MockitoExtension.class)
public class TestRangerAccessControlEnforcer {
    @Test
    public void test01_subAccess_callsDefaultEnforcer_forTopAndChildren_trailingSlash() throws Exception {
        RangerHdfsPlugin      plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);

        Mockito.when(plugin.isHadoopAuthEnabled()).thenReturn(true);
        Mockito.when(plugin.isUseLegacySubAccessAuthorization()).thenReturn(false);
        Mockito.when(plugin.isOptimizeSubAccessAuthEnabled()).thenReturn(false);
        Mockito.when(plugin.getHadoopModuleName()).thenReturn("hdfs");
        Mockito.when(plugin.getExcludedUsers()).thenReturn(Collections.emptySet());
        // Return NOT_DETERMINED results to force default authorizer path
        Mockito.when(plugin.isAccessAllowed(Mockito.any(RangerAccessRequest.class), Mockito.any())).thenAnswer(inv -> {
            RangerAccessRequest req = inv.getArgument(0);
            return new RangerAccessResult(0, "hdfs", null, req);
        });

        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        // Build inode hierarchy: root directory with two child directories "a" and "b"
        INodeDirectory rootDir  = Mockito.mock(INodeDirectory.class);
        INode          rootNode = Mockito.mock(INode.class);
        Mockito.when(rootNode.isDirectory()).thenReturn(true);
        Mockito.when(rootNode.asDirectory()).thenReturn(rootDir);
        Mockito.when(rootDir.getFullPathName()).thenReturn("/root");
        Mockito.when(rootDir.getPathComponents()).thenReturn(new byte[][] {"".getBytes()});
        INodeDirectoryAttributes rootAttrs = Mockito.mock(INodeDirectoryAttributes.class);
        Mockito.when(rootAttrs.getLocalNameBytes()).thenReturn("root".getBytes());
        Mockito.when(rootDir.getSnapshotINode(Mockito.anyInt())).thenReturn(rootAttrs);

        INode          childA = Mockito.mock(INode.class);
        INode          childB = Mockito.mock(INode.class);
        INodeDirectory dirA   = Mockito.mock(INodeDirectory.class);
        INodeDirectory dirB   = Mockito.mock(INodeDirectory.class);
        Mockito.when(childA.isDirectory()).thenReturn(true);
        Mockito.when(childB.isDirectory()).thenReturn(true);
        Mockito.when(childA.asDirectory()).thenReturn(dirA);
        Mockito.when(childB.asDirectory()).thenReturn(dirB);
        Mockito.when(childA.getLocalName()).thenReturn("a");
        Mockito.when(childB.getLocalName()).thenReturn("b");
        INodeDirectoryAttributes attrA = Mockito.mock(INodeDirectoryAttributes.class);
        INodeDirectoryAttributes attrB = Mockito.mock(INodeDirectoryAttributes.class);
        Mockito.when(attrA.getLocalNameBytes()).thenReturn("a".getBytes());
        Mockito.when(attrB.getLocalNameBytes()).thenReturn("b".getBytes());
        Mockito.when(dirA.getSnapshotINode(Mockito.anyInt())).thenReturn(attrA);
        Mockito.when(dirB.getSnapshotINode(Mockito.anyInt())).thenReturn(attrB);
        Mockito.when(dirA.getPathComponents()).thenReturn(new byte[][] {"".getBytes(), "root".getBytes(), "a".getBytes()});
        Mockito.when(dirB.getPathComponents()).thenReturn(new byte[][] {"".getBytes(), "root".getBytes(), "b".getBytes()});
        ReadOnlyList<INode> emptyChildren = Mockito.mock(ReadOnlyList.class);
        Mockito.when(emptyChildren.isEmpty()).thenReturn(true);
        Mockito.when(emptyChildren.size()).thenReturn(0);
        Mockito.when(emptyChildren.iterator()).thenReturn(Collections.emptyIterator());
        Mockito.when(dirA.getChildrenList(Mockito.anyInt())).thenReturn(emptyChildren);
        Mockito.when(dirB.getChildrenList(Mockito.anyInt())).thenReturn(emptyChildren);

        List<INode>         list     = Arrays.asList(childA, childB);
        ReadOnlyList<INode> children = Mockito.mock(ReadOnlyList.class);
        Mockito.when(children.isEmpty()).thenReturn(list.isEmpty());
        Mockito.when(children.size()).thenReturn(list.size());
        Mockito.when(children.get(Mockito.eq(0))).thenReturn(list.get(0));
        Mockito.when(children.get(Mockito.eq(1))).thenReturn(list.get(1));
        Mockito.when(children.iterator()).thenReturn(list.iterator());
        Mockito.when(rootDir.getChildrenList(Mockito.anyInt())).thenReturn(children);

        // prepare arrays
        INodeAttributes[] inodeAttrs    = new INodeAttributes[] {rootAttrs};
        INode[]           inodes        = new INode[] {rootNode};
        byte[][]          pathByNameArr = new byte[][] {"root".getBytes()};

        UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class);
        Mockito.when(ugi.getShortUserName()).thenReturn("user");
        Mockito.when(ugi.getGroupNames()).thenReturn(new String[] {"grp"});

        // Call with resourcePath ending with separator
        enforcer.checkPermission("owner", "super", ugi, inodeAttrs, inodes, pathByNameArr, 0, "/root/", 0, false,
                null, null, null, FsAction.READ_EXECUTE, false);

        // Verify defaultEnforcer called for top dir and each child
        ArgumentCaptor<INodeAttributes[]> attrsCaptor  = ArgumentCaptor.forClass(INodeAttributes[].class);
        ArgumentCaptor<INode[]>           inodesCaptor = ArgumentCaptor.forClass(INode[].class);
        Mockito.verify(defaultEnforcer, Mockito.atLeast(2)).checkPermission(Mockito.anyString(), Mockito.anyString(), Mockito.any(),
                attrsCaptor.capture(), inodesCaptor.capture(), Mockito.any(), Mockito.anyInt(), Mockito.anyString(), Mockito.anyInt(), Mockito.anyBoolean(),
                Mockito.isNull(), Mockito.isNull(), Mockito.isNull(), Mockito.isNull(), Mockito.anyBoolean());

        // Ensure at least one invocation carried arrays augmented by 1 (child path case)
        boolean sawAugmented = attrsCaptor.getAllValues().stream().anyMatch(a -> a.length == inodeAttrs.length + 1);
        Assertions.assertTrue(sawAugmented);
        boolean sawInodeAugmented = inodesCaptor.getAllValues().stream().anyMatch(a -> a.length == inodes.length + 1);
        Assertions.assertTrue(sawInodeAugmented);
    }

    @Test
    public void test02_subAccess_callsDefaultEnforcer_children_withoutTrailingSlash() throws Exception {
        RangerHdfsPlugin      plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);

        Mockito.when(plugin.isHadoopAuthEnabled()).thenReturn(true);
        Mockito.when(plugin.isUseLegacySubAccessAuthorization()).thenReturn(false);
        Mockito.when(plugin.isOptimizeSubAccessAuthEnabled()).thenReturn(false);
        Mockito.when(plugin.getHadoopModuleName()).thenReturn("hdfs");
        Mockito.when(plugin.getExcludedUsers()).thenReturn(Collections.emptySet());
        Mockito.when(plugin.isAccessAllowed(Mockito.any(RangerAccessRequest.class), Mockito.any())).thenAnswer(inv -> {
            RangerAccessRequest req = inv.getArgument(0);
            return new RangerAccessResult(0, "hdfs", null, req);
        });

        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        INodeDirectory rootDir  = Mockito.mock(INodeDirectory.class);
        INode          rootNode = Mockito.mock(INode.class);
        Mockito.when(rootNode.isDirectory()).thenReturn(true);
        Mockito.when(rootNode.asDirectory()).thenReturn(rootDir);
        Mockito.when(rootDir.getFullPathName()).thenReturn("/root");
        Mockito.when(rootDir.getPathComponents()).thenReturn(new byte[][] {"".getBytes()});
        INodeDirectoryAttributes rootAttrs = Mockito.mock(INodeDirectoryAttributes.class);
        Mockito.when(rootAttrs.getLocalNameBytes()).thenReturn("root".getBytes());
        Mockito.when(rootDir.getSnapshotINode(Mockito.anyInt())).thenReturn(rootAttrs);

        INode          childC = Mockito.mock(INode.class);
        INodeDirectory dirC   = Mockito.mock(INodeDirectory.class);
        Mockito.when(childC.isDirectory()).thenReturn(true);
        Mockito.when(childC.asDirectory()).thenReturn(dirC);
        Mockito.when(childC.getLocalName()).thenReturn("c");
        INodeDirectoryAttributes attrC = Mockito.mock(INodeDirectoryAttributes.class);
        Mockito.when(attrC.getLocalNameBytes()).thenReturn("c".getBytes());
        Mockito.when(dirC.getSnapshotINode(Mockito.anyInt())).thenReturn(attrC);
        Mockito.when(dirC.getPathComponents()).thenReturn(new byte[][] {"".getBytes(), "root".getBytes(), "c".getBytes()});

        List<INode>         list     = Collections.singletonList(childC);
        ReadOnlyList<INode> children = Mockito.mock(ReadOnlyList.class);
        Mockito.when(children.isEmpty()).thenReturn(list.isEmpty());
        Mockito.when(children.size()).thenReturn(list.size());
        Mockito.when(children.get(Mockito.eq(0))).thenReturn(list.get(0));
        Mockito.when(children.iterator()).thenReturn(list.iterator());
        Mockito.when(rootDir.getChildrenList(Mockito.anyInt())).thenReturn(children);
        ReadOnlyList<INode> emptyChildren2 = Mockito.mock(ReadOnlyList.class);
        Mockito.when(emptyChildren2.isEmpty()).thenReturn(true);
        Mockito.when(emptyChildren2.size()).thenReturn(0);
        Mockito.when(emptyChildren2.iterator()).thenReturn(Collections.emptyIterator());
        Mockito.when(dirC.getChildrenList(Mockito.anyInt())).thenReturn(emptyChildren2);

        INodeAttributes[] inodeAttrs    = new INodeAttributes[] {rootAttrs};
        INode[]           inodes        = new INode[] {rootNode};
        byte[][]          pathByNameArr = new byte[][] {"root".getBytes()};

        UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class);
        Mockito.when(ugi.getShortUserName()).thenReturn("user");
        Mockito.when(ugi.getGroupNames()).thenReturn(new String[] {"grp"});

        // resourcePath without trailing separator forces adding Path.SEPARATOR_CHAR when pushing children
        enforcer.checkPermission("owner", "super", ugi, inodeAttrs, inodes, pathByNameArr, 0, "/root", 0, false,
                null, null, null, FsAction.READ_EXECUTE, false);

        Mockito.verify(defaultEnforcer, Mockito.atLeastOnce()).checkPermission(Mockito.anyString(), Mockito.anyString(), Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any(), Mockito.anyInt(), Mockito.anyString(), Mockito.anyInt(), Mockito.anyBoolean(), Mockito.isNull(), Mockito.isNull(), Mockito.isNull(), Mockito.isNull(), Mockito.anyBoolean());
    }

    @Test
    public void test03_traverseOnly_setsExecute_and_usesDefaultEnforcer() throws Exception {
        RangerHdfsPlugin      plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);

        Mockito.when(plugin.isHadoopAuthEnabled()).thenReturn(true);
        Mockito.when(plugin.getHadoopModuleName()).thenReturn("hdfs");
        Mockito.when(plugin.getExcludedUsers()).thenReturn(new HashSet<String>());
        // No policy evaluation in this path

        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        INodeDirectory rootDir  = Mockito.mock(INodeDirectory.class);
        INode          rootNode = Mockito.mock(INode.class);
        Mockito.when(rootNode.isDirectory()).thenReturn(true);
        Mockito.when(rootNode.asDirectory()).thenReturn(rootDir);
        Mockito.when(rootDir.getFullPathName()).thenReturn("/root");
        Mockito.when(rootDir.getPathComponents()).thenReturn(new byte[][] {"".getBytes()});
        INodeDirectoryAttributes rootAttrs = Mockito.mock(INodeDirectoryAttributes.class);
        Mockito.when(rootAttrs.getLocalNameBytes()).thenReturn("root".getBytes());
        Mockito.when(rootDir.getSnapshotINode(Mockito.anyInt())).thenReturn(rootAttrs);

        INodeAttributes[] inodeAttrs    = new INodeAttributes[] {rootAttrs};
        INode[]           inodes        = new INode[] {rootNode};
        byte[][]          pathByNameArr = new byte[][] {"root".getBytes()};

        UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class);
        Mockito.when(ugi.getShortUserName()).thenReturn("user");
        Mockito.when(ugi.getGroupNames()).thenReturn(new String[] {"grp"});

        // All access parameters null -> traverseOnlyCheck true
        enforcer.checkPermission("owner", "super", ugi, inodeAttrs, inodes, pathByNameArr, 0, Path.SEPARATOR, 0, false,
                null, null, null, null, false);

        Mockito.verify(plugin, Mockito.atLeastOnce()).isAccessAllowed(Mockito.any(RangerAccessRequest.class), Mockito.isNull());
    }

    @Test
    public void test04_isAccessAllowedForHierarchy_notDetermined_and_pathHasWildcard() throws Exception {
        RangerHdfsPlugin      plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);

        Mockito.when(plugin.getRandomizedWildcardPathName()).thenReturn("*RAND*");

        // Return result without isAccessDetermined => NOT_DETERMINED
        Mockito.when(plugin.isAccessAllowed(Mockito.any(RangerAccessRequest.class), Mockito.isNull())).thenAnswer(inv -> {
            RangerAccessRequest req = inv.getArgument(0);
            return new RangerAccessResult(0, "hdfs", null, req);
        });

        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        INode           inode      = Mockito.mock(INode.class);
        INodeAttributes inodeAttrs = Mockito.mock(INodeAttributes.class);
        Mockito.when(inodeAttrs.getUserName()).thenReturn("owner");

        UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class);
        Mockito.when(ugi.getShortUserName()).thenReturn("user");
        Mockito.when(ugi.getGroupNames()).thenReturn(new String[] {"grp"});

        Class<?>[] inner         = RangerAccessControlEnforcer.class.getDeclaredClasses();
        Class<?>   authzCtxClass = null;
        for (Class<?> c : inner) {
            if (c.getSimpleName().equals("AuthzContext")) {
                authzCtxClass = c;
                break;
            }
        }
        Constructor<?> ctor = authzCtxClass.getDeclaredConstructor(UserGroupInformation.class, String.class, boolean.class);
        ctor.setAccessible(true);
        Object authzCtx = ctor.newInstance(ugi, "op", false);

        Method m = RangerAccessControlEnforcer.class.getDeclaredMethod("isAccessAllowedForHierarchy", INode.class, INodeAttributes.class, String.class, FsAction.class, authzCtxClass);
        m.setAccessible(true);

        ArgumentCaptor<RangerAccessRequest> reqCaptor = ArgumentCaptor.forClass(RangerAccessRequest.class);

        Object ret = m.invoke(enforcer, inode, inodeAttrs, "/root/child", FsAction.READ_EXECUTE, authzCtx);

        Mockito.verify(plugin, Mockito.atLeastOnce()).isAccessAllowed(reqCaptor.capture(), Mockito.isNull());
        RangerAccessRequest sent = reqCaptor.getValue();
        Assertions.assertTrue(sent.getResource().getAsString().startsWith("/root/child/"));
        Assertions.assertTrue(sent.getResource().getAsString().contains("*RAND*"));
        Assertions.assertEquals("NOT_DETERMINED", ret.toString());
    }

    @Test
    public void test05_isAccessAllowedForHierarchy_allow_and_deny() throws Exception {
        RangerHdfsPlugin      plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);

        Mockito.when(plugin.getRandomizedWildcardPathName()).thenReturn("*W*");

        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        INode           inode      = Mockito.mock(INode.class);
        INodeAttributes inodeAttrs = Mockito.mock(INodeAttributes.class);

        UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class);
        Mockito.when(ugi.getShortUserName()).thenReturn("user");
        Mockito.when(ugi.getGroupNames()).thenReturn(new String[] {"grp"});

        Class<?> authzCtxClass = null;
        for (Class<?> c : RangerAccessControlEnforcer.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals("AuthzContext")) {
                authzCtxClass = c;
                break;
            }
        }
        Constructor<?> ctor = authzCtxClass.getDeclaredConstructor(UserGroupInformation.class, String.class, boolean.class);
        ctor.setAccessible(true);
        Object authzCtx = ctor.newInstance(ugi, "op", false);

        Method m = RangerAccessControlEnforcer.class.getDeclaredMethod("isAccessAllowedForHierarchy", INode.class, INodeAttributes.class, String.class, FsAction.class, authzCtxClass);
        m.setAccessible(true);

        // DENY
        Mockito.when(plugin.isAccessAllowed(Mockito.any(RangerAccessRequest.class), Mockito.isNull())).thenAnswer(inv -> {
            RangerAccessRequest req = inv.getArgument(0);
            RangerAccessResult  rs  = new RangerAccessResult(0, "hdfs", null, req);
            rs.setIsAllowed(false); // also sets determined
            return rs;
        });
        Object retDeny = m.invoke(enforcer, inode, inodeAttrs, "/p", FsAction.EXECUTE, authzCtx);
        Assertions.assertEquals("DENY", retDeny.toString());

        // ALLOW
        Mockito.when(plugin.isAccessAllowed(Mockito.any(RangerAccessRequest.class), Mockito.isNull())).thenAnswer(inv -> {
            RangerAccessRequest req = inv.getArgument(0);
            RangerAccessResult  rs  = new RangerAccessResult(0, "hdfs", null, req);
            rs.setIsAccessDetermined(true);
            rs.setIsAllowed(true);
            return rs;
        });
        Object retAllow = m.invoke(enforcer, inode, inodeAttrs, "/p", FsAction.EXECUTE, authzCtx);
        Assertions.assertEquals("ALLOW", retAllow.toString());
    }

    @Test
    public void test06_operationOptimizer_delete_setsParentAccess_and_caches() throws Exception {
        RangerHdfsPlugin            plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer       defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);
        RangerAccessControlEnforcer enforcer        = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        Class<?> ctxClz = null;
        for (Class<?> c : RangerAccessControlEnforcer.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals("OptimizedAuthzContext")) {
                ctxClz = c;
            }
        }

        INode inode = Mockito.mock(INode.class);
        Mockito.when(inode.isDirectory()).thenReturn(true);
        INodeAttributes attr = Mockito.mock(INodeAttributes.class);
        Mockito.when(attr.getLocalNameBytes()).thenReturn("root".getBytes());
        byte[][] components = new byte[][] {"root".getBytes()};
        // consume stubs to satisfy strictness
        inode.isDirectory();
        attr.getLocalNameBytes();

        OperationOptimizer                                optimizer = new OperationOptimizer(enforcer, "delete", "/root", null, FsAction.READ, null, null, components, new INodeAttributes[] {attr}, 0, null, inode, inode);
        RangerAccessControlEnforcer.OptimizedAuthzContext ctx       = optimizer.optimize();
        Assertions.assertNotNull(ctx);

        // parentAccess should be WRITE_EXECUTE
        Field parentAccessF = ctxClz.getDeclaredField("parentAccess");
        parentAccessF.setAccessible(true);
        Object parentAccessVal = parentAccessF.get(ctx);
        Assertions.assertEquals(FsAction.WRITE_EXECUTE, parentAccessVal);
    }

    @Test
    public void test07_operationOptimizer_create_bypass_whenNodeNull() throws Exception {
        RangerHdfsPlugin            plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer       defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);
        RangerAccessControlEnforcer enforcer        = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        INodeAttributes attr = Mockito.mock(INodeAttributes.class);
        Mockito.when(attr.getLocalNameBytes()).thenReturn("root".getBytes());
        byte[][] components = new byte[][] {"root".getBytes()};
        // consume stub
        attr.getLocalNameBytes();
        OperationOptimizer                                optimizer = new OperationOptimizer(enforcer, "create", "/root", null, null, null, null, components, new INodeAttributes[] {attr}, 0, null, null, null);
        RangerAccessControlEnforcer.OptimizedAuthzContext ctx       = optimizer.optimize();

        Assertions.assertSame(OperationOptimizer.OPT_BYPASS_AUTHZ, ctx);
    }

    @Test
    public void test08_operationOptimizer_listStatus_setsAccess_and_trimsPath() throws Exception {
        RangerHdfsPlugin            plugin          = Mockito.mock(RangerHdfsPlugin.class);
        AccessControlEnforcer       defaultEnforcer = Mockito.mock(AccessControlEnforcer.class);
        RangerAccessControlEnforcer enforcer        = new RangerAccessControlEnforcer(plugin, defaultEnforcer);

        Class<?> ctxClz = null;
        for (Class<?> c : RangerAccessControlEnforcer.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals("OptimizedAuthzContext")) {
                ctxClz = c;
            }
        }
        INode inode = Mockito.mock(INode.class);
        Mockito.when(inode.isDirectory()).thenReturn(true);
        INodeAttributes attr = Mockito.mock(INodeAttributes.class);
        // consume stubbed isDirectory
        inode.isDirectory();
        byte[][]                                          components = new byte[][] {"root".getBytes()};
        OperationOptimizer                                optimizer  = new OperationOptimizer(enforcer, "listStatus", "/root/", null, null, null, null, components, new INodeAttributes[] {attr}, 0, null, null, inode);
        RangerAccessControlEnforcer.OptimizedAuthzContext ctx        = optimizer.optimize();
        Assertions.assertNotNull(ctx);

        Field accessF = ctxClz.getDeclaredField("access");
        accessF.setAccessible(true);
        Assertions.assertEquals(FsAction.READ_EXECUTE, accessF.get(ctx));

        Field pathF = ctxClz.getDeclaredField("path");
        pathF.setAccessible(true);
        Assertions.assertEquals("/root", pathF.get(ctx));
    }

    @Test
    public void test09_operationOptimizer_isOptimizableOperation() throws Exception {
        Assertions.assertTrue(OperationOptimizer.isOptimizableOperation("create"));
        Assertions.assertTrue(OperationOptimizer.isOptimizableOperation("delete"));
        Assertions.assertTrue(OperationOptimizer.isOptimizableOperation("rename"));
        Assertions.assertTrue(OperationOptimizer.isOptimizableOperation("mkdirs"));
        Assertions.assertTrue(OperationOptimizer.isOptimizableOperation("listStatus"));
        Assertions.assertTrue(OperationOptimizer.isOptimizableOperation("getEZForPath"));
        Assertions.assertFalse(OperationOptimizer.isOptimizableOperation("randomOp"));
    }

    @Test
    public void test10_operationOptimizer_create_fileNullAccess_returnsNull() throws Exception {
        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(Mockito.mock(RangerHdfsPlugin.class), Mockito.mock(AccessControlEnforcer.class));
        INode                       fileNode = Mockito.mock(INode.class);
        Mockito.when(fileNode.isFile()).thenReturn(true);
        INodeAttributes attr = Mockito.mock(INodeAttributes.class);
        // consume stubbed isFile
        fileNode.isFile();
        byte[][]                                          components = new byte[][] {"f".getBytes()};
        OperationOptimizer                                optimizer  = new OperationOptimizer(enforcer, "create", "/f", null, null, null, null, components, new INodeAttributes[] {attr}, 0, null, null, fileNode);
        RangerAccessControlEnforcer.OptimizedAuthzContext ctx        = optimizer.optimize();
        Assertions.assertNull(ctx);
    }

    @Test
    public void test11_operationOptimizer_rename_parentDirectory_returnsContext() throws Exception {
        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(Mockito.mock(RangerHdfsPlugin.class), Mockito.mock(AccessControlEnforcer.class));
        Class<?>                    ctxClz   = null;
        for (Class<?> c : RangerAccessControlEnforcer.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals("OptimizedAuthzContext")) {
                ctxClz = c;
            }
        }
        INode dirParent = Mockito.mock(INode.class);
        Mockito.when(dirParent.isDirectory()).thenReturn(true);
        INodeAttributes attr = Mockito.mock(INodeAttributes.class);
        // consume stubbed isDirectory
        dirParent.isDirectory();
        byte[][]                                          components = new byte[][] {"".getBytes(), "p".getBytes(), "f".getBytes()};
        OperationOptimizer                                optimizer  = new OperationOptimizer(enforcer, "rename", "/p/f", null, null, null, null, components, new INodeAttributes[] {attr, attr, attr}, 0, null, dirParent, null);
        RangerAccessControlEnforcer.OptimizedAuthzContext ctx        = optimizer.optimize();
        Assertions.assertNotNull(ctx);
        Field pathF = ctxClz.getDeclaredField("path");
        pathF.setAccessible(true);
        Assertions.assertEquals("/p", pathF.get(ctx));
    }

    @Test
    public void test12_operationOptimizer_mkdirs_nodeIsFile_returnsNull() throws Exception {
        RangerAccessControlEnforcer enforcer = new RangerAccessControlEnforcer(Mockito.mock(RangerHdfsPlugin.class), Mockito.mock(AccessControlEnforcer.class));
        INode                       file     = Mockito.mock(INode.class);
        Mockito.when(file.isFile()).thenReturn(true);
        INodeAttributes attr = Mockito.mock(INodeAttributes.class);
        // consume stubbed isFile
        file.isFile();
        byte[][]                                          components = new byte[][] {"d".getBytes()};
        OperationOptimizer                                optimizer  = new OperationOptimizer(enforcer, "mkdirs", "/d", null, null, null, null, components, new INodeAttributes[] {attr}, 0, null, null, file);
        RangerAccessControlEnforcer.OptimizedAuthzContext ctx        = optimizer.optimize();
        Assertions.assertNull(ctx);
    }
}
