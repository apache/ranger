/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.services.hdfs;

import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerAccessTypeDef;
import org.apache.ranger.plugin.model.RangerServiceDef.RangerResourceDef;
import org.apache.ranger.plugin.resourcematcher.RangerAbstractResourceMatcher;
import org.apache.ranger.plugin.resourcematcher.RangerPathResourceMatcher;
import org.apache.ranger.plugin.service.ResourceLookupContext;
import org.apache.ranger.services.hdfs.client.HdfsResourceMgr;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RangerServiceHdfs
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerServiceHdfs {
    @Test
    public void test01_validateConfig_delegatesToConnectionTest() throws Exception {
        RangerServiceHdfs svc     = new RangerServiceHdfs();
        RangerServiceDef  def     = buildMinimalServiceDef();
        RangerService     service = buildService("hdfs-test", "hdfs", new HashMap<>());
        svc.init(def, service);

        Map<String, Object> expected = new HashMap<>();
        expected.put("status", "ok");

        try (MockedStatic<HdfsResourceMgr> mocked = Mockito.mockStatic(HdfsResourceMgr.class)) {
            mocked.when(() -> HdfsResourceMgr.connectionTest(Mockito.eq("hdfs-test"), Mockito.anyMap())).thenReturn(expected);

            Map<String, Object> ret = svc.validateConfig();
            Assertions.assertEquals(expected, ret);
            mocked.verify(() -> HdfsResourceMgr.connectionTest(Mockito.eq("hdfs-test"), Mockito.anyMap()));
        }
    }

    @Test
    public void test02_lookupResource_delegatesToGetHdfsResources() throws Exception {
        RangerServiceHdfs svc     = new RangerServiceHdfs();
        RangerServiceDef  def     = buildMinimalServiceDef();
        RangerService     service = buildService("hdfs-svc", "hdfs", new HashMap<>());
        svc.init(def, service);

        ResourceLookupContext ctx = new ResourceLookupContext();
        ctx.setUserInput("/tmp/");
        ctx.setResourceName("path");
        Map<String, List<String>> res = new HashMap<>();
        res.put(HdfsResourceMgr.PATH, Collections.singletonList("/tmp"));
        ctx.setResources(res);

        List<String> expected = Arrays.asList("/tmp/a", "/tmp/b");

        try (MockedStatic<HdfsResourceMgr> mocked = Mockito.mockStatic(HdfsResourceMgr.class)) {
            mocked.when(() -> HdfsResourceMgr.getHdfsResources(Mockito.eq("hdfs-svc"), Mockito.eq("hdfs"), Mockito.anyMap(), Mockito.eq(ctx))).thenReturn(expected);

            List<String> ret = svc.lookupResource(ctx);
            Assertions.assertEquals(expected, ret);
            mocked.verify(() -> HdfsResourceMgr.getHdfsResources(Mockito.eq("hdfs-svc"), Mockito.eq("hdfs"), Mockito.anyMap(), Mockito.eq(ctx)));
        }
    }

    @Test
    public void test03_getDefaultRangerPolicies_setsPathWildcard_andAddsAuditPolicies() throws Exception {
        RangerServiceHdfs   svc = new RangerServiceHdfs();
        RangerServiceDef    def = buildMinimalServiceDef();
        Map<String, String> cfg = new HashMap<>();
        cfg.put("setup.additional.default.policies", "false");
        RangerService service = buildService("hdfs-def", "hdfs", cfg);
        svc.init(def, service);

        List<RangerPolicy> policies = svc.getDefaultRangerPolicies();
        Assertions.assertFalse(policies.isEmpty());

        boolean foundAll          = false;
        boolean foundKms          = false;
        boolean foundHbaseArchive = false;

        for (RangerPolicy p : policies) {
            if (p.getName().contains("all")) {
                RangerPolicy.RangerPolicyResource r = p.getResources().get("path");
                Assertions.assertNotNull(r);
                Assertions.assertEquals(Collections.singletonList("/*"), r.getValues());
                foundAll = true;
            }
            if ("kms-audit-path".equals(p.getName())) {
                Assertions.assertEquals(Collections.singletonList("/ranger/audit/kms"), p.getResources().get("path").getValues());
                Assertions.assertTrue(p.getPolicyItems().stream().anyMatch(it -> it.getUsers() != null && it.getUsers().contains("keyadmin")));
                foundKms = true;
            }
            if ("hbase-archive".equals(p.getName())) {
                Assertions.assertEquals(Collections.singletonList("/hbase/archive"), p.getResources().get("path").getValues());
                Assertions.assertTrue(p.getPolicyItems().stream().anyMatch(it -> it.getUsers() != null && it.getUsers().contains("hbase")));
                foundHbaseArchive = true;
            }
        }

        Assertions.assertTrue(foundAll);
        Assertions.assertTrue(foundKms);
        Assertions.assertTrue(foundHbaseArchive);
    }

    private RangerService buildService(String name, String type, Map<String, String> cfg) {
        RangerService svc = new RangerService();
        svc.setName(name);
        svc.setType(type);
        svc.setConfigs(cfg);
        return svc;
    }

    private RangerServiceDef buildMinimalServiceDef() {
        RangerServiceDef def = new RangerServiceDef();
        def.setName("hdfs");

        RangerAccessTypeDef read = new RangerAccessTypeDef();
        read.setName("read");
        RangerAccessTypeDef write = new RangerAccessTypeDef();
        write.setName("write");
        def.setAccessTypes(Arrays.asList(read, write));

        Map<String, String> options = new HashMap<>();
        options.put("create.default.policy.per.hierarchy", "true");
        def.setOptions(options);

        RangerResourceDef path = new RangerResourceDef();
        path.setName("path");
        path.setMandatory(true);
        path.setRecursiveSupported(true);
        path.setMatcher(RangerPathResourceMatcher.class.getName());
        Map<String, String> matcherOptions = new HashMap<>();
        matcherOptions.put(RangerPathResourceMatcher.OPTION_PATH_SEPARATOR, "/");
        matcherOptions.put(RangerAbstractResourceMatcher.OPTION_WILD_CARD, "true");
        path.setMatcherOptions(matcherOptions);

        List<RangerResourceDef> resources = new ArrayList<>();
        resources.add(path);
        def.setResources(resources);
        return def;
    }
}
