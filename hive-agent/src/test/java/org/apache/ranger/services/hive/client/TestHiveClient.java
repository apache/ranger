/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.services.hive.client;

import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;
import org.apache.hadoop.hive.metastore.api.FieldSchema;
import org.apache.ranger.plugin.client.HadoopConfigHolder;
import org.apache.ranger.plugin.client.HadoopException;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.security.auth.Subject;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.Permission;
import java.security.PrivilegedExceptionAction;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverPropertyInfo;
import java.sql.ResultSet;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLTimeoutException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description : Unit Test cases for HiveClient
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestHiveClient {
    @Test
    public void test01_connectionTestEmptyDbListSetsFailureMessage() throws Exception {
        try (MockedConstruction<HiveClient> cons = Mockito.mockConstruction(HiveClient.class, (mock, ctx) -> {
            Mockito.when(mock.getDatabaseList("*", null)).thenReturn(Collections.emptyList());
        })) {
            Map<String, Object> resp = HiveClient.connectionTest("svc", Collections.emptyMap());
            assertNotNull(resp);
            assertNotEquals(Boolean.TRUE, resp.get("connectivityStatus"));
        }
    }

    @Test
    public void test02_connectionTestSuccessSetsSuccessMessageAndCloses() throws Exception {
        try (MockedConstruction<HiveClient> cons = Mockito.mockConstruction(HiveClient.class, (mock, ctx) -> {
            Mockito.when(mock.getDatabaseList("*", null)).thenReturn(Collections.singletonList("db1"));
        })) {
            Map<String, Object> resp = HiveClient.connectionTest("svc", new HashMap<>());
            assertNotNull(resp);
            List<HiveClient> constructed = cons.constructed();
            if (!constructed.isEmpty()) {
                Mockito.verify(constructed.get(0), Mockito.times(1)).close();
            }
        }
    }

    @Test
    public void test03_connectionTestPropagatesException() throws Exception {
        try (MockedConstruction<HiveClient> cons = Mockito.mockConstruction(HiveClient.class, (mock, ctx) -> {
            Mockito.when(mock.getDatabaseList("*", null)).thenThrow(new RuntimeException("boom"));
        })) {
            assertThrows(Exception.class, () -> HiveClient.connectionTest("svc", Collections.emptyMap()));
        }
    }

    @Test
    public void test04_constructorsInvokeInitHive() throws Exception {
        NoopHiveClient c1 = new NoopHiveClient("svc");
        assertTrue(c1.initCalled);
        NoopHiveClient c2 = new NoopHiveClient("svc", new HashMap<>());
        assertTrue(c2.initCalled);
    }

    @Test
    public void test05_getDatabaseList_usesHMWhenEnabled() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, true);
        Field fHM = HiveClient.class.getDeclaredField("hiveClient");
        fHM.setAccessible(true);
        HiveMetaStoreClient hms = Mockito.mock(HiveMetaStoreClient.class);
        when(hms.getAllDatabases()).thenReturn(Arrays.asList("db1", "db2"));
        fHM.set(client, hms);
        List<String> out = client.getDatabaseList("*", Collections.singletonList("db2"));
        assertEquals(Collections.singletonList("db1"), out);
    }

    @Test
    public void test06_getTableList_usesHMAndRespectsExcludes() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, true);
        Field fHM = HiveClient.class.getDeclaredField("hiveClient");
        fHM.setAccessible(true);
        HiveMetaStoreClient hms = Mockito.mock(HiveMetaStoreClient.class);
        when(hms.getTables("db1", "tbl*")).thenReturn(Arrays.asList("t1", "t2"));
        fHM.set(client, hms);
        List<String> out = client.getTableList("tbl*", Collections.singletonList("db1"), Collections.singletonList("t2"));
        assertEquals(Collections.singletonList("t1"), out);
    }

    @Test
    public void test07_getColumnList_usesHMWithPatternAndExcludes() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, true);
        Field fHM = HiveClient.class.getDeclaredField("hiveClient");
        fHM.setAccessible(true);
        HiveMetaStoreClient hms = Mockito.mock(HiveMetaStoreClient.class);
        when(hms.getFields("db1", "t1")).thenReturn(Arrays.asList(new FieldSchema("c1", "int", null), new FieldSchema("c2", "string", null)));
        fHM.set(client, hms);
        List<String> out = client.getColumnList("c*", Collections.singletonList("db1"), Collections.singletonList("t1"), Collections.singletonList("c2"));
        assertEquals(Collections.singletonList("c1"), out);
    }

    @Test
    public void test08_main_args2_noDatabaseFoundPrintedAndClosed() throws Exception {
        PrintStream           origOut = System.out;
        ByteArrayOutputStream bout    = new ByteArrayOutputStream();
        System.setOut(new PrintStream(bout));
        try (MockedConstruction<HiveClient> cons = Mockito.mockConstruction(HiveClient.class, (mock, ctx) -> {
            when(mock.getDatabaseList("db", null)).thenReturn(Collections.emptyList());
        })) {
            HiveClient.main(new String[] {"svc", "db"});
            String out = bout.toString();
            assertNotNull(out);
            // ensure constructed mock was closed by try-with-resources
            List<HiveClient> constructed = cons.constructed();
            if (!constructed.isEmpty()) {
                Mockito.verify(constructed.get(0), Mockito.times(1)).close();
            }
        } finally {
            System.setOut(origOut);
        }
    }

    @Test
    public void test09_main_args3_printsTables() throws Exception {
        PrintStream           origOut = System.out;
        ByteArrayOutputStream bout    = new ByteArrayOutputStream();
        System.setOut(new PrintStream(bout));
        try (MockedConstruction<HiveClient> cons = Mockito.mockConstruction(HiveClient.class, (mock, ctx) -> {
            when(mock.getTableList("tbl", null, null)).thenReturn(Collections.singletonList("db.tbl1"));
        })) {
            HiveClient.main(new String[] {"svc", "db", "tbl"});
            String out = bout.toString();
            assertNotNull(out);
        } finally {
            System.setOut(origOut);
        }
    }

    @Test
    public void test10_main_args4_printsColumns() throws Exception {
        PrintStream           origOut = System.out;
        ByteArrayOutputStream bout    = new ByteArrayOutputStream();
        System.setOut(new PrintStream(bout));
        try (MockedConstruction<HiveClient> cons = Mockito.mockConstruction(HiveClient.class, (mock, ctx) -> {
            when(mock.getColumnList("col", null, null, null)).thenReturn(Collections.singletonList("db.tbl.col1"));
        })) {
            HiveClient.main(new String[] {"svc", "db", "tbl", "col"});
            String out = bout.toString();
            assertNotNull(out);
        } finally {
            System.setOut(origOut);
        }
    }

    @Test
    public void test11_getDatabaseList_jdbcPath() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, false);
        Field fCon = HiveClient.class.getDeclaredField("con");
        fCon.setAccessible(true);
        Connection con  = Mockito.mock(Connection.class);
        Statement  stat = Mockito.mock(Statement.class);
        ResultSet  rs   = Mockito.mock(ResultSet.class);
        when(con.createStatement()).thenReturn(stat);
        when(stat.executeQuery(Mockito.anyString())).thenReturn(rs);
        when(rs.next()).thenReturn(true, false);
        when(rs.getString(1)).thenReturn("db1");
        fCon.set(client, con);
        List<String> out = client.getDatabaseList("db*", null);
        assertEquals(Collections.singletonList("db1"), out);
    }

    @Test
    public void test12_close_closesConnection() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fCon   = HiveClient.class.getDeclaredField("con");
        fCon.setAccessible(true);
        Connection con = Mockito.mock(Connection.class);
        fCon.set(client, con);
        client.close();
        Mockito.verify(con, Mockito.times(1)).close();
    }

    @Test
    public void test13_getTableList_jdbcPath_excludesAndPattern() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, false);
        Field fCon = HiveClient.class.getDeclaredField("con");
        fCon.setAccessible(true);
        Connection con  = Mockito.mock(Connection.class);
        Statement  stat = Mockito.mock(Statement.class);
        ResultSet  rs   = Mockito.mock(ResultSet.class);
        when(con.createStatement()).thenReturn(stat);
        when(stat.execute(Mockito.eq("use db1"))).thenReturn(true);
        when(stat.executeQuery(Mockito.anyString())).thenReturn(rs);
        when(rs.next()).thenReturn(true, true, false);
        when(rs.getString(1)).thenReturn("t1", "t2");
        fCon.set(client, con);
        List<String> out = client.getTableList("t*", Collections.singletonList("db1"), Collections.singletonList("t2"));
        assertEquals(Collections.singletonList("t1"), out);
        Mockito.verify(stat, Mockito.atLeastOnce()).execute(Mockito.eq("use db1"));
    }

    @Test
    public void test14_getTableList_jdbcPath_timeoutThrowsHadoopException() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, false);
        Field fCon = HiveClient.class.getDeclaredField("con");
        fCon.setAccessible(true);
        Connection con  = Mockito.mock(Connection.class);
        Statement  stat = Mockito.mock(Statement.class);
        when(con.createStatement()).thenReturn(stat);
        when(stat.execute(Mockito.anyString())).thenReturn(true);
        when(stat.executeQuery(Mockito.anyString())).thenThrow(new SQLTimeoutException("timeout"));
        fCon.set(client, con);
        assertThrows(HadoopException.class, () -> client.getTableList("t*", Collections.singletonList("db1"), null));
    }

    @Test
    public void test17_getClmList_jdbcPath_excludesAndPattern() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, false);
        Field fCon = HiveClient.class.getDeclaredField("con");
        fCon.setAccessible(true);
        Connection con  = Mockito.mock(Connection.class);
        Statement  stat = Mockito.mock(Statement.class);
        ResultSet  rs   = Mockito.mock(ResultSet.class);
        when(con.createStatement()).thenReturn(stat);
        when(stat.execute(Mockito.eq("use db1"))).thenReturn(true);
        when(stat.executeQuery(Mockito.eq("describe  t1"))).thenReturn(rs);
        when(rs.next()).thenReturn(true, true, false);
        when(rs.getString(1)).thenReturn("c1", "c2");
        fCon.set(client, con);
        List<String> out = client.getColumnList("c*", Collections.singletonList("db1"), Collections.singletonList("t1"), Collections.singletonList("c2"));
        assertEquals(Collections.singletonList("c1"), out);
    }

    @Test
    public void test18_getClmList_jdbcPath_timeoutThrowsHadoopException() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, false);
        Field fCon = HiveClient.class.getDeclaredField("con");
        fCon.setAccessible(true);
        Connection con  = Mockito.mock(Connection.class);
        Statement  stat = Mockito.mock(Statement.class);
        when(con.createStatement()).thenReturn(stat);
        when(stat.execute(Mockito.anyString())).thenReturn(true);
        when(stat.executeQuery(Mockito.anyString())).thenThrow(new SQLTimeoutException("timeout"));
        fCon.set(client, con);
        assertThrows(HadoopException.class, () -> client.getColumnList("c*", Collections.singletonList("db1"), Collections.singletonList("t1"), null));
    }

    @Test
    public void test19_main_noArgs_printsUsageAndExits() {
        PrintStream           origErr = System.err;
        ByteArrayOutputStream berr    = new ByteArrayOutputStream();
        System.setErr(new PrintStream(berr));
        SecurityManager              prev = System.getSecurityManager();
        ExitInterceptSecurityManager sm   = new ExitInterceptSecurityManager(prev);
        System.setSecurityManager(sm);
        try {
            assertThrows(SecurityException.class, () -> HiveClient.main(new String[] {}));
            assertEquals(Integer.valueOf(1), sm.status);
            String err = berr.toString();
            assertNotNull(err);
            assertTrue(err.contains("USAGE: java"));
        } finally {
            System.setErr(origErr);
            System.setSecurityManager(prev);
        }
    }

    @Test
    public void test20_getViewListAndUDFListReturnNull() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        assertNull(client.getViewList("db", "v*"));
        assertNull(client.getUDFList("db", "f*"));
    }

    @Test
    public void test21_privateInitConnection_wrapperRethrowsAsHadoopException() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        // Configure holder to take HM path so inner will wrap to HadoopException
        Field fCfg = Class.forName("org.apache.ranger.plugin.client.BaseClient").getDeclaredField("configHolder");
        fCfg.setAccessible(true);
        HadoopConfigHolder cfg = Mockito.mock(HadoopConfigHolder.class);
        when(cfg.getRangerSection()).thenReturn(new Properties());
        fCfg.set(client, cfg);
        Method m = HiveClient.class.getDeclaredMethod("initConnection");
        m.setAccessible(true);
        assertThrows(HadoopException.class, () -> {
            try {
                m.invoke(client);
            } catch (InvocationTargetException ite) {
                throw ite.getCause();
            }
        });
    }

    @Test
    public void test22_initConnection_hmBranch_success() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, true);
        Field fSite = HiveClient.class.getDeclaredField("hiveSiteFilePath");
        fSite.setAccessible(true);
        fSite.set(client, "/path/does/not/exist/hive-site.xml");
        try (MockedConstruction<HiveMetaStoreClient> cons = Mockito.mockConstruction(HiveMetaStoreClient.class, (mock, ctx) -> {})) {
            Method m = HiveClient.class.getDeclaredMethod("initConnection", String.class, String.class);
            m.setAccessible(true);
            // should not throw; constructor intercepted and hiveClient set
            m.invoke(client, null, null);
            List<HiveMetaStoreClient> constructed = cons.constructed();
            assertTrue(constructed.size() >= 1);
        }
    }

    @Test
    public void test22b_initConnection_hmBranch_throwableWrapsAsHadoopException() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fFlag  = HiveClient.class.getDeclaredField("enableHiveMetastoreLookup");
        fFlag.setAccessible(true);
        fFlag.set(client, true);
        Field fSite = HiveClient.class.getDeclaredField("hiveSiteFilePath");
        fSite.setAccessible(true);
        fSite.set(client, ""); // triggers "property not found" path
        try (MockedConstruction<HiveMetaStoreClient> cons = Mockito.mockConstruction(HiveMetaStoreClient.class, (mock, ctx) -> {
            throw new RuntimeException("boom");
        })) {
            Method m = HiveClient.class.getDeclaredMethod("initConnection", String.class, String.class);
            m.setAccessible(true);
            assertThrows(HadoopException.class, () -> {
                try {
                    m.invoke(client, null, null);
                } catch (InvocationTargetException ite) {
                    throw ite.getCause();
                }
            });
        }
    }

    @Test
    public void test23_initConnection_jdbcBranch_reflectionExceptionPaths() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fCfg   = Class.forName("org.apache.ranger.plugin.client.BaseClient").getDeclaredField("configHolder");
        fCfg.setAccessible(true);
        HadoopConfigHolder cfg         = Mockito.mock(HadoopConfigHolder.class);
        Properties         rangerProps = new Properties();
        rangerProps.setProperty("jdbc.driverClassName", TestHiveClient.IllegalAccessDriver.class.getName());
        rangerProps.setProperty("jdbc.url", "jdbc:hive2://localhost:10000");
        when(cfg.getRangerSection()).thenReturn(rangerProps);
        fCfg.set(client, cfg);
        Method m = HiveClient.class.getDeclaredMethod("initConnection", String.class, String.class);
        m.setAccessible(true);
        // IllegalAccessException path
        assertThrows(HadoopException.class, () -> {
            try {
                m.invoke(client, null, null);
            } catch (InvocationTargetException ite) {
                throw ite.getCause();
            }
        });
        // Class not found -> Throwable path
        rangerProps.setProperty("jdbc.driverClassName", "com.example.NoSuchDriver");
        assertThrows(HadoopException.class, () -> {
            try {
                m.invoke(client, null, null);
            } catch (InvocationTargetException ite) {
                throw ite.getCause();
            }
        });
    }

    @Test
    public void test24_initHive_kerberosPath_invokesMetastoreInitConnection() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fCfg   = Class.forName("org.apache.ranger.plugin.client.BaseClient").getDeclaredField("configHolder");
        fCfg.setAccessible(true);
        HadoopConfigHolder cfg = Mockito.mock(HadoopConfigHolder.class);
        fCfg.set(client, cfg);
        try (MockedStatic<Subject> subj = Mockito.mockStatic(Subject.class)) {
            subj.when(() -> Subject.doAs(Mockito.any(Subject.class), Mockito.any(PrivilegedExceptionAction.class))).thenReturn(null);
            Method m = HiveClient.class.getDeclaredMethod("initHive");
            m.setAccessible(true);
            assertDoesNotThrow(() -> m.invoke(client));
        }
    }

    @Test
    public void test25_initHive_nonKerberosPath_invokesJdbcInitConnectionAndWraps() throws Exception {
        NoopHiveClient client = new NoopHiveClient("svc", new HashMap<>());
        Field          fCfg   = Class.forName("org.apache.ranger.plugin.client.BaseClient").getDeclaredField("configHolder");
        fCfg.setAccessible(true);
        HadoopConfigHolder cfg = Mockito.mock(HadoopConfigHolder.class);
        Mockito.when(cfg.isEnableHiveMetastoreLookup()).thenReturn(false);
        Mockito.when(cfg.getHiveSiteFilePath()).thenReturn("");
        Mockito.when(cfg.isKerberosAuthentication()).thenReturn(false);
        Mockito.when(cfg.getUserName()).thenReturn("u");
        Mockito.when(cfg.getPassword()).thenReturn("p");
        fCfg.set(client, cfg);
        try (MockedStatic<Subject> subj = Mockito.mockStatic(Subject.class)) {
            subj.when(() -> Subject.doAs(Mockito.any(Subject.class), Mockito.any(PrivilegedExceptionAction.class))).thenReturn(null);
            Method m = HiveClient.class.getDeclaredMethod("initHive");
            m.setAccessible(true);
            assertDoesNotThrow(() -> m.invoke(client));
        }
    }

    public static class NoopHiveClient extends HiveClient {
        public boolean initCalled;

        public NoopHiveClient(String serviceName) throws Exception {
            super(serviceName);
        }

        public NoopHiveClient(String serviceName, Map<String, String> props) throws Exception {
            super(serviceName, props);
        }

        @Override
        public void initHive() {
            initCalled = true;
        }

        @Override
        protected void login() {
            /* no-op to avoid real Hadoop auth */
        }

        @Override
        protected Subject getLoginSubject() {
            return new Subject();
        }
    }

    public static class BypassLoginHiveClient extends HiveClient {
        public BypassLoginHiveClient(String serviceName) throws Exception {
            super(serviceName);
        }

        public BypassLoginHiveClient(String serviceName, Map<String, String> props) throws Exception {
            super(serviceName, props);
        }

        @Override
        protected void login() { /* no-op to avoid real Hadoop auth */ }

        @Override
        protected Subject getLoginSubject() {
            return new Subject();
        }
    }

    private static class ExitInterceptSecurityManager extends SecurityManager {
        private final SecurityManager original;
        public        Integer         status;

        ExitInterceptSecurityManager(SecurityManager original) {
            this.original = original;
        }

        @Override
        public void checkPermission(Permission perm) {
            if (original != null) {
                original.checkPermission(perm);
            }
        }

        @Override
        public void checkExit(int status) {
            this.status = status;
            throw new SecurityException("exit");
        }
    }

    public static class IllegalAccessDriver implements Driver {
        private IllegalAccessDriver() {}

        @Override
        public Connection connect(String url, Properties info) {
            return null;
        }

        @Override
        public boolean acceptsURL(String url) {
            return false;
        }

        @Override
        public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
            return new DriverPropertyInfo[0];
        }

        @Override
        public int getMajorVersion() {
            return 1;
        }

        @Override
        public int getMinorVersion() {
            return 0;
        }

        @Override
        public boolean jdbcCompliant() {
            return false;
        }

        @Override
        public Logger getParentLogger() throws SQLFeatureNotSupportedException {
            throw new SQLFeatureNotSupportedException();
        }
    }
}
