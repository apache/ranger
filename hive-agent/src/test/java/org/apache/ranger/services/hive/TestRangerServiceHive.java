/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.services.hive;

import org.apache.ranger.plugin.client.HadoopException;
import org.apache.ranger.plugin.model.RangerPolicy;
import org.apache.ranger.plugin.model.RangerService;
import org.apache.ranger.plugin.model.RangerServiceDef;
import org.apache.ranger.plugin.policyengine.RangerPolicyEngine;
import org.apache.ranger.plugin.service.ResourceLookupContext;
import org.apache.ranger.services.hive.client.HiveResourceMgr;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RangerServiceHive
 */
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRangerServiceHive {
    @Test
    public void test00_init_setsBaseFields() throws Exception {
        RangerServiceHive svc     = new RangerServiceHive();
        RangerServiceDef  def     = new RangerServiceDef();
        RangerService     service = new RangerService();
        service.setName("svc");
        svc.init(def, service);
        Field fService = RangerServiceHive.class.getSuperclass().getDeclaredField("service");
        fService.setAccessible(true);
        Field fSvcDef = RangerServiceHive.class.getSuperclass().getDeclaredField("serviceDef");
        fSvcDef.setAccessible(true);
        assertEquals(service, fService.get(svc));
        assertEquals(def, fSvcDef.get(svc));
    }

    @Test
    public void test01_validateConfig_delegatesAndReturns() throws Exception {
        Map<String, String> cfg = new HashMap<>();
        cfg.put("k", "v");
        RangerServiceHive svc = newService("svc", "hive", cfg);
        try (MockedStatic<HiveResourceMgr> stat = Mockito.mockStatic(HiveResourceMgr.class)) {
            Map<String, Object> resp = new HashMap<>();
            resp.put("ok", true);
            stat.when(() -> HiveResourceMgr.connectionTest(Mockito.eq("svc"), Mockito.eq(cfg))).thenReturn(resp);
            Map<String, Object> out = svc.validateConfig();
            assertEquals(resp, out);
        }
    }

    @Test
    public void test02_validateConfig_throwsHadoopException() throws Exception {
        Map<String, String> cfg = new HashMap<>();
        RangerServiceHive   svc = newService("svc", "hive", cfg);
        try (MockedStatic<HiveResourceMgr> stat = Mockito.mockStatic(HiveResourceMgr.class)) {
            stat.when(() -> HiveResourceMgr.connectionTest(Mockito.eq("svc"), Mockito.eq(cfg))).thenThrow(new HadoopException("x"));
            assertThrows(HadoopException.class, svc::validateConfig);
        }
    }

    @Test
    public void test03_lookupResource_delegates() throws Exception {
        Map<String, String>   cfg = new HashMap<>();
        RangerServiceHive     svc = newService("svc", "hive", cfg);
        ResourceLookupContext ctx = new ResourceLookupContext();
        try (MockedStatic<HiveResourceMgr> stat = Mockito.mockStatic(HiveResourceMgr.class)) {
            List<String> resp = Collections.singletonList("db1");
            stat.when(() -> HiveResourceMgr.getHiveResources("svc", "hive", cfg, ctx)).thenReturn(resp);
            List<String> out = svc.lookupResource(ctx);
            assertEquals(resp, out);
        }
    }

    @Test
    public void test04_lookupResource_nullContextReturnsEmpty() throws Exception {
        RangerServiceHive svc = newService("svc", "hive", new HashMap<>());
        List<String>      out = svc.lookupResource(null);
        assertNotNull(out);
        assertTrue(out.isEmpty());
    }

    @Test
    public void test05_createDefaultDBPolicy_reflection() throws Exception {
        RangerServiceHive svc = newService("svc", "hive", new HashMap<>());
        Method            m   = RangerServiceHive.class.getDeclaredMethod("createDefaultDBPolicy");
        m.setAccessible(true);
        RangerPolicy p = (RangerPolicy) m.invoke(svc);
        assertNotNull(p);
        assertEquals("default database tables columns", p.getName());
        assertEquals("svc", p.getService());
        Map<String, RangerPolicy.RangerPolicyResource> res = p.getResources();
        assertEquals(Collections.singletonList("default"), res.get("database").getValues());
        assertEquals(Collections.singletonList("*"), res.get("table").getValues());
        assertEquals(Collections.singletonList("*"), res.get("column").getValues());
    }

    @Test
    public void test06_createInformationSchemaPolicy_reflection() throws Exception {
        RangerServiceHive svc = newService("svc", "hive", new HashMap<>());
        Method            m   = RangerServiceHive.class.getDeclaredMethod("createInformationSchemaPolicy");
        m.setAccessible(true);
        RangerPolicy p = (RangerPolicy) m.invoke(svc);
        assertNotNull(p);
        assertEquals("Information_schema database tables columns", p.getName());
        assertEquals("svc", p.getService());
        Map<String, RangerPolicy.RangerPolicyResource> res = p.getResources();
        assertEquals(Collections.singletonList("information_schema"), res.get("database").getValues());
        assertEquals(Collections.singletonList("*"), res.get("table").getValues());
        assertEquals(Collections.singletonList("*"), res.get("column").getValues());
    }

    @Test
    public void test07_hasWildcardAsteriskResource_trueFalse() throws Exception {
        RangerServiceHive svc = newService("svc", "hive", new HashMap<>());
        Method            m   = RangerServiceHive.class.getDeclaredMethod("hasWildcardAsteriskResource", Map.class, String[].class);
        m.setAccessible(true);
        Map<String, RangerPolicy.RangerPolicyResource> res = new HashMap<>();
        res.put("database", new RangerPolicy.RangerPolicyResource(Collections.singletonList("*"), false, false));
        assertTrue((Boolean) m.invoke(svc, res, new String[] {"database"}));
    }

    @Test
    public void test08_getDefaultRangerPolicies_appendsDefaultAndInfo() throws Exception {
        RangerServiceHive svc = newService("svc", "hive", new HashMap<>());
        // minimally initialize service and serviceDef so super call doesn't NPE
        RangerService service = new RangerService();
        service.setName("svc");
        Field fService = RangerServiceHive.class.getSuperclass().getDeclaredField("service");
        fService.setAccessible(true);
        fService.set(svc, service);
        Field fSvcDef = RangerServiceHive.class.getSuperclass().getDeclaredField("serviceDef");
        fSvcDef.setAccessible(true);
        fSvcDef.set(svc, new RangerServiceDef());

        List<RangerPolicy> out = svc.getDefaultRangerPolicies();
        assertNotNull(out);
        boolean hasDefault = out.stream().anyMatch(p -> "default database tables columns".equals(p.getName()));
        boolean hasInfo    = out.stream().anyMatch(p -> "Information_schema database tables columns".equals(p.getName()));
        assertTrue(hasDefault);
        assertTrue(hasInfo);
    }

    @Test
    public void test09_getDefaultRangerPolicies_addsLookupUserAndOwnerItems() throws Exception {
        // Prepare configs to drive additional default policies from base service
        Map<String, String> cfg = new HashMap<>();
        cfg.put("setup.additional.default.policies", "true");
        // policy 1: all databases (database=*) => should add public(create) and owner(all)
        cfg.put("default-policy.1.name", "all - database");
        cfg.put("default-policy.1.resource.database", "*");
        // policy 2: all tables (database=*, table=*) => should add owner(all)
        cfg.put("default-policy.2.name", "all - database, table");
        cfg.put("default-policy.2.resource.database", "*");
        cfg.put("default-policy.2.resource.table", "*");
        RangerServiceHive svc = newService("svc", "hive", cfg);
        // set lookUpUser so lookup-user entry is created for policies with name containing "all"
        Field fLook = RangerServiceHive.class.getSuperclass().getDeclaredField("lookUpUser");
        fLook.setAccessible(true);
        fLook.set(svc, "lookupUser");
        // also initialize service and serviceDef like in test08 to avoid NPEs inside super.getDefaultRangerPolicies
        RangerService service = new RangerService();
        service.setName("svc");
        Field fService = RangerServiceHive.class.getSuperclass().getDeclaredField("service");
        fService.setAccessible(true);
        fService.set(svc, service);
        Field fSvcDef = RangerServiceHive.class.getSuperclass().getDeclaredField("serviceDef");
        fSvcDef.setAccessible(true);
        fSvcDef.set(svc, new RangerServiceDef());
        List<RangerPolicy> out = svc.getDefaultRangerPolicies();
        assertNotNull(out);
        // find our additional default policies
        RangerPolicy allDb  = out.stream().filter(p -> "all - database".equals(p.getName())).findFirst().orElse(null);
        RangerPolicy allTbl = out.stream().filter(p -> "all - database, table".equals(p.getName())).findFirst().orElse(null);
        assertNotNull(allDb);
        assertNotNull(allTbl);
        // verify lookup-user, public(create), and owner(all) on database=* policy
        assertTrue(allDb.getPolicyItems().stream().anyMatch(i -> i.getUsers() != null && i.getUsers().contains("lookupUser")));
        assertTrue(allDb.getPolicyItems().stream().anyMatch(i -> i.getGroups() != null && i.getGroups().contains(RangerPolicyEngine.GROUP_PUBLIC)));
        assertTrue(allDb.getPolicyItems().stream().anyMatch(i -> i.getUsers() != null && i.getUsers().contains(RangerPolicyEngine.RESOURCE_OWNER)));
        // verify owner(all) on database=* and table=* policy
        assertTrue(allTbl.getPolicyItems().stream().anyMatch(i -> i.getUsers() != null && i.getUsers().contains(RangerPolicyEngine.RESOURCE_OWNER)));
    }

    private static RangerServiceHive newService(String name, String type, Map<String, String> configs) throws Exception {
        RangerServiceHive svc   = new RangerServiceHive();
        Field             fName = RangerServiceHive.class.getSuperclass().getDeclaredField("serviceName");
        fName.setAccessible(true);
        fName.set(svc, name);
        Field fType = RangerServiceHive.class.getSuperclass().getDeclaredField("serviceType");
        fType.setAccessible(true);
        fType.set(svc, type);
        Field fCfg = RangerServiceHive.class.getSuperclass().getDeclaredField("configs");
        fCfg.setAccessible(true);
        fCfg.set(svc, configs);
        return svc;
    }
}
