/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.ugsyncutil.transform;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RegEx
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRegEx {
    @Test
    public void test01_UserNameTransform() {
        String       userNameBaseProperty = "ranger.usersync.mapping.username.regex";
        String       mappingSeparator     = "/";
        RegEx        userNameRegEx        = new RegEx();
        List<String> userRegexPatterns    = new ArrayList<>();

        userRegexPatterns.add("s/\\s/_/");
        userNameRegEx.populateReplacementPatterns(userNameBaseProperty, userRegexPatterns, mappingSeparator);
        Assertions.assertEquals("test_user", userNameRegEx.transform("test user"));
    }

    @Test
    public void test02_GroupNameTransform() {
        String       groupNameBaseProperty = "ranger.usersync.mapping.groupname.regex";
        String       mappingSeparator      = "/";
        RegEx        groupNameRegEx        = new RegEx();
        List<String> groupRegexPatterns    = new ArrayList<>();

        groupRegexPatterns.add("s/\\s/_/g");
        groupRegexPatterns.add("s/_/\\$/g");
        groupNameRegEx.populateReplacementPatterns(groupNameBaseProperty, groupRegexPatterns, mappingSeparator);
        Assertions.assertEquals("ldap$grp", groupNameRegEx.transform("ldap grp"));
    }

    @Test
    public void test03_EmptyTransform() {
        RegEx userNameRegEx  = new RegEx();
        RegEx groupNameRegEx = new RegEx();

        Assertions.assertEquals("test user", userNameRegEx.transform("test user"));
        Assertions.assertEquals("ldap grp", groupNameRegEx.transform("ldap grp"));
    }

    @Test
    public void test04_Transform() {
        String       userNameBaseProperty  = "ranger.usersync.mapping.username.regex";
        String       groupNameBaseProperty = "ranger.usersync.mapping.groupname.regex";
        String       mappingSeparator      = "/";
        RegEx        userNameRegEx         = new RegEx();
        RegEx        groupNameRegEx        = new RegEx();
        List<String> userRegexPatterns     = new ArrayList<>();
        List<String> groupRegexPatterns    = new ArrayList<>();

        userRegexPatterns.add("s/\\s/_/g");
        groupRegexPatterns.add("s/\\s/_/g");
        userNameRegEx.populateReplacementPatterns(userNameBaseProperty, userRegexPatterns, mappingSeparator);
        groupNameRegEx.populateReplacementPatterns(groupNameBaseProperty, groupRegexPatterns, mappingSeparator);
        Assertions.assertEquals("test_user", userNameRegEx.transform("test user"));
        Assertions.assertEquals("ldap_grp", groupNameRegEx.transform("ldap grp"));
    }

    @Test
    public void test05_Transform1() {
        String       userNameBaseProperty  = "ranger.usersync.mapping.username.regex";
        String       groupNameBaseProperty = "ranger.usersync.mapping.groupname.regex";
        String       mappingSeparator      = "/";
        RegEx        userNameRegEx         = new RegEx();
        RegEx        groupNameRegEx        = new RegEx();
        List<String> userRegexPatterns     = new ArrayList<>();
        List<String> groupRegexPatterns    = new ArrayList<>();

        userRegexPatterns.add("s/\\\\/ /g");
        userRegexPatterns.add("s//_/g");
        userNameRegEx.populateReplacementPatterns(userNameBaseProperty, userRegexPatterns, mappingSeparator);
        groupRegexPatterns.add("s/\\s/\\$/g");
        groupRegexPatterns.add("s/\\s");
        groupRegexPatterns.add("s/\\$//g");
        groupNameRegEx.populateReplacementPatterns(groupNameBaseProperty, groupRegexPatterns, mappingSeparator);
        Assertions.assertEquals("test user", userNameRegEx.transform("test\\user"));
        Assertions.assertEquals("ldapgrp", groupNameRegEx.transform("ldap grp"));
    }

    @Test
    public void test06_TransformWithSeparators() {
        String   userNameBaseProperty = "ranger.usersync.mapping.username.regex";
        String[] separators           = {"%", "#", "&", "!", "@", "-", "~", "=", ",", " "};
        for (String separator : separators) {
            List<String> userRegexPatterns = new ArrayList<>();
            RegEx        userNameRegEx     = new RegEx();
            userRegexPatterns.add(String.format("s%sdark%sDE/dark%sg", separator, separator, separator));
            userNameRegEx.populateReplacementPatterns(userNameBaseProperty, userRegexPatterns, separator);
            Assertions.assertEquals("DE/dark_knight_admin", userNameRegEx.transform("dark_knight_admin"));
        }
    }

    @Test
    public void test07_UsernamePrefix() {
        String       userNameBaseProperty = "ranger.usersync.mapping.username.regex";
        String       separator            = "#";
        RegEx        userNameRegEx        = new RegEx();
        List<String> userRegexPatterns    = Collections.singletonList("s#^(.*)#PR/$1#g");
        userNameRegEx.populateReplacementPatterns(userNameBaseProperty, userRegexPatterns, separator);
        Assertions.assertEquals("PR/mew_two", userNameRegEx.transform("mew_two"));
        Assertions.assertEquals("PR/dragoon", userNameRegEx.transform("dragoon"));
        Assertions.assertEquals("PR/pikachu", userNameRegEx.transform("pikachu"));
        Assertions.assertEquals("PR/dialga", userNameRegEx.transform("dialga"));
    }

    @Test
    public void test08_UsernameSuffix() {
        String       userNameBaseProperty = "ranger.usersync.mapping.username.regex";
        String       separator            = "#";
        RegEx        userNameRegEx        = new RegEx();
        List<String> userRegexPatterns    = Collections.singletonList("s#^(.*)#$1_ty#g");
        userNameRegEx.populateReplacementPatterns(userNameBaseProperty, userRegexPatterns, separator);
        Assertions.assertEquals("mew_ty", userNameRegEx.transform("mew"));
        Assertions.assertEquals("onix_ty", userNameRegEx.transform("onix"));
    }

    @Test
    public void test09_InitWithNullPatternsDoesNotThrow() {
        RegEx regEx = new RegEx();
        // Should be caught inside init and not throw out
        regEx.init("base", null, "/");
    }

    @Test
    public void test10_TransformWithNullInputCaughtAndReturnsNull() {
        RegEx        regEx    = new RegEx();
        List<String> patterns = new ArrayList<>();
        patterns.add("s/./x/g");
        regEx.populateReplacementPatterns("base", patterns, "/");
        Assertions.assertNull(regEx.transform(null));
    }

    @Test
    public void test11_GetReplacementPattern() {
        RegEx        regEx    = new RegEx();
        List<String> patterns = new ArrayList<>();
        patterns.add("s/a/b/");
        regEx.populateReplacementPatterns("base", patterns, "/");
        Assertions.assertNotNull(regEx.getReplacementPattern());
        Assertions.assertFalse(regEx.getReplacementPattern().isEmpty());
        Assertions.assertTrue(regEx.getReplacementPattern().containsKey("a"));
        Assertions.assertEquals("b", regEx.getReplacementPattern().get("a"));
    }

    @Test
    public void test12_PopulateReplacementPatterns_MultipleAndInvalid() {
        RegEx        regEx    = new RegEx();
        List<String> patterns = new ArrayList<>();
        patterns.add("s/\\s/_/g");
        patterns.add("s/_/-/g");
        patterns.add("this-is-not-a-valid-syntax");

        regEx.populateReplacementPatterns("base", patterns, "/");

        Assertions.assertNotNull(regEx.getReplacementPattern());
        Assertions.assertEquals(2, regEx.getReplacementPattern().size());

        List<String> keysInOrder = new ArrayList<>(regEx.getReplacementPattern().keySet());
        Assertions.assertEquals("\\s", keysInOrder.get(0));
        Assertions.assertEquals("_", keysInOrder.get(1));

        Assertions.assertEquals("_", regEx.getReplacementPattern().get("\\s"));
        Assertions.assertEquals("-", regEx.getReplacementPattern().get("_"));
    }
}
