/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.unixusersync.process;

import com.sun.jersey.api.client.ClientResponse;
import org.apache.ranger.authorization.utils.JsonUtils;
import org.apache.ranger.ugsyncutil.model.FileSyncSourceInfo;
import org.apache.ranger.ugsyncutil.model.LdapSyncSourceInfo;
import org.apache.ranger.ugsyncutil.model.UgsyncAuditInfo;
import org.apache.ranger.ugsyncutil.model.UsersGroupRoleAssignments;
import org.apache.ranger.ugsyncutil.model.XGroupInfo;
import org.apache.ranger.ugsyncutil.model.XUserInfo;
import org.apache.ranger.ugsyncutil.util.UgsyncCommonConstants;
import org.apache.ranger.unixusersync.config.UserGroupSyncConfig;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.Extension;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.ws.rs.core.Cookie;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description : Unit Test cases for PolicyMgrUserGroupBuilder
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestPolicyMgrUserGroupBuilder {
    @Test
    public void testA_userNameTransform_appliesLowerCaseAndRegex() throws Exception {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty(UgsyncCommonConstants.UGSYNC_USERNAME_CASE_CONVERSION_PARAM, UgsyncCommonConstants.UGSYNC_LOWER_CASE_CONVERSION_VALUE);
        cfg.setProperty(UgsyncCommonConstants.SYNC_MAPPING_USERNAME, "s/[=]/_/g");

        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("userNameTransform", String.class);
        m.setAccessible(true);
        String out = (String) m.invoke(builder, "User=One");
        assertEquals("user_one", out);
    }

    @Test
    public void testB_groupNameTransform_toUpper() throws Exception {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty(UgsyncCommonConstants.UGSYNC_GROUPNAME_CASE_CONVERSION_PARAM, UgsyncCommonConstants.UGSYNC_UPPER_CASE_CONVERSION_VALUE);

        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("groupNameTransform", String.class);
        m.setAccessible(true);
        String out = (String) m.invoke(builder, "groupAlpha");
        assertEquals("GROUPALPHA", out);
    }

    @Test
    public void testC_isValidString_withNameValidation() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Method enable = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("setUserSyncNameValidationEnabled", String.class);
        enable.setAccessible(true);
        enable.invoke(builder, "true");

        Method isValid = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("isValidString", String.class);
        isValid.setAccessible(true);

        assertFalse((Boolean) isValid.invoke(builder, "bad!name"));
        assertTrue((Boolean) isValid.invoke(builder, "good_name-1+/@="));
    }

    @Test
    public void testD_computeGroupUsersDelta_updatesDeltaMap() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Field groupNameMap = PolicyMgrUserGroupBuilder.class.getDeclaredField("groupNameMap");
        groupNameMap.setAccessible(true);
        Map<String, String> gnm = new HashMap<>();
        gnm.put("cn=G1", "Group1");
        groupNameMap.set(builder, gnm);

        Field userNameMap = PolicyMgrUserGroupBuilder.class.getDeclaredField("userNameMap");
        userNameMap.setAccessible(true);
        Map<String, String> unm = new HashMap<>();
        unm.put("uid=U1", "user1");
        userNameMap.set(builder, unm);

        Field groupUsersCache = PolicyMgrUserGroupBuilder.class.getDeclaredField("groupUsersCache");
        groupUsersCache.setAccessible(true);
        groupUsersCache.set(builder, new HashMap<String, Set<String>>());

        Map<String, Set<String>> src = new HashMap<>();
        src.put("cn=G1", new HashSet<>(Collections.singletonList("uid=U1")));

        Method compute = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("computeGroupUsersDelta", Map.class);
        compute.setAccessible(true);
        Object list = compute.invoke(builder, src);
        assertNotNull(list);

        Field deltaGroupUsers = PolicyMgrUserGroupBuilder.class.getDeclaredField("deltaGroupUsers");
        deltaGroupUsers.setAccessible(true);
        Map<String, Set<String>> dgu = (Map<String, Set<String>>) deltaGroupUsers.get(builder);
        assertTrue(dgu.containsKey("Group1"));
        assertTrue(dgu.get("Group1").contains("user1"));
    }

    @Test
    public void testE_computeUserDelta_marksNewUsers() throws Exception {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty(UgsyncCommonConstants.UGSYNC_USERNAME_CASE_CONVERSION_PARAM, UgsyncCommonConstants.UGSYNC_NONE_CASE_CONVERSION_VALUE);
        cfg.setProperty(UserGroupSyncConfig.UGSYNC_NAME_VALIDATION_ENABLED, "false");

        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Field userCache = PolicyMgrUserGroupBuilder.class.getDeclaredField("userCache");
        userCache.setAccessible(true);
        userCache.set(builder, new HashMap<String, Object>());

        Field userNameMap = PolicyMgrUserGroupBuilder.class.getDeclaredField("userNameMap");
        userNameMap.setAccessible(true);
        userNameMap.set(builder, new HashMap<String, String>());

        Map<String, Map<String, String>> srcUsers = new HashMap<>();
        Map<String, String>              attrs    = new HashMap<>();
        attrs.put(UgsyncCommonConstants.ORIGINAL_NAME, "UserX");
        attrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        srcUsers.put("uid=UserX,dc=example,dc=com", attrs);

        Method compute = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("computeUserDelta", Map.class);
        compute.setAccessible(true);
        compute.invoke(builder, srcUsers);

        Field deltaUsers = PolicyMgrUserGroupBuilder.class.getDeclaredField("deltaUsers");
        deltaUsers.setAccessible(true);
        Map<String, Object> du = (Map<String, Object>) deltaUsers.get(builder);
        assertTrue(du.containsKey("UserX"));
    }

    @Test
    public void testF_computeGroupDelta_marksNewGroups() throws Exception {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty(UgsyncCommonConstants.UGSYNC_GROUPNAME_CASE_CONVERSION_PARAM, UgsyncCommonConstants.UGSYNC_NONE_CASE_CONVERSION_VALUE);
        cfg.setProperty(UserGroupSyncConfig.UGSYNC_NAME_VALIDATION_ENABLED, "false");

        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Field groupCache = PolicyMgrUserGroupBuilder.class.getDeclaredField("groupCache");
        groupCache.setAccessible(true);
        groupCache.set(builder, new HashMap<String, Object>());

        Field groupNameMap = PolicyMgrUserGroupBuilder.class.getDeclaredField("groupNameMap");
        groupNameMap.setAccessible(true);
        groupNameMap.set(builder, new HashMap<String, String>());

        Map<String, Map<String, String>> srcGroups = new HashMap<>();
        Map<String, String>              gattrs    = new HashMap<>();
        gattrs.put(UgsyncCommonConstants.ORIGINAL_NAME, "GroupX");
        gattrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        srcGroups.put("cn=GroupX,dc=example,dc=com", gattrs);

        Method compute = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("computeGroupDelta", Map.class);
        compute.setAccessible(true);
        compute.invoke(builder, srcGroups);

        Field deltaGroups = PolicyMgrUserGroupBuilder.class.getDeclaredField("deltaGroups");
        deltaGroups.setAccessible(true);
        Map<String, Object> dg = (Map<String, Object>) deltaGroups.get(builder);
        assertTrue(dg.containsKey("GroupX"));
    }

    @Test
    public void testG_getRoleForUserGroups_parsesRules() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("getRoleForUserGroups", String.class, Map.class, Map.class);
        m.setAccessible(true);

        Map<String, String> userMap  = new HashMap<>();
        Map<String, String> groupMap = new HashMap<>();
        String              rules    = "ROLE_SYS_ADMIN:u:alice,bob&ROLE_KEY_ADMIN:g:group1,group2";

        m.invoke(builder, rules, userMap, groupMap);

        assertEquals("ROLE_SYS_ADMIN", userMap.get("alice"));
        assertEquals("ROLE_SYS_ADMIN", userMap.get("bob"));
        assertEquals("ROLE_KEY_ADMIN", groupMap.get("group1"));
        assertEquals("ROLE_KEY_ADMIN", groupMap.get("group2"));
    }

    @Test
    public void testI_updateUsersRoles_returnsNullOnException() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        UsersGroupRoleAssignments ug = new UsersGroupRoleAssignments();
        ug.setUsers(Collections.singletonList("user1"));
        ug.setGroupRoleAssignments(Collections.emptyMap());
        ug.setUserRoleAssignments(Collections.emptyMap());
        ug.setWhiteListGroupRoleAssignments(Collections.emptyMap());
        ug.setWhiteListUserRoleAssignments(Collections.emptyMap());
        ug.setReset(false);

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("updateUsersRoles", UsersGroupRoleAssignments.class);
        m.setAccessible(true);
        Object resp = m.invoke(builder, ug);
        assertNull(resp);
    }

    @Test
    public void testJ_tryCredMethods_returnNullOnNoClient() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        Method getCred = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("tryGetEntityWithCred", String.class, int.class);
        getCred.setAccessible(true);
        Object r1 = getCred.invoke(builder, "/api", 0);
        assertNull(r1);

        Method uploadCred = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("tryUploadEntityWithCred", Object.class, String.class);
        uploadCred.setAccessible(true);
        Object r2 = uploadCred.invoke(builder, Collections.singletonMap("k", "v"), "/api");
        assertNull(r2);
    }

    @Test
    public void testK_postUserGroupAuditInfo_setsCounts() {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        try {
            Field userCache = PolicyMgrUserGroupBuilder.class.getDeclaredField("userCache");
            userCache.setAccessible(true);
            Map<String, XUserInfo> uc = new HashMap<>();
            uc.put("u1", new XUserInfo());
            uc.put("u2", new XUserInfo());
            userCache.set(builder, uc);

            Field groupCache = PolicyMgrUserGroupBuilder.class.getDeclaredField("groupCache");
            groupCache.setAccessible(true);
            Map<String, XGroupInfo> gc = new HashMap<>();
            gc.put("g1", new XGroupInfo());
            groupCache.set(builder, gc);

            Field noOfNewUsers = PolicyMgrUserGroupBuilder.class.getDeclaredField("noOfNewUsers");
            noOfNewUsers.setAccessible(true);
            noOfNewUsers.setInt(builder, 1);

            Field noOfNewGroups = PolicyMgrUserGroupBuilder.class.getDeclaredField("noOfNewGroups");
            noOfNewGroups.setAccessible(true);
            noOfNewGroups.setInt(builder, 1);

            UgsyncAuditInfo audit = new UgsyncAuditInfo();
            audit.setSyncSource("Unix");
            // initialize sync section to avoid NPE
            audit.setUnixSyncSourceInfo(new org.apache.ranger.ugsyncutil.model.UnixSyncSourceInfo());

            builder.postUserGroupAuditInfo(audit);
            assertEquals(1L, audit.getNoOfNewUsers());
            assertEquals(1L, audit.getNoOfNewGroups());
            assertEquals(2, audit.getUnixSyncSourceInfo().getTotalUsersSynced());
            assertEquals(1, audit.getUnixSyncSourceInfo().getTotalGroupsSynced());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testL_addOrUpdateUsersGroups_createsDeltas_andPersists() throws Throwable {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        // Initialize required maps
        setPrivate(builder, "groupNameMap", new HashMap<String, String>());
        setPrivate(builder, "userNameMap", new HashMap<String, String>());
        setPrivate(builder, "groupUsersCache", new HashMap<String, Set<String>>());
        setPrivate(builder, "groupCache", new HashMap<String, XGroupInfo>());
        setPrivate(builder, "userCache", new HashMap<String, XUserInfo>());
        setPrivate(builder, "groupMap", new HashMap<String, String>());
        setPrivate(builder, "userMap", new HashMap<String, String>());

        // REST returns null â†’ expect exception path when deltas exist
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        Map<String, Map<String, String>> sourceGroups = new HashMap<>();
        Map<String, String>              gattrs       = new HashMap<>();
        gattrs.put(UgsyncCommonConstants.ORIGINAL_NAME, "GroupY");
        gattrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        sourceGroups.put("cn=GroupY,dc=example,dc=com", gattrs);

        Map<String, Map<String, String>> sourceUsers = new HashMap<>();
        Map<String, String>              uattrs      = new HashMap<>();
        uattrs.put(UgsyncCommonConstants.ORIGINAL_NAME, "UserY");
        uattrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        sourceUsers.put("uid=UserY,dc=example,dc=com", uattrs);

        Map<String, Set<String>> sourceGroupUsers = new HashMap<>();
        sourceGroupUsers.put("cn=GroupY,dc=example,dc=com", new HashSet<>(Collections.singletonList("uid=UserY,dc=example,dc=com")));

        assertThrows(Throwable.class, () -> {
            try {
                builder.addOrUpdateUsersGroups(sourceGroups, sourceUsers, sourceGroupUsers, false);
            } catch (Throwable t) {
                throw new RuntimeException(t);
            }
        });
    }

    @Test
    public void testM_buildGroupList_usesCredGet_returnsEmpty() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        setPrivate(builder, "groupCache", new HashMap<String, XGroupInfo>());

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("buildGroupList");
        m.setAccessible(true);
        assertThrows(Throwable.class, () -> {
            try {
                m.invoke(builder);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testN_buildUserList_usesCredGet_returnsEmpty() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        setPrivate(builder, "userCache", new HashMap<String, XUserInfo>());

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("buildUserList");
        m.setAccessible(true);
        assertThrows(Throwable.class, () -> {
            try {
                m.invoke(builder);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testO_tryGetEntityWithCookie_ok() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        setPrivate(builder, "sessionId", new Cookie("c", "v"));
        setPrivate(builder, "isValidRangerCookie", true);

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("tryGetEntityWithCookie", String.class, int.class);
        m.setAccessible(true);
        Object out = m.invoke(builder, "/api", 0);
        assertNull(out);
    }

    @Test
    public void testP_tryUploadEntityWithCookie_ok() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        setPrivate(builder, "sessionId", new Cookie("c", "v"));
        setPrivate(builder, "isValidRangerCookie", true);

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("tryUploadEntityWithCookie", Object.class, String.class);
        m.setAccessible(true);
        Object out = m.invoke(builder, Collections.singletonMap("a", "b"), "/api");
        assertNull(out);
    }

    @Test
    public void testQ_getUsers_returnsOne() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        org.apache.ranger.unixusersync.model.GetXUserListResponse list = new org.apache.ranger.unixusersync.model.GetXUserListResponse();
        list.setTotalCount(0);
        list.setXuserInfoList(new ArrayList<XUserInfo>());

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("getUsers", org.apache.ranger.unixusersync.model.GetXUserListResponse.class);
        m.setAccessible(true);
        Object ret = m.invoke(builder, list);
        assertEquals(0, ((Integer) ret).intValue());
    }

    @Test
    public void testR_getGroups_returnsOne() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        org.apache.ranger.unixusersync.model.GetXGroupListResponse list = new org.apache.ranger.unixusersync.model.GetXGroupListResponse();
        list.setTotalCount(0);
        list.setXgroupInfoList(new ArrayList<XGroupInfo>());

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("getGroups", org.apache.ranger.unixusersync.model.GetXGroupListResponse.class);
        m.setAccessible(true);
        Object ret = m.invoke(builder, list);
        assertEquals(0, ((Integer) ret).intValue());
    }

    @Test
    public void testS_getGroupUsers_returnsOne() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        List<org.apache.ranger.ugsyncutil.model.GroupUserInfo> list = new ArrayList<>();

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("getGroupUsers", List.class);
        m.setAccessible(true);
        Object ret = m.invoke(builder, list);
        assertEquals(0, ((Integer) ret).intValue());
    }

    @Test
    public void testT_init_throwsButStarts() {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        assertThrows(Throwable.class, builder::init);
    }

    @Test
    public void testU_computeDeletedGroups_and_getDeletedGroups_throwOnRest() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "currentSyncSource", "Unix");
        setPrivate(builder, "ldapUrl", "ldap://example");

        Map<String, XGroupInfo> gcache = new HashMap<>();
        XGroupInfo              g      = new XGroupInfo();
        g.setName("Gdel");
        Map<String, String> attrs = new HashMap<>();
        attrs.put(UgsyncCommonConstants.FULL_NAME, "cn=Gdel,dc=example,dc=com");
        attrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        attrs.put(UgsyncCommonConstants.LDAP_URL, "ldap://example");
        g.setOtherAttrsMap(attrs);
        g.setOtherAttributes(JsonUtils.objectToJson(attrs));
        g.setIsVisible("0");
        gcache.put("Gdel", g);
        setPrivate(builder, "groupCache", gcache);

        Method comp = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("computeDeletedGroups", Map.class);
        comp.setAccessible(true);
        comp.invoke(builder, new HashMap<String, Map<String, String>>());

        Map<String, XGroupInfo> deletedGroups = getPrivate(builder, "deletedGroups", Map.class);
        assertTrue(deletedGroups.containsKey("Gdel"));

        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        Method getDel = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("getDeletedGroups");
        getDel.setAccessible(true);
        assertThrows(Exception.class, () -> {
            try {
                getDel.invoke(builder);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testV_computeDeletedUsers_and_getDeletedUsers_throwOnRest() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "currentSyncSource", "Unix");
        setPrivate(builder, "ldapUrl", "ldap://example");

        Map<String, XUserInfo> ucache = new HashMap<>();
        XUserInfo              u      = new XUserInfo();
        u.setName("Udel");
        Map<String, String> attrs = new HashMap<>();
        attrs.put(UgsyncCommonConstants.FULL_NAME, "uid=Udel,dc=example,dc=com");
        attrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        attrs.put(UgsyncCommonConstants.LDAP_URL, "ldap://example");
        u.setOtherAttrsMap(attrs);
        u.setOtherAttributes(JsonUtils.objectToJson(attrs));
        u.setIsVisible("1");
        ucache.put("Udel", u);
        setPrivate(builder, "userCache", ucache);

        Method comp = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("computeDeletedUsers", Map.class);
        comp.setAccessible(true);
        comp.invoke(builder, new HashMap<String, Map<String, String>>());

        Map<String, XUserInfo> deletedUsers = getPrivate(builder, "deletedUsers", Map.class);
        assertTrue(deletedUsers.containsKey("Udel"));

        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        Method getDel = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("getDeletedUsers");
        getDel.setAccessible(true);
        assertThrows(Exception.class, () -> {
            try {
                getDel.invoke(builder);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testW_addOrUpdateDeltaUsers_throwsWithoutRest() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        Map<String, XUserInfo>    delta   = new HashMap<>();
        XUserInfo                 xu      = new XUserInfo();
        xu.setName("u1");
        xu.setOtherAttributes("{}");
        xu.setOtherAttrsMap(new HashMap<String, String>());
        delta.put("u1", xu);
        setPrivate(builder, "deltaUsers", delta);
        setPrivate(builder, "recordsToPullPerCall", "1");
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("addOrUpdateDeltaUsers");
        m.setAccessible(true);
        assertThrows(Exception.class, () -> {
            try {
                m.invoke(builder);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testX_addOrUpdateDeltaGroupUsers_throwsWithoutRest() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "recordsToPullPerCall", "1");
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        List<org.apache.ranger.ugsyncutil.model.GroupUserInfo> list = new ArrayList<>();
        org.apache.ranger.ugsyncutil.model.GroupUserInfo       gui  = new org.apache.ranger.ugsyncutil.model.GroupUserInfo();
        gui.setGroupName("g1");
        list.add(gui);
        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("addOrUpdateDeltaGroupUsers", List.class);
        m.setAccessible(true);
        assertThrows(Exception.class, () -> {
            try {
                m.invoke(builder, list);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testY_updateRoles_returnsNullWithoutRest() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        UsersGroupRoleAssignments ug = new UsersGroupRoleAssignments();
        ug.setUsers(Collections.singletonList("u1"));
        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("updateRoles", UsersGroupRoleAssignments.class);
        m.setAccessible(true);
        Object out = m.invoke(builder, ug);
        assertNull(out);
    }

    @Test
    public void testZ_buildUserGroupInfo_throwsWithoutRest() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());
        Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("buildUserGroupInfo");
        m.setAccessible(true);
        assertThrows(Throwable.class, () -> {
            try {
                m.invoke(builder);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testAA_setOtherAttributes_updatesObjects() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        Method                    m       = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("setOtherAttributes", Object.class, String.class, Map.class, String.class);
        m.setAccessible(true);
        Map<String, String> other = new HashMap<>();
        other.put("k", "v");
        String attrs = JsonUtils.objectToJson(other);

        XUserInfo u = new XUserInfo();
        u.setOtherAttrsMap(new HashMap<String, String>());
        Object ru = m.invoke(builder, u, "Unix", other, attrs);
        assertEquals("Unix", ((XUserInfo) ru).getSyncSource());
        assertEquals("v", ((XUserInfo) ru).getOtherAttrsMap().get("k"));

        XGroupInfo g = new XGroupInfo();
        g.setOtherAttrsMap(new HashMap<String, String>());
        Object rg = m.invoke(builder, g, "Unix", other, attrs);
        assertEquals("Unix", ((XGroupInfo) rg).getSyncSource());
        assertEquals("v", ((XGroupInfo) rg).getOtherAttrsMap().get("k"));
    }

    @Test
    public void testAB_updateDeletedGroups_and_Users_wrappers_throw() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "currentSyncSource", "Unix");
        setPrivate(builder, "ldapUrl", "ldap://example");

        // Prepare caches to compute deletions
        Map<String, XGroupInfo> gcache = new HashMap<>();
        XGroupInfo              g      = new XGroupInfo();
        g.setName("Gdel2");
        Map<String, String> attrsG = new HashMap<>();
        attrsG.put(UgsyncCommonConstants.FULL_NAME, "cn=Gdel2,dc=example,dc=com");
        attrsG.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        attrsG.put(UgsyncCommonConstants.LDAP_URL, "ldap://example");
        g.setOtherAttrsMap(attrsG);
        g.setOtherAttributes(JsonUtils.objectToJson(attrsG));
        g.setIsVisible("0");
        gcache.put("Gdel2", g);
        setPrivate(builder, "groupCache", gcache);

        Map<String, XUserInfo> ucache = new HashMap<>();
        XUserInfo              u      = new XUserInfo();
        u.setName("Udel2");
        Map<String, String> attrsU = new HashMap<>();
        attrsU.put(UgsyncCommonConstants.FULL_NAME, "uid=Udel2,dc=example,dc=com");
        attrsU.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        attrsU.put(UgsyncCommonConstants.LDAP_URL, "ldap://example");
        u.setOtherAttrsMap(attrsU);
        u.setOtherAttributes(JsonUtils.objectToJson(attrsU));
        u.setIsVisible("1");
        ucache.put("Udel2", u);
        setPrivate(builder, "userCache", ucache);

        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        Method upG = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("updateDeletedGroups", Map.class);
        upG.setAccessible(true);
        assertThrows(Exception.class, () -> {
            try {
                upG.invoke(builder, new HashMap<String, Map<String, String>>());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });

        Method upU = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("updateDeletedUsers", Map.class);
        upU.setAccessible(true);
        assertThrows(Exception.class, () -> {
            try {
                upU.invoke(builder, new HashMap<String, Map<String, String>>());
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }

    @Test
    public void testAC_main_invokesInit_andThrows() {
        assertThrows(Throwable.class, () -> PolicyMgrUserGroupBuilder.main(new String[] {}));
    }

    @Test
    public void testAD_init_parsesRoleRules_andWhitelistAddsSysAdmin() {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.policymgr.username", "svc");
        cfg.setProperty("ranger.usersync.policymanager.baseURL", "http://localhost");
        cfg.setProperty("ranger.usersync.group.based.role.assignment.rules", "ROLE_SYS_ADMIN:u:alice&ROLE_KEY_ADMIN:g:group1");
        cfg.setProperty("ranger.usersync.whitelist.users.role.assignment.rules", "ROLE_KEY_ADMIN:u:bob");

        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        assertThrows(Throwable.class, builder::init);

        try {
            Map<String, String> userMap           = getPrivate(builder, "userMap", Map.class);
            Map<String, String> groupMap          = getPrivate(builder, "groupMap", Map.class);
            Map<String, String> whiteListUserMap  = getPrivate(builder, "whiteListUserMap", Map.class);
            Map<String, String> whiteListGroupMap = getPrivate(builder, "whiteListGroupMap", Map.class);

            assertEquals("ROLE_SYS_ADMIN", userMap.get("alice"));
            assertEquals("ROLE_KEY_ADMIN", groupMap.get("group1"));

            assertEquals("ROLE_KEY_ADMIN", whiteListUserMap.get("bob"));
            assertEquals("ROLE_SYS_ADMIN", whiteListUserMap.get("svc"));
            assertTrue(whiteListGroupMap.isEmpty());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testAE_postUserGroupAuditInfo_setsCounts_forLdapAndFile() {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        try {
            Map<String, XUserInfo> uc = new HashMap<>();
            uc.put("u1", new XUserInfo());
            uc.put("u2", new XUserInfo());
            uc.put("u3", new XUserInfo());
            setPrivate(builder, "userCache", uc);

            Map<String, XGroupInfo> gc = new HashMap<>();
            gc.put("g1", new XGroupInfo());
            gc.put("g2", new XGroupInfo());
            setPrivate(builder, "groupCache", gc);

            // Deleted counters
            Field fDelU = PolicyMgrUserGroupBuilder.class.getDeclaredField("noOfDeletedUsers");
            fDelU.setAccessible(true);
            fDelU.setInt(builder, 5);
            Field fDelG = PolicyMgrUserGroupBuilder.class.getDeclaredField("noOfDeletedGroups");
            fDelG.setAccessible(true);
            fDelG.setInt(builder, 7);

            // LDAP/AD
            UgsyncAuditInfo ldapAudit = new UgsyncAuditInfo();
            ldapAudit.setSyncSource("LDAP/AD");
            ldapAudit.setLdapSyncSourceInfo(new LdapSyncSourceInfo());
            builder.postUserGroupAuditInfo(ldapAudit);
            assertEquals(3, ldapAudit.getLdapSyncSourceInfo().getTotalUsersSynced());
            assertEquals(2, ldapAudit.getLdapSyncSourceInfo().getTotalGroupsSynced());
            assertEquals(5, ldapAudit.getLdapSyncSourceInfo().getTotalUsersDeleted());
            assertEquals(7, ldapAudit.getLdapSyncSourceInfo().getTotalGroupsDeleted());

            // File
            UgsyncAuditInfo fileAudit = new UgsyncAuditInfo();
            fileAudit.setSyncSource("File");
            fileAudit.setFileSyncSourceInfo(new FileSyncSourceInfo());
            builder.postUserGroupAuditInfo(fileAudit);
            assertEquals(3, fileAudit.getFileSyncSourceInfo().getTotalUsersSynced());
            assertEquals(2, fileAudit.getFileSyncSourceInfo().getTotalGroupsSynced());
            assertEquals(5, fileAudit.getFileSyncSourceInfo().getTotalUsersDeleted());
            assertEquals(7, fileAudit.getFileSyncSourceInfo().getTotalGroupsDeleted());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testAF_addOrUpdateUsersGroups_computeDeletes_updatesCaches() throws Throwable {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        XGroupInfo g = new XGroupInfo();
        g.setName("G1");
        Map<String, XGroupInfo> deletedGroups = new HashMap<>();
        deletedGroups.put("G1", g);

        XUserInfo u = new XUserInfo();
        u.setName("U1");
        Map<String, XUserInfo> deletedUsers = new HashMap<>();
        deletedUsers.put("U1", u);

        setPrivate(builder, "deletedGroups", deletedGroups);
        setPrivate(builder, "deletedUsers", deletedUsers);
        setPrivate(builder, "groupCache", new HashMap<String, XGroupInfo>());
        setPrivate(builder, "userCache", new HashMap<String, XUserInfo>());
        setPrivate(builder, "isStartupFlag", false);

        assertDoesNotThrow(() -> {
            try {
                builder.addOrUpdateUsersGroups(Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), true);
            } catch (Throwable t) {
                throw new RuntimeException(t);
            }
        });

        try {
            Map<String, XGroupInfo> groupCache = getPrivate(builder, "groupCache", Map.class);
            Map<String, XUserInfo>  userCache  = getPrivate(builder, "userCache", Map.class);
            assertTrue(groupCache.containsKey("G1"));
            assertTrue(userCache.containsKey("U1"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Test
    public void testAG_addOrUpdateUsersGroups_startupCollectsUsers_andCallsUpdateRoles() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        Map<String, String> wlGroupMap = new HashMap<>();
        wlGroupMap.put("g1", "ROLE_KEY_ADMIN");
        setPrivate(builder, "whiteListGroupMap", wlGroupMap);

        Map<String, Set<String>> groupUsersCache = new HashMap<>();
        groupUsersCache.put("g1", new HashSet<>(Collections.singletonList("u1")));
        setPrivate(builder, "groupUsersCache", groupUsersCache);

        setPrivate(builder, "whiteListUserMap", new HashMap<String, String>());
        setPrivate(builder, "userMap", new HashMap<String, String>());
        setPrivate(builder, "groupMap", new HashMap<String, String>());
        setPrivate(builder, "isStartupFlag", true);

        assertThrows(Throwable.class, () -> {
            try {
                builder.addOrUpdateUsersGroups(Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), false);
            } catch (Throwable t) {
                throw new RuntimeException(t);
            }
        });
    }

    @Test
    public void testAH_cookieBasedEntity_routes_to_correct_methods() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        class TrackingRest extends FakeRest {
            boolean postWithCred;
            boolean postWithCookie;
            boolean getWithCred;
            boolean getWithCookie;

            @Override
            public ClientResponse get(String relativeUrl, Map<String, String> params) {
                getWithCred = true;
                return null;
            }

            @Override
            public ClientResponse get(String relativeUrl, Map<String, String> params, Cookie sessionId) {
                getWithCookie = true;
                return null;
            }

            @Override
            public ClientResponse post(String relativeUrl, Map<String, String> params, Object obj) {
                postWithCred = true;
                return null;
            }

            @Override
            public ClientResponse post(String relativeUrl, Map<String, String> params, Object obj, Cookie sessionId) {
                postWithCookie = true;
                return null;
            }
        }

        TrackingRest rest = new TrackingRest();
        setPrivate(builder, "ldapUgSyncClient", rest);

        // Case 1: No cookie -> use credential-based paths
        Method up = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("cookieBasedUploadEntity", Object.class, String.class);
        up.setAccessible(true);
        up.invoke(builder, Collections.singletonMap("a", "b"), "/api");
        assertTrue(rest.postWithCred);
        assertFalse(rest.postWithCookie);

        Method get = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("cookieBasedGetEntity", String.class, int.class);
        get.setAccessible(true);
        get.invoke(builder, "/api", 0);
        assertTrue(rest.getWithCred);
        assertFalse(rest.getWithCookie);

        // Case 2: Valid cookie -> use cookie-based paths
        setPrivate(builder, "sessionId", new Cookie("c", "v"));
        setPrivate(builder, "isValidRangerCookie", true);

        rest.postWithCookie = false;
        rest.postWithCred   = false;
        rest.getWithCookie  = false;
        rest.getWithCred    = false;

        up.invoke(builder, Collections.singletonMap("x", "y"), "/api2");
        assertTrue(rest.postWithCookie);
        assertFalse(rest.postWithCred);

        get.invoke(builder, "/api2", 5);
        assertTrue(rest.getWithCookie);
        assertFalse(rest.getWithCred);
    }

    @Test
    public void testAI_computeUserDelta_covers_update_branches_and_skips() throws Exception {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.policymgr.username", "svc");
        cfg.setProperty(UserGroupSyncConfig.UGSYNC_NAME_VALIDATION_ENABLED, "false");

        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();

        // Prepare caches and maps
        Map<String, XUserInfo> userCache = new HashMap<>();
        XUserInfo              svcUser   = new XUserInfo();
        svcUser.setName("svc");
        svcUser.setSyncSource("Unix");
        svcUser.setOtherAttributes("{}");
        svcUser.setOtherAttrsMap(new HashMap<String, String>());
        userCache.put("svc", svcUser);

        XUserInfo adminUser = new XUserInfo();
        adminUser.setName("admin");
        adminUser.setSyncSource("Unix");
        adminUser.setOtherAttributes("{}");
        adminUser.setOtherAttrsMap(new HashMap<String, String>());
        userCache.put("admin", adminUser);

        XUserInfo normalUser = new XUserInfo();
        normalUser.setName("user1");
        normalUser.setSyncSource("Unix");
        Map<String, String> normAttrs = new HashMap<>();
        normAttrs.put(UgsyncCommonConstants.FULL_NAME, "uid=user1,dc=example,dc=com");
        normAttrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        normalUser.setOtherAttrsMap(normAttrs);
        normalUser.setOtherAttributes(JsonUtils.objectToJson(normAttrs));
        userCache.put("user1", normalUser);

        // User with different DN to trigger skip update branch
        XUserInfo collideUser = new XUserInfo();
        collideUser.setName("user2");
        collideUser.setSyncSource("Unix");
        Map<String, String> colAttrs = new HashMap<>();
        colAttrs.put(UgsyncCommonConstants.FULL_NAME, "uid=user2,dc=example,dc=com");
        colAttrs.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        collideUser.setOtherAttrsMap(colAttrs);
        collideUser.setOtherAttributes(JsonUtils.objectToJson(colAttrs));
        userCache.put("user2", collideUser);

        // Map fields
        setPrivate(builder, "userCache", userCache);
        setPrivate(builder, "userNameMap", new HashMap<String, String>());
        setPrivate(builder, "policyMgrUserName", "svc");

        // Case 1: startup true, sync-source validation disabled, and different sync source -> update path
        setPrivate(builder, "isStartupFlag", true);
        setPrivate(builder, "isSyncSourceValidationEnabled", false);

        Map<String, Map<String, String>> src1   = new HashMap<>();
        Map<String, String>              attrs1 = new HashMap<>();
        attrs1.put(UgsyncCommonConstants.ORIGINAL_NAME, "user1");
        attrs1.put(UgsyncCommonConstants.SYNC_SOURCE, "LDAP/AD");
        attrs1.put(UgsyncCommonConstants.FULL_NAME, "uid=user1,dc=example,dc=com");
        src1.put("uid=user1,dc=example,dc=com", attrs1);

        Method compute = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("computeUserDelta", Map.class);
        compute.setAccessible(true);
        compute.invoke(builder, src1);

        Map<String, XUserInfo> deltaUsers = getPrivate(builder, "deltaUsers", Map.class);
        assertTrue(deltaUsers.containsKey("user1"));

        // Case 2: DN mismatch skip branch, but identical otherAttributes -> mapping updated
        setPrivate(builder, "isStartupFlag", false);
        Map<String, Map<String, String>> src2   = new HashMap<>();
        Map<String, String>              attrs2 = new HashMap<>();
        attrs2.put(UgsyncCommonConstants.ORIGINAL_NAME, "user2");
        attrs2.put(UgsyncCommonConstants.SYNC_SOURCE, "Unix");
        // Keep FULL_NAME same as current to ensure otherAttributes string equality
        attrs2.put(UgsyncCommonConstants.FULL_NAME, "uid=user2,dc=example,dc=com");
        // Use a different entry key (DN) to trigger DN mismatch path
        src2.put("uid=user2-new,dc=example,dc=com", attrs2);

        compute.invoke(builder, src2);
        Map<String, String> userNameMap = getPrivate(builder, "userNameMap", Map.class);

        // Case 3: attribute update when sync source same but other attributes differ -> update path increments modified users
        Map<String, Map<String, String>> src3   = new HashMap<>();
        Map<String, String>              attrs3 = new HashMap<>(normAttrs);
        attrs3.put(UgsyncCommonConstants.ORIGINAL_NAME, "user1");
        attrs3.put("extra", "v");
        src3.put("uid=user1,dc=example,dc=com", attrs3);
        compute.invoke(builder, src3);
        deltaUsers = getPrivate(builder, "deltaUsers", Map.class);

        // Case 4: skip updates for admin and svc
        Map<String, Map<String, String>> src4 = new HashMap<>();
        Map<String, String>              a1   = new HashMap<>();
        a1.put(UgsyncCommonConstants.ORIGINAL_NAME, "admin");
        a1.put(UgsyncCommonConstants.SYNC_SOURCE, "LDAP/AD");
        a1.put(UgsyncCommonConstants.FULL_NAME, "uid=admin,dc=example,dc=com");
        src4.put("uid=admin,dc=example,dc=com", a1);
        Map<String, String> a2 = new HashMap<>();
        a2.put(UgsyncCommonConstants.ORIGINAL_NAME, "svc");
        a2.put(UgsyncCommonConstants.SYNC_SOURCE, "LDAP/AD");
        a2.put(UgsyncCommonConstants.FULL_NAME, "uid=svc,dc=example,dc=com");
        src4.put("uid=svc,dc=example,dc=com", a2);
        compute.invoke(builder, src4);
        deltaUsers = getPrivate(builder, "deltaUsers", Map.class);
        assertFalse(deltaUsers.containsKey("admin"));
        assertFalse(deltaUsers.containsKey("svc"));

        // Case 5: no-change path ensures userNameMap updated when attributes equal
        Map<String, Map<String, String>> src5   = new HashMap<>();
        Map<String, String>              attrs5 = new HashMap<>(normAttrs);
        attrs5.put(UgsyncCommonConstants.ORIGINAL_NAME, "user1");
        src5.put("uid=user1,dc=example,dc=com", attrs5);
        compute.invoke(builder, src5);
        userNameMap = getPrivate(builder, "userNameMap", Map.class);
        assertEquals("user1", userNameMap.get("uid=user1,dc=example,dc=com"));
    }

    @Test
    public void testAJ_buildUserGroupInfo_kerberos_doAs_failure_throws() throws Exception {
        PolicyMgrUserGroupBuilder builder = new PolicyMgrUserGroupBuilder();
        // Force kerberos branch and set principal/keytab
        setPrivate(builder, "authenticationType", "kerberos");
        setPrivate(builder, "principal", "svc/_HOST@EXAMPLE.COM");
        setPrivate(builder, "keytab", "/tmp/svc.keytab");
        setPrivate(builder, "nameRules", "DEFAULT");
        // Cause inner build* calls to fail in doAs, so lambda returns false
        setPrivate(builder, "ldapUgSyncClient", new FakeRest());

        try (org.mockito.MockedStatic<org.apache.hadoop.security.SecureClientLogin> mocked = org.mockito.Mockito.mockStatic(org.apache.hadoop.security.SecureClientLogin.class)) {
            mocked.when(() -> org.apache.hadoop.security.SecureClientLogin.isKerberosCredentialExists("svc/_HOST@EXAMPLE.COM", "/tmp/svc.keytab")).thenReturn(true);
            mocked.when(() -> org.apache.hadoop.security.SecureClientLogin.loginUserFromKeytab("svc/_HOST@EXAMPLE.COM", "/tmp/svc.keytab", "DEFAULT")).thenReturn(new javax.security.auth.Subject());

            Method m = PolicyMgrUserGroupBuilder.class.getDeclaredMethod("buildUserGroupInfo");
            m.setAccessible(true);
            assertThrows(Exception.class, () -> {
                try {
                    m.invoke(builder);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            });
        }
    }

    // Helpers
    @SuppressWarnings("unchecked")
    private static <T> T getPrivate(Object target, String field, Class<T> type) throws Exception {
        Field f = target.getClass().getDeclaredField(field);
        f.setAccessible(true);
        return (T) f.get(target);
    }

    private static void setPrivate(Object target, String field, Object value) throws Exception {
        Field f = target.getClass().getDeclaredField(field);
        f.setAccessible(true);
        f.set(target, value);
    }

    public static class MockitoExtension implements Extension {}

    private static class FakeRest extends RangerUgSyncRESTClient {
        FakeRest() {
            super("http://localhost", "", "", "", "", "", "", "", "", "", "", "");
        }

        @Override
        public ClientResponse get(String relativeUrl, Map<String, String> params) {
            return null;
        }

        @Override
        public ClientResponse get(String relativeUrl, Map<String, String> params, Cookie sessionId) {
            return null;
        }

        @Override
        public ClientResponse post(String relativeUrl, Map<String, String> params, Object obj) {
            return null;
        }

        @Override
        public ClientResponse post(String relativeUrl, Map<String, String> params, Object obj, Cookie sessionId) {
            return null;
        }
    }
}
