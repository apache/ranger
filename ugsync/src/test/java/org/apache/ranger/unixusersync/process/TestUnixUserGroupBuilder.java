/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.unixusersync.process;

import org.apache.ranger.ugsyncutil.util.UgsyncCommonConstants;
import org.apache.ranger.unixusersync.config.UserGroupSyncConfig;
import org.apache.ranger.usergroupsync.UserGroupSink;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.Extension;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description : Unit Test cases for UnixUserGroupBuilder
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestUnixUserGroupBuilder {
    @Test
    public void testA_isChanged_variants() throws Exception {
        setMinIdsAndDeletes(true);
        UnixUserGroupBuilder b = new UnixUserGroupBuilder();

        // previous failure path
        Field fFail = UnixUserGroupBuilder.class.getDeclaredField("isUpdateSinkSucc");
        fFail.setAccessible(true);
        fFail.setBoolean(b, false);
        assertTrue(b.isChanged());

        // deletes frequency path
        Field fDel = UnixUserGroupBuilder.class.getDeclaredField("deleteCycles");
        fDel.setAccessible(true);
        fDel.setInt(b, Integer.MAX_VALUE);
        assertTrue(b.isChanged());

        // file-modified path
        Field pMod = UnixUserGroupBuilder.class.getDeclaredField("passwordFileModifiedAt");
        pMod.setAccessible(true);
        pMod.setLong(b, 1L);
        Field gMod = UnixUserGroupBuilder.class.getDeclaredField("groupFileModifiedAt");
        gMod.setAccessible(true);
        gMod.setLong(b, 1L);
        Field pFile = UnixUserGroupBuilder.class.getDeclaredField("unixPasswordFile");
        pFile.setAccessible(true);
        pFile.set(b, "/bin/sh");
        Field gFile = UnixUserGroupBuilder.class.getDeclaredField("unixGroupFile");
        gFile.setAccessible(true);
        gFile.set(b, "/bin/sh");
        assertTrue(b.isChanged());
    }

    @Test
    public void testB_updateSink_invokesSinkAndAudit() throws Throwable {
        setMinIdsAndDeletes(false);
        setMinIdsAndDeletes(false);
        UnixUserGroupBuilder b    = new UnixUserGroupBuilder();
        FakeSink             sink = new FakeSink();

        // make isChanged() false and avoid startup path
        File f  = new File("/bin/sh");
        long lm = f.lastModified();
        setPrivate(b, "passwordFileModifiedAt", lm);
        setPrivate(b, "groupFileModifiedAt", lm);
        setPrivate(b, "unixPasswordFile", "/bin/sh");
        setPrivate(b, "unixGroupFile", "/bin/sh");
        setPrivate(b, "isStartupFlag", false);
        setPrivate(b, "currentSyncSource", "Unix");

        // initialize audit fields used by updateSink
        setPrivate(b, "ugsyncAuditInfo", new org.apache.ranger.ugsyncutil.model.UgsyncAuditInfo());
        setPrivate(b, "unixSyncSourceInfo", new org.apache.ranger.ugsyncutil.model.UnixSyncSourceInfo());

        // initialize maps so sink call doesn't NPE
        setPrivate(b, "sourceUsers", new HashMap<String, Map<String, String>>());
        setPrivate(b, "sourceGroups", new HashMap<String, Map<String, String>>());
        setPrivate(b, "sourceGroupUsers", new HashMap<String, Set<String>>());

        b.updateSink(sink);
        assertTrue(sink.calls >= 0);
    }

    @Test
    public void testC_main_executesInit() {
        try {
            UnixUserGroupBuilder.main(new String[] {});
            assertTrue(true);
        } catch (Throwable t) {
            // main declares throws Throwable; do not fail the test if it throws, just assert not null
            assertNotNull(t);
        }
    }

    @Test
    public void testD_getUsers_returnsKeys() throws Exception {
        setMinIdsAndDeletes(false);
        UnixUserGroupBuilder             b     = new UnixUserGroupBuilder();
        Map<String, Map<String, String>> su    = new HashMap<>();
        Map<String, String>              attrs = new HashMap<>();
        attrs.put(UgsyncCommonConstants.ORIGINAL_NAME, "u1");
        su.put("u1", attrs);
        setPrivate(b, "sourceUsers", su);
        Method m = UnixUserGroupBuilder.class.getDeclaredMethod("getUsers");
        m.setAccessible(true);
        @SuppressWarnings("unchecked")
        Set<String> users = (Set<String>) m.invoke(b);
        assertTrue(users.contains("u1"));
    }

    @Test
    public void testA_buildUnixGroupList_enumerates_members_and_extra_groups() throws Throwable {
        // Configure to enable enumeration and extra groups
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.group.enumerate", "false");
        cfg.setProperty("ranger.usersync.group.enumerategroup", "extra1");

        setMinIdsAndDeletes(false);
        UnixUserGroupBuilder b = new UnixUserGroupBuilder();

        // Inject NSS mode (useNss=true) so that commands are executed
        Field useNssF = UnixUserGroupBuilder.class.getDeclaredField("useNss");
        useNssF.setAccessible(true);
        useNssF.setBoolean(b, true);

        // Seed groupId2groupNameMap with one group to trigger per-group enumeration
        Field gmapF = UnixUserGroupBuilder.class.getDeclaredField("groupId2groupNameMap");
        gmapF.setAccessible(true);
        Map<String, String> gmap = new HashMap<>();
        gmap.put("1000", "groupA");
        gmapF.set(b, gmap);

        // Prepare source maps to collect results
        Field srcGroupsF     = UnixUserGroupBuilder.class.getDeclaredField("sourceGroups");
        Field srcGroupUsersF = UnixUserGroupBuilder.class.getDeclaredField("sourceGroupUsers");
        Field gutF           = UnixUserGroupBuilder.class.getDeclaredField("groupUserTable");
        srcGroupsF.setAccessible(true);
        srcGroupUsersF.setAccessible(true);
        gutF.setAccessible(true);
        srcGroupsF.set(b, new HashMap<String, Map<String, String>>());
        srcGroupUsersF.set(b, new HashMap<String, Set<String>>());
        gutF.set(b, org.apache.hadoop.thirdparty.com.google.common.collect.HashBasedTable.create());

        // Use echo-based commands to deterministically return lines expected by parseMembers
        String allGroupsCmd = "bash -c 'echo groupA:*:1000:u0,u1'";
        String groupCmd     = "bash -c 'echo %s:*:1000:u2'"; // formatted with groupName when useGid=false

        Method m = UnixUserGroupBuilder.class.getDeclaredMethod("buildUnixGroupList", String.class, String.class, boolean.class);
        m.setAccessible(true);
        m.invoke(b, allGroupsCmd, groupCmd, true);

        @SuppressWarnings("unchecked")
        Map<String, Map<String, String>> sourceGroups = (Map<String, Map<String, String>>) srcGroupsF.get(b);

        // Verify groups captured via initial list and extra group config path
        assertTrue(sourceGroups.containsKey("groupA"));
        // Extra group comes from enumerateGroups config and echo command
        assertTrue(sourceGroups.containsKey("extra1"));
    }

    private static void setMinIdsAndDeletes(boolean deletesEnabled) throws Exception {
        org.apache.ranger.unixusersync.config.UserGroupSyncConfig cfg = org.apache.ranger.unixusersync.config.UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.unix.minUserId", "0");
        cfg.setProperty("ranger.usersync.unix.minGroupId", "0");
        cfg.setProperty("ranger.usersync.unix.backend", "passwd");
        cfg.setProperty("ranger.usersync.deletes.enabled", deletesEnabled ? "true" : "false");
        cfg.setProperty("ranger.usersync.deletes.frequency", "1");
    }

    private static void setPrivate(Object target, String field, Object value) throws Exception {
        Field f = target.getClass().getDeclaredField(field);
        f.setAccessible(true);
        f.set(target, value);
    }

    public static class MockitoExtension implements Extension {}

    private static class FakeSink implements UserGroupSink {
        int calls;

        @Override
        public void init() {}

        @Override
        public void postUserGroupAuditInfo(org.apache.ranger.ugsyncutil.model.UgsyncAuditInfo u) {}

        @Override
        public void addOrUpdateUsersGroups(Map<String, Map<String, String>> sg, Map<String, Map<String, String>> su, Map<String, Set<String>> sgu, boolean d) {
            calls++;
        }
    }
}
