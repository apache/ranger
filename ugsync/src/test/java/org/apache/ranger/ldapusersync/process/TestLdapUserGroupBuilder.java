/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.ldapusersync.process;

import org.apache.directory.server.annotations.CreateLdapConnectionPool;
import org.apache.directory.server.core.annotations.ApplyLdifFiles;
import org.apache.directory.server.core.annotations.ContextEntry;
import org.apache.directory.server.core.annotations.CreateDS;
import org.apache.directory.server.core.annotations.CreateIndex;
import org.apache.directory.server.core.annotations.CreatePartition;
import org.apache.directory.server.core.integ.AbstractLdapTestUnit;
import org.apache.hadoop.thirdparty.com.google.common.collect.HashBasedTable;
import org.apache.hadoop.thirdparty.com.google.common.collect.Table;
import org.apache.ranger.ugsyncutil.model.UgsyncAuditInfo;
import org.apache.ranger.unixusersync.config.UserGroupSyncConfig;
import org.apache.ranger.usergroupsync.UserGroupSink;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedConstruction;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.naming.NamingEnumeration;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.BasicAttribute;
import javax.naming.directory.BasicAttributes;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.naming.ldap.InitialLdapContext;
import javax.naming.ldap.LdapContext;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description : Unit Test cases for LdapUserGroupBuilder
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
@CreateDS(name = "dsUGB", partitions = {
        @CreatePartition(
                name = "AD", suffix = "DC=ranger,DC=qe,DC=hortonworks,DC=com",
                contextEntry = @ContextEntry(entryLdif = "dn: DC=ranger,DC=qe,DC=hortonworks,DC=com\nobjectClass: domain\nobjectClass: top\ndc: example\n\n"),
                indexes = {
                        @CreateIndex(attribute = "objectClass"),
                        @CreateIndex(attribute = "dc"),
                        @CreateIndex(attribute = "ou")
                })})
@CreateLdapConnectionPool(maxActive = 1, maxWait = 5000)
@ApplyLdifFiles("ADSchema.ldif")
public class TestLdapUserGroupBuilder extends AbstractLdapTestUnit {
    @Test
    public void testA_init_and_isChanged() throws Exception {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        assertDoesNotThrow(b::init);
        assertTrue(b.isChanged());
    }

    @Test
    public void testB_createLdapContext_and_close() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Method create = LdapUserGroupBuilder.class.getDeclaredMethod("createLdapContext");
        create.setAccessible(true);
        assertThrows(Throwable.class, () -> create.invoke(b));
    }

    @Test
    public void testC_setConfig_configures_search_controls() throws Exception {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();

        Method setCfg = LdapUserGroupBuilder.class.getDeclaredMethod("setConfig");
        setCfg.setAccessible(true);
        assertDoesNotThrow(() -> setCfg.invoke(b));

        Field uscF = LdapUserGroupBuilder.class.getDeclaredField("userSearchControls");
        Field gscF = LdapUserGroupBuilder.class.getDeclaredField("groupSearchControls");
        Field usbF = LdapUserGroupBuilder.class.getDeclaredField("userSearchBase");
        Field gsbF = LdapUserGroupBuilder.class.getDeclaredField("groupSearchBase");
        uscF.setAccessible(true);
        gscF.setAccessible(true);
        usbF.setAccessible(true);
        gsbF.setAccessible(true);
        assertNotNull(uscF.get(b));
        assertNotNull(gscF.get(b));
        assertTrue(((String[]) usbF.get(b)).length > 0);
        assertTrue(((String[]) gsbF.get(b)).length > 0);
    }

    @Test
    public void testD_getFirstRDN_and_getShortName() throws Exception {
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();

        Method firstRdn = LdapUserGroupBuilder.class.getDeclaredMethod("getFirstRDN", String.class);
        firstRdn.setAccessible(true);
        assertEquals("cn=admins", firstRdn.invoke(b, "cn=admins,ou=groups,dc=example,dc=com"));
        assertEquals("", firstRdn.invoke(b, "uid=user1,ou=people,dc=example,dc=com"));
        assertEquals("", firstRdn.invoke(b, "invalid, string"));

        Method shortName = LdapUserGroupBuilder.class.getDeclaredMethod("getShortName", String.class);
        shortName.setAccessible(true);
        assertEquals("user1", shortName.invoke(null, "uid=user1,ou=people,dc=example,dc=com"));
        assertEquals("admins", shortName.invoke(null, "cn=admins,ou=groups,dc=example,dc=com"));
        assertNull(shortName.invoke(null, new Object[] {null}));
    }

    @Test
    public void testE_addToAttrMap_supports_string_and_bytes() throws Exception {
        LdapUserGroupBuilder b            = new LdapUserGroupBuilder();
        Method               addToAttrMap = LdapUserGroupBuilder.class.getDeclaredMethod("addToAttrMap", Map.class, String.class, Attribute.class, String.class);
        addToAttrMap.setAccessible(true);

        Map<String, String> map = new HashMap<>();
        Attribute           a1  = new BasicAttribute("cloud_id", new byte[] {1, 2, 3});
        addToAttrMap.invoke(b, map, "cloud_id", a1, "byte[]");
        assertTrue(map.containsKey("cloud_id"));

        Attribute a2 = new BasicAttribute("displayname", "Team A");
        addToAttrMap.invoke(b, map, "displayname", a2, "String");
        assertEquals("Team A", map.get("displayname"));
    }

    @Test
    public void testF_getUsers_throws_without_ldap() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Method getUsers = LdapUserGroupBuilder.class.getDeclaredMethod("getUsers", boolean.class);
        getUsers.setAccessible(true);
        assertThrows(Throwable.class, () -> getUsers.invoke(b, false));
    }

    @Test
    public void testG_getGroups_throws_without_ldap() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Method getGroups = LdapUserGroupBuilder.class.getDeclaredMethod("getGroups", boolean.class);
        getGroups.setAccessible(true);
        assertThrows(Throwable.class, () -> getGroups.invoke(b, false));
    }

    @Test
    public void testH_updateSink_invokes_sink_methods_without_searches() throws Throwable {
        LdapUserGroupBuilder b      = new LdapUserGroupBuilder();
        Field                fUser  = LdapUserGroupBuilder.class.getDeclaredField("userSearchEnabled");
        Field                fGroup = LdapUserGroupBuilder.class.getDeclaredField("groupSearchEnabled");
        fUser.setAccessible(true);
        fGroup.setAccessible(true);
        fUser.setBoolean(b, false);
        fGroup.setBoolean(b, false);

        RecordingSink sink = new RecordingSink();
    }

    @Test
    public void testI_goUpGroupHierarchy_propagates_members() throws Exception {
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();

        Field gutF = LdapUserGroupBuilder.class.getDeclaredField("groupUserTable");
        gutF.setAccessible(true);
        @SuppressWarnings("unchecked")
        Table<String, String, String> gut = HashBasedTable.create();
        gutF.set(b, gut);

        String parent    = "cn=parent,dc=example,dc=com";
        String child     = "cn=child,dc=example,dc=com";
        String user1Full = "uid=user1,ou=people,dc=example,dc=com";

        gut.put(parent, user1Full, "user1");
        gut.put(child, "uid=user2,ou=people,dc=example,dc=com", "user2");

        Set<String> nextLevel = new HashSet<>();
        nextLevel.add(child);

        Method goUp = LdapUserGroupBuilder.class.getDeclaredMethod("goUpGroupHierarchy", Set.class, int.class, String.class);
        goUp.setAccessible(true);
        goUp.invoke(b, nextLevel, 1, parent);

        assertTrue(gut.contains(parent, user1Full));
        assertTrue(gut.contains(child, user1Full));
    }

    @Test
    public void testJ_goUpGroupHierarchyLdap_early_return() throws Throwable {
        LdapUserGroupBuilder b        = new LdapUserGroupBuilder();
        Set<String>          empty    = Collections.emptySet();
        Method               goUpLdap = LdapUserGroupBuilder.class.getDeclaredMethod("goUpGroupHierarchyLdap", Set.class, int.class);
        goUpLdap.setAccessible(true);
        assertDoesNotThrow(() -> goUpLdap.invoke(b, empty, 1));
    }

    @Test
    public void testK_getDNForMemberOf_throws_without_ldap() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Method getDN = LdapUserGroupBuilder.class.getDeclaredMethod("getDNForMemberOf", String.class);
        getDN.setAccessible(true);
        assertThrows(Throwable.class, () -> getDN.invoke(b, "cn=admins,ou=groups,dc=example,dc=com"));
    }

    @Test
    public void testL_main_runs() throws Exception {
        resetConfig();
        configureMinimalLdapConfig();
        assertDoesNotThrow(() -> LdapUserGroupBuilder.main(new String[] {}));
    }

    @Test
    public void testM_closeLdapContext_closes_context_only() throws Exception {
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();

        final boolean[] ctxClosed = new boolean[] {false};

        LdapContext ctx = (LdapContext) Proxy.newProxyInstance(LdapContext.class.getClassLoader(), new Class[] {LdapContext.class}, (proxy, method, args) -> {
            if ("close".equals(method.getName())) {
                ctxClosed[0] = true;
                return null;
            }
            return null;
        });

        Field ctxF = LdapUserGroupBuilder.class.getDeclaredField("ldapContext");
        ctxF.setAccessible(true);
        ctxF.set(b, ctx);

        Method close = LdapUserGroupBuilder.class.getDeclaredMethod("closeLdapContext");
        close.setAccessible(true);
        assertDoesNotThrow(() -> close.invoke(b));

        assertTrue(ctxClosed[0]);
    }

    @Test
    public void testN_updateSink_invokes_sink_and_audit_with_computeDeletes() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.policymanager.testrun", "true");
        cfg.setProperty("ranger.usersync.deletes.enabled", "true");
        cfg.setProperty("ranger.usersync.deletes.frequency", "1");

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Field fUser  = LdapUserGroupBuilder.class.getDeclaredField("userSearchEnabled");
        Field fGroup = LdapUserGroupBuilder.class.getDeclaredField("groupSearchEnabled");
        Field fDel   = LdapUserGroupBuilder.class.getDeclaredField("deleteCycles");
        fUser.setAccessible(true);
        fGroup.setAccessible(true);
        fDel.setAccessible(true);
        fUser.setBoolean(b, false);
        fGroup.setBoolean(b, false);
        fDel.setInt(b, 1); // match frequency to trigger computeDeletes

        CapturingSink sink = new CapturingSink();
        b.updateSink(sink);

        assertTrue(sink.addOrUpdateCalled);
        assertTrue(sink.auditCalled);
        assertTrue(sink.computeDeletesFlag);
    }

    @Test
    public void testO_goUpGroupHierarchyLdap_guard_with_zero_levels() throws Throwable {
        LdapUserGroupBuilder b    = new LdapUserGroupBuilder();
        Set<String>          some = new HashSet<>();
        some.add("cn=child,ou=groups,dc=example,dc=com");
        Method goUpLdap = LdapUserGroupBuilder.class.getDeclaredMethod("goUpGroupHierarchyLdap", Set.class, int.class);
        goUpLdap.setAccessible(true);
        assertDoesNotThrow(() -> goUpLdap.invoke(b, some, 0));
    }

    @Test
    public void testP_getUsers_throws_with_computeDeletes_true() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();
        Method getUsers = LdapUserGroupBuilder.class.getDeclaredMethod("getUsers", boolean.class);
        getUsers.setAccessible(true);
        assertThrows(Throwable.class, () -> getUsers.invoke(b, true));
    }

    @Test
    public void testQ_getGroups_throws_with_computeDeletes_true() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();
        Method getGroups = LdapUserGroupBuilder.class.getDeclaredMethod("getGroups", boolean.class);
        getGroups.setAccessible(true);
        assertThrows(Throwable.class, () -> getGroups.invoke(b, true));
    }

    @Test
    public void testR_getDNForMemberOf_throws_with_various_filters() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();
        Method getDN = LdapUserGroupBuilder.class.getDeclaredMethod("getDNForMemberOf", String.class);
        getDN.setAccessible(true);
        assertThrows(Throwable.class, () -> getDN.invoke(b, "cn=Group*"));
        assertThrows(Throwable.class, () -> getDN.invoke(b, "(cn=Group*)"));
    }

    @Test
    public void testS_goUpGroupHierarchyLdap_guard_with_negative_levels() throws Throwable {
        LdapUserGroupBuilder b    = new LdapUserGroupBuilder();
        Set<String>          some = new HashSet<>();
        some.add("cn=child,ou=groups,dc=example,dc=com");
        Method goUpLdap = LdapUserGroupBuilder.class.getDeclaredMethod("goUpGroupHierarchyLdap", Set.class, int.class);
        goUpLdap.setAccessible(true);
        assertDoesNotThrow(() -> goUpLdap.invoke(b, some, -1));
    }

    @Test
    public void testT_group_config_fields_reflect_properties() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.ldap.group.objectclass", "groupOfNames");
        cfg.setProperty("ranger.usersync.ldap.group.searchfilter", "(cn=*)");

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Field gObj = LdapUserGroupBuilder.class.getDeclaredField("groupObjectClass");
        Field gFil = LdapUserGroupBuilder.class.getDeclaredField("groupSearchFilter");
        Field gSc  = LdapUserGroupBuilder.class.getDeclaredField("groupSearchControls");
        gObj.setAccessible(true);
        gFil.setAccessible(true);
        gSc.setAccessible(true);

        assertEquals("groupOfNames", gObj.get(b));
        assertEquals("cn=*", gFil.get(b));
        assertNotNull(gSc.get(b));
    }

    @Test
    public void testU_user_config_fields_reflect_properties_and_timestamps_initialized() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.ldap.user.nameattribute", "uid");
        cfg.setProperty("ranger.usersync.ldap.user.searchfilter", "(uid=*)");

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        Field uName = LdapUserGroupBuilder.class.getDeclaredField("userNameAttribute");
        Field uFil  = LdapUserGroupBuilder.class.getDeclaredField("userSearchFilter");
        Field ts    = LdapUserGroupBuilder.class.getDeclaredField("deltaSyncUserTimeStamp");
        uName.setAccessible(true);
        uFil.setAccessible(true);
        ts.setAccessible(true);

        assertEquals("uid", uName.get(b));
        assertEquals("(uid=*)", uFil.get(b));
        assertTrue(((String) ts.get(b)).startsWith("1970"));
    }

    @Test
    public void testV_getUsers_processes_user_and_group_memberships() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.ldap.user.searchfilter", "cn=User*");

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        // Disable group search so user memberof is used
        Field fGroupEnabled = LdapUserGroupBuilder.class.getDeclaredField("groupSearchEnabled");
        fGroupEnabled.setAccessible(true);
        fGroupEnabled.setBoolean(b, false);

        // Prepare internal tables/maps used by getUsers
        Field gutF       = LdapUserGroupBuilder.class.getDeclaredField("groupUserTable");
        Field srcUsersF  = LdapUserGroupBuilder.class.getDeclaredField("sourceUsers");
        Field srcGroupsF = LdapUserGroupBuilder.class.getDeclaredField("sourceGroups");
        gutF.setAccessible(true);
        srcUsersF.setAccessible(true);
        srcGroupsF.setAccessible(true);
        gutF.set(b, HashBasedTable.create());
        srcUsersF.set(b, new HashMap<>());
        srcGroupsF.set(b, new HashMap<>());

        // Build a single SearchResult with required attributes
        final String userDn  = "cn=User1000,ou=people,dc=example,dc=com";
        final String groupDn = "CN=Group10,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";

        Attributes attrs = new BasicAttributes(true);
        attrs.put(new BasicAttribute("cn", "User1000"));
        attrs.put(new BasicAttribute("uSNChanged", "2001"));
        attrs.put(new BasicAttribute("memberof", groupDn));

        class TestSearchResult extends SearchResult {
            private final String nameInNs;

            TestSearchResult(String name, Attributes a, String nameInNs) {
                super(name, null, a);
                this.nameInNs = nameInNs;
            }

            @Override
            public String getNameInNamespace() {
                return nameInNs;
            }
        }

        final SearchResult sr = new TestSearchResult(userDn, attrs, userDn);

        class SingleEnum implements NamingEnumeration<SearchResult> {
            private boolean consumed;

            @Override
            public SearchResult next() {
                consumed = true;
                return sr;
            }

            @Override
            public boolean hasMore() {
                return !consumed;
            }

            @Override
            public void close() {}

            @Override
            public boolean hasMoreElements() {
                return hasMore();
            }

            @Override
            public SearchResult nextElement() {
                return next();
            }
        }

        try (MockedConstruction<InitialLdapContext> mocked = Mockito.mockConstruction(InitialLdapContext.class, (mock, ctx) -> {
            Mockito.when(mock.search(Mockito.anyString(), Mockito.anyString(), Mockito.any(SearchControls.class)))
                    .thenReturn(new SingleEnum());
            Mockito.when(mock.getResponseControls()).thenReturn(null);
        })) {
            Method getUsers = LdapUserGroupBuilder.class.getDeclaredMethod("getUsers", boolean.class);
            getUsers.setAccessible(true);
            Object ret = getUsers.invoke(b, false);

            // Assert highest delta updated from uSNChanged
            assertEquals(2001L, ((Number) ret).longValue());

            // Verify extended filter includes custom filter and base
            Field extFilF = LdapUserGroupBuilder.class.getDeclaredField("extendedUserSearchFilter");
            extFilF.setAccessible(true);
            String ext = (String) extFilF.get(b);
            assertTrue(ext.contains("(objectclass="));
            assertTrue(ext.contains("(cn=User*)"));

            @SuppressWarnings("unchecked")
            Table<String, String, String> gut = (Table<String, String, String>) gutF.get(b);
            assertTrue(gut.rowKeySet().contains(groupDn));
            assertTrue(gut.contains(groupDn, userDn));

            @SuppressWarnings("unchecked")
            Map<String, Map<String, String>> srcUsers = (Map<String, Map<String, String>>) srcUsersF.get(b);
            assertTrue(srcUsers.containsKey(userDn));
        }
    }

    @Test
    public void testW_getGroups_processes_groups_and_memberships() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.ldap.group.searchfilter", "cn=Group*");

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        // Disable user search so members are added to sourceUsers directly
        Field fUserEnabled = LdapUserGroupBuilder.class.getDeclaredField("userSearchEnabled");
        fUserEnabled.setAccessible(true);
        fUserEnabled.setBoolean(b, false);

        // Prepare internal structures used by getGroups
        Field gutF           = LdapUserGroupBuilder.class.getDeclaredField("groupUserTable");
        Field srcUsersF      = LdapUserGroupBuilder.class.getDeclaredField("sourceUsers");
        Field srcGroupsF     = LdapUserGroupBuilder.class.getDeclaredField("sourceGroups");
        Field srcGroupUsersF = LdapUserGroupBuilder.class.getDeclaredField("sourceGroupUsers");
        gutF.setAccessible(true);
        srcUsersF.setAccessible(true);
        srcGroupsF.setAccessible(true);
        srcGroupUsersF.setAccessible(true);
        gutF.set(b, HashBasedTable.create());
        srcUsersF.set(b, new HashMap<>());
        srcGroupsF.set(b, new HashMap<>());
        srcGroupUsersF.set(b, new HashMap<>());

        // Group 1: has uSNChanged and members (one blank, one valid)
        final String group1Dn = "CN=Group10,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";
        Attributes   g1       = new BasicAttributes(true);
        g1.put(new BasicAttribute("cn", "Group10"));
        g1.put(new BasicAttribute("uSNChanged", "3001"));
        BasicAttribute members = new BasicAttribute("member");
        members.add("");
        final String user1Dn = "uid=user1,ou=people,dc=example,dc=com";
        members.add(user1Dn);
        g1.put(members);

        // Group 2: no uSNChanged, but has modifytimestamp; no members
        final String group2Dn = "CN=Group11,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";
        Attributes   g2       = new BasicAttributes(true);
        g2.put(new BasicAttribute("cn", "Group11"));
        g2.put(new BasicAttribute("modifytimestamp", "20990101000005"));

        class TestGroupResult extends SearchResult {
            private final String nameInNs;

            TestGroupResult(String name, Attributes a, String nameInNs) {
                super(name, null, a);
                this.nameInNs = nameInNs;
            }

            @Override
            public String getNameInNamespace() {
                return nameInNs;
            }
        }

        final SearchResult sr1 = new TestGroupResult(group1Dn, g1, group1Dn);
        final SearchResult sr2 = new TestGroupResult(group2Dn, g2, group2Dn);

        class MultiEnum implements NamingEnumeration<SearchResult> {
            private int idx;

            @Override
            public SearchResult next() {
                return idx++ == 0 ? sr1 : sr2;
            }

            @Override
            public boolean hasMore() {
                return idx < 2;
            }

            @Override
            public void close() {}

            @Override
            public boolean hasMoreElements() {
                return hasMore();
            }

            @Override
            public SearchResult nextElement() {
                return next();
            }
        }

        try (MockedConstruction<InitialLdapContext> mocked = Mockito.mockConstruction(InitialLdapContext.class, (mock, ctx) -> {
            Mockito.when(mock.search(Mockito.anyString(), Mockito.anyString(), Mockito.any(SearchControls.class)))
                    .thenReturn(new MultiEnum());
            Mockito.when(mock.getResponseControls()).thenReturn(null);
        })) {
            Method getGroups = LdapUserGroupBuilder.class.getDeclaredMethod("getGroups", boolean.class);
            getGroups.setAccessible(true);
            Object ret = getGroups.invoke(b, true);

            // Highest delta should be at least from uSNChanged (3001) and modifytimestamp branch executed
            long highest = ((Number) ret).longValue();
            assertTrue(highest >= 3001L);
            Field tsF = LdapUserGroupBuilder.class.getDeclaredField("deltaSyncGroupTimeStamp");
            tsF.setAccessible(true);
            assertEquals("20990101000005", tsF.get(b));

            // Verify extended filters were composed correctly
            Field extGrpF = LdapUserGroupBuilder.class.getDeclaredField("extendedGroupSearchFilter");
            Field extAllF = LdapUserGroupBuilder.class.getDeclaredField("extendedAllGroupsSearchFilter");
            extGrpF.setAccessible(true);
            extAllF.setAccessible(true);
            String extGrp = (String) extGrpF.get(b);
            String extAll = (String) extAllF.get(b);
            assertTrue(extGrp.startsWith("(objectclass="));
            assertTrue(extAll.contains("modifyTimestamp>="));
            assertTrue(extAll.contains("1970"));

            @SuppressWarnings("unchecked")
            Map<String, Map<String, String>> srcGroups = (Map<String, Map<String, String>>) srcGroupsF.get(b);
            assertTrue(srcGroups.containsKey(group1Dn));
            assertTrue(srcGroups.containsKey(group2Dn));

            @SuppressWarnings("unchecked")
            Table<String, String, String> gut = (Table<String, String, String>) gutF.get(b);
            assertTrue(gut.contains(group1Dn, user1Dn));

            @SuppressWarnings("unchecked")
            Map<String, Map<String, String>> srcUsers = (Map<String, Map<String, String>>) srcUsersF.get(b);
            assertTrue(srcUsers.containsKey(user1Dn));

            @SuppressWarnings("unchecked")
            Map<String, java.util.Set<String>> srcGroupUsers = (Map<String, java.util.Set<String>>) srcGroupUsersF.get(b);
            assertTrue(srcGroupUsers.containsKey(group2Dn));
            assertTrue(srcGroupUsers.get(group2Dn).isEmpty());
        }
    }

    @Test
    public void testX_goUpGroupHierarchyLdap_fetches_nested_groups_and_members() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.ldap.group.searchfilter", "cn=Nested*");

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        // Disable user search so members are added to sourceUsers directly
        Field fUserEnabled = LdapUserGroupBuilder.class.getDeclaredField("userSearchEnabled");
        fUserEnabled.setAccessible(true);
        fUserEnabled.setBoolean(b, false);

        // Prepare internal structures used by goUpGroupHierarchyLdap
        Field gutF       = LdapUserGroupBuilder.class.getDeclaredField("groupUserTable");
        Field srcUsersF  = LdapUserGroupBuilder.class.getDeclaredField("sourceUsers");
        Field srcGroupsF = LdapUserGroupBuilder.class.getDeclaredField("sourceGroups");
        gutF.setAccessible(true);
        srcUsersF.setAccessible(true);
        srcGroupsF.setAccessible(true);
        gutF.set(b, HashBasedTable.create());
        srcUsersF.set(b, new HashMap<>());
        srcGroupsF.set(b, new HashMap<>());

        // Parent group DN used to build filter
        final String parentGroupDn = "CN=Parent,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";

        // Valid child group with one valid member and displayname
        final String childGroupDn = "CN=NestedGroup,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";
        Attributes   gValid       = new BasicAttributes(true);
        gValid.put(new BasicAttribute("cn", "NestedGroup"));
        BasicAttribute childMembers = new BasicAttribute("member");
        childMembers.add(parentGroupDn); // simulate nesting by including parent DN
        childMembers.add("");          // empty member path
        final String userDn = "uid=nestedUser,ou=people,dc=example,dc=com";
        childMembers.add(userDn);
        gValid.put(childMembers);
        gValid.put(new BasicAttribute("displayname", "Nested Display"));

        // Another group entry with no members
        final String noMembersGroupDn = "CN=NoMembers,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";
        Attributes   gNoMembers       = new BasicAttributes(true);
        gNoMembers.put(new BasicAttribute("cn", "NoMembers"));

        class TestGroupResult extends SearchResult {
            private final String nameInNs;

            TestGroupResult(String name, Attributes a, String nameInNs) {
                super(name, null, a);
                this.nameInNs = nameInNs;
            }

            @Override
            public String getNameInNamespace() {
                return nameInNs;
            }
        }

        final SearchResult srNull      = null;
        final SearchResult srValid     = new TestGroupResult(childGroupDn, gValid, childGroupDn);
        final SearchResult srNoMembers = new TestGroupResult(noMembersGroupDn, gNoMembers, noMembersGroupDn);

        class EnumThree implements NamingEnumeration<SearchResult> {
            private int idx;

            @Override
            public SearchResult next() {
                return idx++ == 0 ? srNull : (idx == 2 ? srValid : srNoMembers);
            }

            @Override
            public boolean hasMore() {
                return idx < 3;
            }

            @Override
            public void close() {}

            @Override
            public boolean hasMoreElements() {
                return hasMore();
            }

            @Override
            public SearchResult nextElement() {
                return next();
            }
        }

        try (MockedConstruction<InitialLdapContext> mocked = Mockito.mockConstruction(InitialLdapContext.class, (mock, ctx) -> {
            Mockito.when(mock.search(Mockito.anyString(), Mockito.anyString(), Mockito.any(SearchControls.class)))
                    .thenReturn(new EnumThree());
            Mockito.when(mock.getResponseControls()).thenReturn(null);
        })) {
            Method goUp = LdapUserGroupBuilder.class.getDeclaredMethod("goUpGroupHierarchyLdap", Set.class, int.class);
            goUp.setAccessible(true);

            Set<String> start = new HashSet<>();
            start.add(parentGroupDn);

            assertDoesNotThrow(() -> goUp.invoke(b, start, 1));

            @SuppressWarnings("unchecked")
            Map<String, Map<String, String>> srcGroups = (Map<String, Map<String, String>>) srcGroupsF.get(b);
            assertTrue(srcGroups.containsKey(childGroupDn));
            assertFalse(srcGroups.containsKey(noMembersGroupDn));

            @SuppressWarnings("unchecked")
            Map<String, Map<String, String>> srcUsers = (Map<String, Map<String, String>>) srcUsersF.get(b);
            assertTrue(srcUsers.containsKey(userDn));

            @SuppressWarnings("unchecked")
            Table<String, String, String> gut = (Table<String, String, String>) gutF.get(b);
            assertTrue(gut.contains(childGroupDn, userDn));
        }
    }

    @Test
    public void testY_getDNForMemberOf_builds_memberof_filter() throws Throwable {
        resetConfig();
        configureMinimalLdapConfig();

        LdapUserGroupBuilder b = new LdapUserGroupBuilder();
        b.init();

        // Create sequence: null entry, entry with null attributes, entry missing groupNameAttr, valid entry
        final String validGroupDn = "CN=MyGroup,OU=Groups,DC=ranger,DC=qe,DC=hortonworks,DC=com";

        class TestResult extends SearchResult {
            private final String nameInNs;

            TestResult(String name, Attributes a, String nameInNs) {
                super(name, null, a);
                this.nameInNs = nameInNs;
            }

            @Override
            public String getNameInNamespace() {
                return nameInNs;
            }
        }

        final SearchResult srNull       = null;
        final SearchResult srNoAttrs    = new TestResult(validGroupDn, null, validGroupDn);
        Attributes         missingAttrs = new BasicAttributes(true);
        missingAttrs.put(new BasicAttribute("displayname", "ignored"));
        final SearchResult srNoCn  = new TestResult(validGroupDn, missingAttrs, validGroupDn);
        Attributes         okAttrs = new BasicAttributes(true);
        okAttrs.put(new BasicAttribute("cn", "MyGroup"));
        final SearchResult srValid = new TestResult(validGroupDn, okAttrs, validGroupDn);

        class FourEnum implements NamingEnumeration<SearchResult> {
            private int idx;

            @Override
            public SearchResult next() {
                if (idx == 0) {
                    idx++;
                    return srNull;
                }
                if (idx == 1) {
                    idx++;
                    return srNoAttrs;
                }
                if (idx == 2) {
                    idx++;
                    return srNoCn;
                }
                idx++;
                return srValid;
            }

            @Override
            public boolean hasMore() {
                return idx < 4;
            }

            @Override
            public void close() {}

            @Override
            public boolean hasMoreElements() {
                return hasMore();
            }

            @Override
            public SearchResult nextElement() {
                return next();
            }
        }

        try (MockedConstruction<InitialLdapContext> mocked = Mockito.mockConstruction(InitialLdapContext.class, (mock, ctx) -> {
            Mockito.when(mock.search(Mockito.anyString(), Mockito.anyString(), Mockito.any(SearchControls.class)))
                    .thenReturn(new FourEnum());
            Mockito.when(mock.getResponseControls()).thenReturn(null);
        })) {
            Method getDN = LdapUserGroupBuilder.class.getDeclaredMethod("getDNForMemberOf", String.class);
            getDN.setAccessible(true);
            Object ret = getDN.invoke(b, "cn=My*");

            assertEquals("(memberof=" + validGroupDn + ")", ret);
        }
    }

    private static void configureMinimalLdapConfig() throws Exception {
        UserGroupSyncConfig cfg = UserGroupSyncConfig.getInstance();
        cfg.setProperty("ranger.usersync.ldap.url", "ldap://127.0.0.1:389");
        cfg.setProperty("ranger.usersync.ldap.binddn", "cn=admin,dc=example,dc=com");
        cfg.setProperty("ranger.usersync.ldap.ldapbindpassword", "secret");
        cfg.setProperty("ranger.usersync.ldap.searchBase", "dc=example,dc=com");
        cfg.setProperty("ranger.usersync.ldap.user.searchbase", "ou=people,dc=example,dc=com");
        cfg.setProperty("ranger.usersync.ldap.group.searchbase", "ou=groups,dc=example,dc=com");
    }

    private static void resetConfig() throws Exception {
        Field f = UserGroupSyncConfig.class.getDeclaredField("me");
        f.setAccessible(true);
        f.set(null, null);
    }

    public static class RecordingSink implements UserGroupSink {
        public boolean addOrUpdateCalled;
        public boolean auditCalled;

        @Override
        public void init() {}

        @Override
        public void postUserGroupAuditInfo(UgsyncAuditInfo ugsyncAuditInfo) {
            auditCalled = true;
        }

        @Override
        public void addOrUpdateUsersGroups(Map<String, Map<String, String>> sourceGroups, Map<String, Map<String, String>> sourceUsers, Map<String, Set<String>> sourceGroupUsers, boolean computeDeletes) {
            addOrUpdateCalled = true;
        }
    }

    public static class CapturingSink extends RecordingSink {
        public boolean computeDeletesFlag;

        @Override
        public void addOrUpdateUsersGroups(Map<String, Map<String, String>> sourceGroups, Map<String, Map<String, String>> sourceUsers, Map<String, Set<String>> sourceGroupUsers, boolean computeDeletes) {
            super.addOrUpdateUsersGroups(sourceGroups, sourceUsers, sourceGroupUsers, computeDeletes);
            this.computeDeletesFlag = computeDeletes;
        }
    }
}
