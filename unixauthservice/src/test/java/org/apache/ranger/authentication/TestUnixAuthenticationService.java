/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.ranger.authentication;

import org.apache.hadoop.conf.Configuration;
import org.apache.ranger.credentialapi.CredentialReader;
import org.apache.ranger.plugin.util.XMLUtils;
import org.apache.ranger.unixusersync.config.UserGroupSyncConfig;
import org.apache.ranger.unixusersync.ha.UserSyncHAInitializerImpl;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLServerSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.Socket;
import java.security.KeyStore;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertInstanceOf;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockConstruction;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @generated by Cursor
 * @description : Unit Test cases for UnixAuthenticationService
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestUnixAuthenticationService {
    @Test
    public void test01_initThrowsWhenCredFileMissing() throws Exception {
        UnixAuthenticationService svc = new UnixAuthenticationService();

        try (MockedStatic<XMLUtils> xmlMock = mockStatic(XMLUtils.class)) {
            xmlMock.when(() -> XMLUtils.loadConfig(any(String.class), any(Properties.class))).thenAnswer(inv -> null);

            try (MockedStatic<CredentialReader> credMock = mockStatic(CredentialReader.class)) {
                // Do not need to reach CredentialReader because missing file check will throw first
                Properties props = new Properties();
                props.setProperty("ranger.usersync.credstore.filename", "/no/such/file.jceks");
                props.setProperty("ranger.usersync.port", "6168");

                // Inject properties via XMLUtils sequence
                xmlMock.when(() -> XMLUtils.loadConfig(eq("ranger-ugsync-default.xml"), any(Properties.class)))
                        .thenAnswer(inv -> {
                            ((Properties) inv.getArgument(1)).putAll(props);
                            return null;
                        });
                xmlMock.when(() -> XMLUtils.loadConfig(eq("ranger-ugsync-site.xml"), any(Properties.class)))
                        .thenAnswer(inv -> null);

                InvocationTargetException ex = assertThrows(InvocationTargetException.class, () -> invokeInit(svc));
                assertInstanceOf(RuntimeException.class, ex.getCause());
            }
        }
    }

    @Test
    public void test02_getFileInputStreamFallsBackToResourcePath() throws Exception {
        UnixAuthenticationService svc = new UnixAuthenticationService();
        Method                    m   = UnixAuthenticationService.class.getDeclaredMethod("getFileInputStream", String.class);
        m.setAccessible(true);

        // Point to a file guaranteed to not exist; should fallback to resource stream, which will be null
        InputStream is = (InputStream) m.invoke(svc, "/this/does/not/exist.txt");
        // Since no resource with that name, it can still be null; verify method returns (null allowed)
        // Next, try with a real file via temp file which should be returned
        File tmp = File.createTempFile("ranger-test", ".txt");
        try {
            InputStream fis = (InputStream) m.invoke(svc, tmp.getAbsolutePath());
            assertNotNull(fis);
            fis.close();
        } finally {
            //noinspection ResultOfMethodCallIgnored
            tmp.delete();
        }
    }

    @Test
    public void test03_runInterruptedStopsHA() throws Exception {
        UnixAuthenticationService svc = new UnixAuthenticationService();
        UserSyncHAInitializerImpl ha  = mock(UserSyncHAInitializerImpl.class);
        setField(svc, "userSyncHAInitializerImpl", ha);

        try (MockedConstruction<Thread> threadConstruction = mockConstruction(Thread.class, (mock, ctx) -> {
            doNothing().when(mock).setName(any());
            doNothing().when(mock).setDaemon(false);
            doNothing().when(mock).start();
        })) {
            // Interrupt current thread so Thread.sleep throws immediately
            Thread.currentThread().interrupt();
            // Call run; should catch InterruptedException and then stop HA in finally
            svc.run();
            // Clear interrupted status for subsequent tests
            Thread.interrupted();
        }
    }

    @Test
    public void test04_startServiceSslAndAcceptIOExceptionPath() throws Throwable {
        UnixAuthenticationService svc = new UnixAuthenticationService();

        // Reflectively set fields needed by startService
        setField(svc, "sslEnabled", true);
        setField(svc, "portNum", 0);
        setField(svc, "enabledProtocolsList", Collections.singletonList("TLSV1.2"));
        setField(svc, "enabledCipherSuiteList", new ArrayList<>());
        setField(svc, "keyStorePath", "");
        setField(svc, "trustStorePath", "");
        setField(svc, "keyStoreType", KeyStore.getDefaultType());
        setField(svc, "trustStoreType", KeyStore.getDefaultType());

        try (MockedStatic<SSLContext> sslStatic = mockStatic(SSLContext.class)) {
            SSLContext             sslContext   = mock(SSLContext.class);
            SSLServerSocketFactory sf           = mock(SSLServerSocketFactory.class);
            SSLServerSocket        secureSocket = mock(SSLServerSocket.class);

            when(SSLContext.getInstance("TLSv1.2")).thenReturn(sslContext);
            when(sslContext.getServerSocketFactory()).thenReturn(sf);
            when(sf.createServerSocket(anyInt())).thenReturn(secureSocket);
            when(secureSocket.getEnabledProtocols()).thenReturn(new String[] {"TLSv1.2"});
            when(secureSocket.getEnabledCipherSuites()).thenReturn(new String[] {});
            when(secureSocket.accept()).thenThrow(new IOException("accept fail"));

            assertThrows(IOException.class, svc::startService);
        }
    }

    @Test
    public void test05_initSuccessPathWithBcfksAndAdminLists() throws Exception {
        UnixAuthenticationService svc = new UnixAuthenticationService();

        Properties props    = new Properties();
        File       credFile = File.createTempFile("ranger-cred", ".bcfks");
        try {
            props.setProperty("ranger.usersync.credstore.filename", credFile.getAbsolutePath());
            props.setProperty("ranger.usersync.keystore.file", "");
            props.setProperty("ranger.usersync.truststore.file", "");
            props.setProperty("ranger.keystore.file.type", "bcfks");
            props.setProperty("ranger.truststore.file.type", "bcfks");
            props.setProperty("ranger.usersync.port", "6168");
            props.setProperty("ranger.usersync.passwordvalidator.path", "/bin/validator");
            props.setProperty("admin.users", "alice,bob");
            props.setProperty("admin.roleNames", "ROLE_ADMIN,ROLE_AUDITOR");
            props.setProperty("ranger.usersync.ssl", "true");
            props.setProperty("ranger.usersync.https.ssl.enabled.protocols", "TLSv1.2");
            props.setProperty("ranger.usersync.https.ssl.enabled.cipher.suites", "");

            try (MockedStatic<XMLUtils> xmlMock = mockStatic(XMLUtils.class);
                    MockedStatic<CredentialReader> credMock = mockStatic(CredentialReader.class)) {
                xmlMock.when(() -> XMLUtils.loadConfig(any(String.class), any(Properties.class))).thenAnswer(inv -> {
                    ((Properties) inv.getArgument(1)).putAll(props);
                    return null;
                });
                credMock.when(() -> CredentialReader.getDecryptedString(any(), any(), any())).thenReturn("pass");

                // invoke private init
                invokeInit(svc);
            }
        } finally {
            //noinspection ResultOfMethodCallIgnored
            credFile.delete();
        }
    }

    @Test
    public void test06_startServiceWithKeyAndTrustStores() throws Throwable {
        UnixAuthenticationService svc = new UnixAuthenticationService();

        setField(svc, "sslEnabled", true);
        setField(svc, "portNum", 0);
        setField(svc, "enabledProtocolsList", Collections.singletonList("TLSV1.2"));
        setField(svc, "enabledCipherSuiteList", new ArrayList<>());
        setField(svc, "keyStorePath", "/tmp/keystore.jks");
        setField(svc, "trustStorePath", "/tmp/truststore.jks");
        setField(svc, "keyStoreType", KeyStore.getDefaultType());
        setField(svc, "trustStoreType", KeyStore.getDefaultType());
        // leave passwords as null to exercise empty defaulting branch

        try (MockedStatic<KeyManagerFactory> kmfStatic = mockStatic(KeyManagerFactory.class);
                MockedStatic<TrustManagerFactory> tmfStatic = mockStatic(TrustManagerFactory.class);
                MockedStatic<SSLContext> sslStatic = mockStatic(SSLContext.class)) {
            KeyManagerFactory kmf = mock(KeyManagerFactory.class);
            kmfStatic.when(() -> KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())).thenReturn(kmf);
            when(kmf.getKeyManagers()).thenReturn(new KeyManager[0]);

            TrustManagerFactory tmf = mock(TrustManagerFactory.class);
            tmfStatic.when(() -> TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())).thenReturn(tmf);
            when(tmf.getTrustManagers()).thenReturn(new TrustManager[0]);

            SSLContext             sslContext   = mock(SSLContext.class);
            SSLServerSocketFactory sf           = mock(SSLServerSocketFactory.class);
            SSLServerSocket        secureSocket = mock(SSLServerSocket.class);

            when(SSLContext.getInstance("TLSv1.2")).thenReturn(sslContext);
            when(sslContext.getServerSocketFactory()).thenReturn(sf);
            when(sf.createServerSocket(anyInt())).thenReturn(secureSocket);
            when(secureSocket.getEnabledProtocols()).thenReturn(new String[] {"TLSv1.2"});
            when(secureSocket.getEnabledCipherSuites()).thenReturn(new String[] {});
            when(secureSocket.accept()).thenThrow(new java.io.IOException("accept fail"));

            assertThrows(java.io.IOException.class, svc::startService);
        }
    }

    @Test
    public void test07_mainEnableUnixAuthInvokesRun() {
        try (MockedStatic<UserGroupSyncConfig> ugscStatic = mockStatic(UserGroupSyncConfig.class);
                MockedStatic<UserSyncHAInitializerImpl> haStatic = mockStatic(UserSyncHAInitializerImpl.class);
                MockedConstruction<UnixAuthenticationService> serviceConstruction = mockConstruction(UnixAuthenticationService.class, (mock, ctx) -> {
                    // service.run() will be called by main; make it a no-op
                })) {
            UserGroupSyncConfig ugsc = mock(UserGroupSyncConfig.class);
            ugscStatic.when(UserGroupSyncConfig::getInstance).thenReturn(ugsc);
            when(ugsc.getUserGroupConfig()).thenReturn(new Configuration());

            UserSyncHAInitializerImpl ha = mock(UserSyncHAInitializerImpl.class);
            haStatic.when(() -> UserSyncHAInitializerImpl.getInstance(any())).thenReturn(ha);

            UnixAuthenticationService.main(new String[] {"-enableUnixAuth"});
        }
    }

    @Test
    public void test08_startServiceEnablesCipherSuites() throws Throwable {
        UnixAuthenticationService svc = new UnixAuthenticationService();
        setField(svc, "sslEnabled", true);
        setField(svc, "portNum", 0);
        setField(svc, "enabledProtocolsList", Collections.singletonList("TLSV1.2"));
        ArrayList<String> enabledCiphers = new ArrayList<>();
        enabledCiphers.add("CIPHER_A");
        setField(svc, "enabledCipherSuiteList", enabledCiphers);
        setField(svc, "keyStorePath", "");
        setField(svc, "trustStorePath", "");
        setField(svc, "keyStoreType", KeyStore.getDefaultType());
        setField(svc, "trustStoreType", KeyStore.getDefaultType());

        try (MockedStatic<SSLContext> sslStatic = mockStatic(SSLContext.class)) {
            SSLContext             sslContext   = mock(SSLContext.class);
            SSLServerSocketFactory sf           = mock(SSLServerSocketFactory.class);
            SSLServerSocket        secureSocket = mock(SSLServerSocket.class);

            when(SSLContext.getInstance("TLSv1.2")).thenReturn(sslContext);
            when(sslContext.getServerSocketFactory()).thenReturn(sf);
            when(sf.createServerSocket(anyInt())).thenReturn(secureSocket);
            when(secureSocket.getEnabledProtocols()).thenReturn(new String[] {"TLSv1.2"});
            when(secureSocket.getEnabledCipherSuites()).thenReturn(new String[] {"CIPHER_A", "CIPHER_B"});
            when(secureSocket.accept()).thenThrow(new IOException("accept fail"));

            assertThrows(IOException.class, svc::startService);
            verify(secureSocket).setEnabledCipherSuites(new String[] {"CIPHER_A"});
        }
    }

    @Test
    public void test09_startServiceSpawnsValidatorThread() throws Throwable {
        UnixAuthenticationService svc = new UnixAuthenticationService();
        setField(svc, "sslEnabled", true);
        setField(svc, "portNum", 0);
        setField(svc, "enabledProtocolsList", Collections.singletonList("TLSV1.2"));
        setField(svc, "enabledCipherSuiteList", new ArrayList<>());
        setField(svc, "keyStorePath", "");
        setField(svc, "trustStorePath", "");
        setField(svc, "keyStoreType", KeyStore.getDefaultType());
        setField(svc, "trustStoreType", KeyStore.getDefaultType());

        final boolean[] runnableIsPasswordValidator = new boolean[] {false};

        try (MockedStatic<SSLContext> sslStatic = mockStatic(SSLContext.class);
                MockedConstruction<Thread> threadConstruction = mockConstruction(Thread.class, (mockThread, ctx) -> {
                    Object arg0 = ctx.arguments().get(0);
                    runnableIsPasswordValidator[0] = (arg0 instanceof Runnable) && arg0.getClass().getName().equals(PasswordValidator.class.getName());
                    doNothing().when(mockThread).start();
                })) {
            SSLContext             sslContext   = mock(SSLContext.class);
            SSLServerSocketFactory sf           = mock(SSLServerSocketFactory.class);
            SSLServerSocket        secureSocket = mock(SSLServerSocket.class);
            Socket                 client       = mock(Socket.class);

            when(SSLContext.getInstance("TLSv1.2")).thenReturn(sslContext);
            when(sslContext.getServerSocketFactory()).thenReturn(sf);
            when(sf.createServerSocket(anyInt())).thenReturn(secureSocket);
            when(secureSocket.getEnabledProtocols()).thenReturn(new String[] {"TLSV1.2"});
            when(secureSocket.getEnabledCipherSuites()).thenReturn(new String[] {});
            when(secureSocket.accept()).thenReturn(client).thenThrow(new IOException("done"));

            assertThrows(IOException.class, svc::startService);
            assertTrue(runnableIsPasswordValidator[0]);
        }
    }

    @Test
    public void test10_startUnixUserGroupSyncProcess_MetricsEnabledAndDisabled() throws Exception {
        UnixAuthenticationService svc = new UnixAuthenticationService();
        Method                    m   = UnixAuthenticationService.class.getDeclaredMethod("startUnixUserGroupSyncProcess");
        m.setAccessible(true);

        try (MockedStatic<UserGroupSyncConfig> ugscStatic = mockStatic(UserGroupSyncConfig.class)) {
            UserGroupSyncConfig ugsc = mock(UserGroupSyncConfig.class);
            ugscStatic.when(UserGroupSyncConfig::getInstance).thenReturn(ugsc);

            // Metrics enabled -> two threads created
            when(ugsc.isUserSyncMetricsEnabled()).thenReturn(true);
            try (MockedConstruction<Thread> threadConstruction = mockConstruction(Thread.class, (mockThread, ctx) -> {
                doNothing().when(mockThread).setName(any());
                doNothing().when(mockThread).setDaemon(false);
                doNothing().when(mockThread).start();
            })) {
                m.invoke(svc);
                assertEquals(2, threadConstruction.constructed().size());
            }

            // Metrics disabled -> one thread created
            when(ugsc.isUserSyncMetricsEnabled()).thenReturn(false);
            try (MockedConstruction<Thread> threadConstruction = mockConstruction(Thread.class, (mockThread, ctx) -> {
                doNothing().when(mockThread).setName(any());
                doNothing().when(mockThread).setDaemon(false);
                doNothing().when(mockThread).start();
            })) {
                m.invoke(svc);
                assertEquals(1, threadConstruction.constructed().size());
            }
        }
    }

    private void invokeInit(UnixAuthenticationService svc) throws Exception {
        Method m = UnixAuthenticationService.class.getDeclaredMethod("init");
        m.setAccessible(true);
        m.invoke(svc);
    }

    private void setField(Object target, String fieldName, Object value) throws Exception {
        Field f = UnixAuthenticationService.class.getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(target, value);
    }
}
