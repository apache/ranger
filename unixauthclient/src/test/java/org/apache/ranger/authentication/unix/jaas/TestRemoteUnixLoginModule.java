/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.ranger.authentication.unix.jaas;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import sun.security.x509.AlgorithmId;
import sun.security.x509.CertificateAlgorithmId;
import sun.security.x509.CertificateSerialNumber;
import sun.security.x509.CertificateValidity;
import sun.security.x509.CertificateVersion;
import sun.security.x509.CertificateX509Key;
import sun.security.x509.X500Name;
import sun.security.x509.X509CertImpl;
import sun.security.x509.X509CertInfo;

import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLServerSocketFactory;
import javax.security.auth.Subject;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.UnsupportedCallbackException;
import javax.security.auth.login.LoginException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.Principal;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @generated by Cursor
 * @description : Unit Test cases for RemoteUnixLoginModule
 */

@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class TestRemoteUnixLoginModule {
    @Test
    public void test01_login_success_commit_addsPrincipals_and_logout_clears() throws Exception {
        try (OneShotAuthServer server = new OneShotAuthServer("OK: g1, g2")) {
            RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
            Subject               subject = new Subject();
            Map<String, Object>   opts    = baseOptions("127.0.0.1", server.getPort());
            m.initialize(subject, fixedCredentials("alice", "secret"), new HashMap<>(), opts);

            assertTrue(m.login());
            assertTrue(m.commit());

            Set<Principal> principals = subject.getPrincipals();
            assertTrue(principals.stream().anyMatch(p -> p instanceof UnixUserPrincipal && p.getName().equals("alice")));
            assertTrue(principals.stream().anyMatch(p -> p instanceof UnixGroupPrincipal && p.getName().equals("g1")));
            assertTrue(principals.stream().anyMatch(p -> p instanceof UnixGroupPrincipal && p.getName().equals("g2")));

            assertTrue(m.logout());
            assertTrue(subject.getPrincipals().isEmpty());
        }
    }

    @Test
    public void test02_login_failed_throws_LoginException() throws Exception {
        try (OneShotAuthServer server = new OneShotAuthServer("FAILED: Invalid Password")) {
            RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
            Subject               subject = new Subject();
            Map<String, Object>   opts    = baseOptions("127.0.0.1", server.getPort());
            m.initialize(subject, fixedCredentials("alice", "secret"), new HashMap<>(), opts);
            assertThrows(LoginException.class, m::login);
            assertFalse(m.commit());
        }
    }

    @Test
    public void test03_login_nullReply_throws_LoginException() throws Exception {
        try (OneShotAuthServer server = new OneShotAuthServer(null)) {
            RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
            Subject               subject = new Subject();
            Map<String, Object>   opts    = baseOptions("127.0.0.1", server.getPort());
            m.initialize(subject, fixedCredentials("bob", "x"), new HashMap<>(), opts);
            assertThrows(LoginException.class, m::login);
        }
    }

    @Test
    public void test04_login_disabled_returnsFalse_and_commitClearsPrincipals() throws Exception {
        RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
        Subject               subject = new Subject();
        Map<String, Object>   opts    = baseOptions("localhost", 65535);
        opts.put("ranger.unixauth.remote.login.enabled", "false");
        m.initialize(subject, fixedCredentials("tom", "y"), new HashMap<>(), opts);

        assertFalse(m.login());
        assertFalse(m.commit());
        assertTrue(subject.getPrincipals().isEmpty());
    }

    @Test
    public void test05_ssl_disabledValidation_connectFailure_throwsLoginException() {
        RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
        Subject               subject = new Subject();
        Map<String, Object>   opts    = baseOptions("127.0.0.1", 65000);
        opts.put("ranger.unixauth.ssl.enabled", "true");
        opts.put("ranger.unixauth.server.cert.validation", "false");
        m.initialize(subject, fixedCredentials("alice", "secret"), new HashMap<>(), opts);
        assertThrows(LoginException.class, m::login);
    }

    @Test
    public void test06_ssl_withTruststore_loadFails_throwsLoginException() {
        RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
        Subject               subject = new Subject();
        Map<String, Object>   opts    = baseOptions("127.0.0.1", 65001);
        opts.put("ranger.unixauth.ssl.enabled", "true");
        opts.put("ranger.unixauth.server.cert.validation", "true");
        opts.put("ranger.unixauth.truststore", "nonexistent.jks");
        opts.put("ranger.unixauth.truststore.password", "");
        m.initialize(subject, fixedCredentials("bob", "pw"), new HashMap<>(), opts);
        assertThrows(LoginException.class, m::login);
    }

    @Test
    public void test07_ssl_withKeystore_loadFails_throwsLoginException() {
        RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
        Subject               subject = new Subject();
        Map<String, Object>   opts    = baseOptions("127.0.0.1", 65002);
        opts.put("ranger.unixauth.ssl.enabled", "true");
        opts.put("ranger.unixauth.keystore", "nonexistent-keystore.jks");
        opts.put("ranger.unixauth.keystore.password", "");
        // disable server cert validation to avoid needing truststore
        opts.put("ranger.unixauth.server.cert.validation", "false");
        m.initialize(subject, fixedCredentials("carol", "pw"), new HashMap<>(), opts);
        assertThrows(LoginException.class, m::login);
    }

    @Test
    public void test08_abort_resetsLoginState_and_commitReturnsFalse() throws Exception {
        try (OneShotAuthServer server = new OneShotAuthServer("OK:")) {
            RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
            Subject               subject = new Subject();
            Map<String, Object>   opts    = baseOptions("127.0.0.1", server.getPort());
            m.initialize(subject, fixedCredentials("alice", "secret"), new HashMap<>(), opts);

            assertTrue(m.login());
            assertTrue(m.abort());

            // After abort(), loginSuccessful should be false; commit should return false and clear principals
            subject.getPrincipals().add(new UnixUserPrincipal("temp"));
            assertFalse(m.commit());
            assertTrue(subject.getPrincipals().isEmpty());
        }
    }

    @Test
    public void test09_ssl_ignoreValidation_successfulHandshake_executesTrustManager_andLogin() throws Exception {
        try (SslOneShotAuthServer server = new SslOneShotAuthServer("OK: gA, gB")) {
            RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
            Subject               subject = new Subject();
            Map<String, Object>   opts    = baseOptions("127.0.0.1", server.getPort());
            opts.put("ranger.unixauth.ssl.enabled", "true");
            opts.put("ranger.unixauth.server.cert.validation", "false");
            m.initialize(subject, fixedCredentials("eve", "pw"), new HashMap<>(), opts);

            assertTrue(m.login());
            assertTrue(m.commit());
            assertTrue(subject.getPrincipals().stream().anyMatch(p -> p instanceof UnixUserPrincipal && p.getName().equals("eve")));
            assertTrue(subject.getPrincipals().stream().anyMatch(p -> p instanceof UnixGroupPrincipal && p.getName().equals("gA")));
            assertTrue(m.logout());
        }
    }

    @Test
    public void test10_login_callbackHandlerThrowsIOException_isWrappedAsLoginException() {
        RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
        Subject               subject = new Subject();
        Map<String, Object>   opts    = baseOptions("127.0.0.1", 65010);
        CallbackHandler cb = new CallbackHandler() {
            @Override
            public void handle(Callback[] callbacks) throws IOException {
                throw new IOException("boom");
            }
        };
        m.initialize(subject, cb, new HashMap<>(), opts);
        assertThrows(LoginException.class, m::login);
    }

    @Test
    public void test11_login_callbackHandlerThrowsUnsupported_isWrappedAsLoginException() {
        RemoteUnixLoginModule m       = new RemoteUnixLoginModule();
        Subject               subject = new Subject();
        Map<String, Object>   opts    = baseOptions("127.0.0.1", 65011);
        CallbackHandler cb = new CallbackHandler() {
            @Override
            public void handle(Callback[] callbacks) throws UnsupportedCallbackException {
                throw new UnsupportedCallbackException(new NameCallback("user"));
            }
        };
        m.initialize(subject, cb, new HashMap<>(), opts);
        assertThrows(LoginException.class, m::login);
    }

    private static Map<String, Object> baseOptions(String host, int port) {
        Map<String, Object> opts = new HashMap<>();
        opts.put("ranger.unixauth.remote.login.enabled", "true");
        opts.put("ranger.unixauth.service.hostname", host);
        opts.put("ranger.unixauth.service.port", String.valueOf(port));
        opts.put("ranger.unixauth.ssl.enabled", "false");
        opts.put("ranger.unixauth.debug", "false");
        return opts;
    }

    private static CallbackHandler fixedCredentials(String user, String pass) {
        return new CallbackHandler() {
            @Override
            public void handle(Callback[] callbacks) throws IOException {
                for (Callback cb : callbacks) {
                    if (cb instanceof NameCallback) {
                        ((NameCallback) cb).setName(user);
                    } else if (cb instanceof PasswordCallback) {
                        ((PasswordCallback) cb).setPassword(pass.toCharArray());
                    }
                }
            }
        };
    }

    private static class OneShotAuthServer implements AutoCloseable {
        private final ServerSocket   server;
        private final Thread         thread;
        private final CountDownLatch ready = new CountDownLatch(1);
        private final String         reply;

        OneShotAuthServer(String reply) throws IOException {
            this.server = new ServerSocket(0);
            this.reply  = reply;
            this.thread = new Thread(() -> {
                ready.countDown();
                try (Socket s = server.accept()) {
                    BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));
                    in.readLine();
                    try (OutputStreamWriter out = new OutputStreamWriter(s.getOutputStream())) {
                        if (reply != null) {
                            out.write(reply + "\n");
                            out.flush();
                        } else {
                            // close without sending
                        }
                    }
                } catch (IOException ignored) {
                } finally {
                    try {
                        server.close();
                    } catch (IOException ignored) {
                    }
                }
            });
            this.thread.setDaemon(true);
            this.thread.start();
            try {
                ready.await(5, TimeUnit.SECONDS);
            } catch (InterruptedException ignored) {
            }
        }

        @Override
        public void close() {
            try {
                server.close();
            } catch (IOException ignored) {
            }
        }

        int getPort() {
            return server.getLocalPort();
        }
    }

    private static class SslOneShotAuthServer implements AutoCloseable {
        private final SSLServerSocket server;
        private final Thread          thread;
        private final CountDownLatch  ready = new CountDownLatch(1);
        private final String          reply;

        SslOneShotAuthServer(String reply) throws Exception {
            this.reply = reply;

            KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
            kpg.initialize(2048);
            KeyPair kp = kpg.generateKeyPair();

            X509Certificate cert = generateSelfSigned("CN=localhost", kp);

            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
            ks.load(null, null);
            char[] pass = "changeit".toCharArray();
            ks.setKeyEntry("server", kp.getPrivate(), pass, new Certificate[] {cert});

            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            kmf.init(ks, pass);
            KeyManager[] kms = kmf.getKeyManagers();

            SSLContext ctx = SSLContext.getInstance("TLSv1.2");
            ctx.init(kms, null, new SecureRandom());
            SSLServerSocketFactory ssf = ctx.getServerSocketFactory();
            this.server = (SSLServerSocket) ssf.createServerSocket(0);

            this.thread = new Thread(() -> {
                ready.countDown();
                try (Socket s = server.accept()) {
                    BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));
                    in.readLine();
                    try (OutputStreamWriter out = new OutputStreamWriter(s.getOutputStream())) {
                        out.write(reply + "\n");
                        out.flush();
                    }
                } catch (IOException ignored) {
                } finally {
                    try {
                        server.close();
                    } catch (IOException ignored) {
                    }
                }
            });
            this.thread.setDaemon(true);
            this.thread.start();
            try {
                ready.await(5, TimeUnit.SECONDS);
            } catch (InterruptedException ignored) {
            }
        }

        @Override
        public void close() {
            try {
                server.close();
            } catch (IOException ignored) {
            }
        }

        int getPort() {
            return server.getLocalPort();
        }

        private static X509Certificate generateSelfSigned(String dn, KeyPair keyPair) throws Exception {
            long now  = System.currentTimeMillis();
            Date from = new Date(now - 60000);
            Date to   = new Date(now + 86400000L);

            X509CertInfo info = new X509CertInfo();
            info.set(X509CertInfo.VERSION, new CertificateVersion(CertificateVersion.V3));
            info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(new BigInteger(64, new SecureRandom())));
            X500Name owner = new X500Name(dn);
            info.set(X509CertInfo.SUBJECT, owner);
            info.set(X509CertInfo.ISSUER, owner);
            info.set(X509CertInfo.VALIDITY, new CertificateValidity(from, to));
            info.set(X509CertInfo.KEY, new CertificateX509Key(keyPair.getPublic()));
            info.set(X509CertInfo.ALGORITHM_ID, new CertificateAlgorithmId(AlgorithmId.get("SHA256withRSA")));

            X509CertImpl cert = new X509CertImpl(info);
            cert.sign(keyPair.getPrivate(), "SHA256withRSA");
            return cert;
        }
    }
}
